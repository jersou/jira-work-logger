// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

"use strict";

// @ts-nocheck
/* eslint-disable */
let System, __instantiate;
(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    },
  };
  async function dI(mid, src) {
    let id = mid.replace(/\.\w+$/i, "");
    if (id.includes("./")) {
      const [o, ...ia] = id.split("/").reverse(),
        [, ...sa] = src.split("/").reverse(),
        oa = [o];
      let s = 0,
        i;
      while ((i = ia.shift())) {
        if (i === "..") s++;
        else if (i === ".") break;
        else oa.push(i);
      }
      if (s < sa.length) oa.push(...sa.slice(s));
      id = oa.reverse().join("/");
    }
    return r.has(id) ? gExpA(id) : import(mid);
  }

  function gC(id, main) {
    return {
      id,
      import: (m) => dI(m, id),
      meta: { url: id, main },
    };
  }

  function gE(exp) {
    return (id, v) => {
      const e = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(e)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true,
        });
      }
      return v;
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }
  __instantiate = (m, a) => {
    System = __instantiate = undefined;
    rF(m);
    return a ? gExpA(m) : gExp(m);
  };
})();

System.register("https://deno.land/std@0.73.0/bytes/mod", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_1("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_1("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_1("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_1("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_1("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_1("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_1("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_1("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_1("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/hash/sha1", [], function (exports_2, context_2) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, blocks, Sha1;
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            blocks = [];
            Sha1 = class Sha1 {
                constructor(sharedMemory = false) {
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#lastByteIndex = 0;
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                #blocks;
                #block;
                #start;
                #bytes;
                #hBytes;
                #finalized;
                #hashed;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #lastByteIndex;
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) >>> 0;
                        this.#bytes = this.#bytes >>> 0;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f;
                    let j;
                    let t;
                    const blocks = this.#blocks;
                    for (j = 16; j < 80; ++j) {
                        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                        blocks[j] = (t << 1) | (t >>> 31);
                    }
                    for (j = 0; j < 20; j += 5) {
                        f = (b & c) | (~b & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1518500249 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (~a & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1518500249 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (~e & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1518500249 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (~d & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1518500249 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (~c & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1518500249 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 40; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1859775393 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1859775393 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1859775393 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1859775393 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1859775393 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 60; j += 5) {
                        f = (b & c) | (b & d) | (c & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 1894007588 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (a & c) | (b & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 1894007588 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (e & b) | (a & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 1894007588 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (d & a) | (e & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 1894007588 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (c & e) | (d & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 1894007588 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 80; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 899497514 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 899497514 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 899497514 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 899497514 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 899497514 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    this.#h0 = (this.#h0 + a) >>> 0;
                    this.#h1 = (this.#h1 + b) >>> 0;
                    this.#h2 = (this.#h2 + c) >>> 0;
                    this.#h3 = (this.#h3 + d) >>> 0;
                    this.#h4 = (this.#h4 + e) >>> 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return (HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f]);
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                    ];
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(20);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    return buffer;
                }
            };
            exports_2("Sha1", Sha1);
        }
    };
});
System.register("https://deno.land/std@0.73.0/hash/sha256", [], function (exports_3, context_3) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^
                            (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 = ((a >>> 2) | (a << 30)) ^
                                ((a >>> 13) | (a << 19)) ^
                                ((a >>> 22) | (a << 10));
                            s1 = ((e >>> 6) | (e << 26)) ^
                                ((e >>> 11) | (e << 21)) ^
                                ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 = ((d >>> 2) | (d << 30)) ^
                            ((d >>> 13) | (d << 19)) ^
                            ((d >>> 22) | (d << 10));
                        s1 = ((h >>> 6) | (h << 26)) ^
                            ((h >>> 11) | (h << 21)) ^
                            ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 = ((c >>> 2) | (c << 30)) ^
                            ((c >>> 13) | (c << 19)) ^
                            ((c >>> 22) | (c << 10));
                        s1 = ((g >>> 6) | (g << 26)) ^
                            ((g >>> 11) | (g << 21)) ^
                            ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 = ((b >>> 2) | (b << 30)) ^
                            ((b >>> 13) | (b << 19)) ^
                            ((b >>> 22) | (b << 10));
                        s1 = ((f >>> 6) | (f << 26)) ^
                            ((f >>> 11) | (f << 21)) ^
                            ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex += HEX_CHARS[(h7 >> 28) & 0x0f] +
                            HEX_CHARS[(h7 >> 24) & 0x0f] +
                            HEX_CHARS[(h7 >> 20) & 0x0f] +
                            HEX_CHARS[(h7 >> 16) & 0x0f] +
                            HEX_CHARS[(h7 >> 12) & 0x0f] +
                            HEX_CHARS[(h7 >> 8) & 0x0f] +
                            HEX_CHARS[(h7 >> 4) & 0x0f] +
                            HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_3("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code = 0x10000 +
                                    (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_3("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.73.0/encoding/utf8", [], function (exports_4, context_4) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_4 && context_4.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_4("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_4("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_4("encoder", encoder = new TextEncoder());
            exports_4("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.73.0/_util/assert", [], function (exports_5, context_5) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_5 && context_5.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_5("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_5("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.73.0/io/bufio", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/_util/assert"], function (exports_6, context_6) {
    "use strict";
    var mod_ts_1, assert_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_6 && context_6.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_6("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_6("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_6("readLines", readLines);
    return {
        setters: [
            function (mod_ts_1_1) {
                mod_ts_1 = mod_ts_1_1;
            },
            function (assert_ts_1_1) {
                assert_ts_1 = assert_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_6("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_6("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_1.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_1.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_1.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_1.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_6("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_6("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_6("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/deferred", [], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_7("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/delay", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_8("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/mux_async_iterator", ["https://deno.land/std@0.73.0/async/deferred"], function (exports_9, context_9) {
    "use strict";
    var deferred_ts_1, MuxAsyncIterator;
    var __moduleName = context_9 && context_9.id;
    return {
        setters: [
            function (deferred_ts_1_1) {
                deferred_ts_1 = deferred_ts_1_1;
            }
        ],
        execute: function () {
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.throws = [];
                    this.signal = deferred_ts_1.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    try {
                        const { value, done } = await iterator.next();
                        if (done) {
                            --this.iteratorCount;
                        }
                        else {
                            this.yields.push({ iterator, value });
                        }
                    }
                    catch (e) {
                        this.throws.push(e);
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        await this.signal;
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        if (this.throws.length) {
                            for (const e of this.throws) {
                                throw e;
                            }
                            this.throws.length = 0;
                        }
                        this.yields.length = 0;
                        this.signal = deferred_ts_1.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_9("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/pool", [], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    function pooledMap(poolLimit, array, iteratorFn) {
        const res = new TransformStream({
            async transform(p, controller) {
                controller.enqueue(await p);
            },
        });
        (async () => {
            const writer = res.writable.getWriter();
            const executing = [];
            for await (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                writer.write(p);
                const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                executing.push(e);
                if (executing.length >= poolLimit) {
                    await Promise.race(executing);
                }
            }
            await Promise.all(executing);
            writer.close();
        })();
        return res.readable.getIterator();
    }
    exports_10("pooledMap", pooledMap);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/mod", ["https://deno.land/std@0.73.0/async/deferred", "https://deno.land/std@0.73.0/async/delay", "https://deno.land/std@0.73.0/async/mux_async_iterator", "https://deno.land/std@0.73.0/async/pool"], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_11(exports);
    }
    return {
        setters: [
            function (deferred_ts_2_1) {
                exportStar_1(deferred_ts_2_1);
            },
            function (delay_ts_1_1) {
                exportStar_1(delay_ts_1_1);
            },
            function (mux_async_iterator_ts_1_1) {
                exportStar_1(mux_async_iterator_ts_1_1);
            },
            function (pool_ts_1_1) {
                exportStar_1(pool_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/textproto/mod", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/encoding/utf8"], function (exports_12, context_12) {
    "use strict";
    var mod_ts_2, utf8_ts_1, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_12 && context_12.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_1.decode(buf);
        }
    }
    function charCode(s) {
        return s.charCodeAt(0);
    }
    return {
        setters: [
            function (mod_ts_2_1) {
                mod_ts_2 = mod_ts_2_1;
            },
            function (utf8_ts_1_1) {
                utf8_ts_1 = utf8_ts_1_1;
            }
        ],
        execute: function () {
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice();
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        let i = kv.indexOf(charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        const key = str(kv.subarray(0, i));
                        if (key == "") {
                            continue;
                        }
                        i++;
                        while (i < kv.byteLength &&
                            (kv[i] == charCode(" ") || kv[i] == charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        try {
                            m.append(key, value);
                        }
                        catch {
                        }
                    }
                }
                async readLineSlice() {
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        if (!line && !more) {
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_2.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === charCode(" ") || l[i] === charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_12("TextProtoReader", TextProtoReader);
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/http_status", [], function (exports_13, context_13) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [],
        execute: function () {
            (function (Status) {
                Status[Status["Continue"] = 100] = "Continue";
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                Status[Status["Processing"] = 102] = "Processing";
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                Status[Status["OK"] = 200] = "OK";
                Status[Status["Created"] = 201] = "Created";
                Status[Status["Accepted"] = 202] = "Accepted";
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                Status[Status["NoContent"] = 204] = "NoContent";
                Status[Status["ResetContent"] = 205] = "ResetContent";
                Status[Status["PartialContent"] = 206] = "PartialContent";
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                Status[Status["IMUsed"] = 226] = "IMUsed";
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                Status[Status["Found"] = 302] = "Found";
                Status[Status["SeeOther"] = 303] = "SeeOther";
                Status[Status["NotModified"] = 304] = "NotModified";
                Status[Status["UseProxy"] = 305] = "UseProxy";
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                Status[Status["BadRequest"] = 400] = "BadRequest";
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                Status[Status["Forbidden"] = 403] = "Forbidden";
                Status[Status["NotFound"] = 404] = "NotFound";
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                Status[Status["Conflict"] = 409] = "Conflict";
                Status[Status["Gone"] = 410] = "Gone";
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                Status[Status["Teapot"] = 418] = "Teapot";
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                Status[Status["Locked"] = 423] = "Locked";
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                Status[Status["TooEarly"] = 425] = "TooEarly";
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                Status[Status["BadGateway"] = 502] = "BadGateway";
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                Status[Status["NotExtended"] = 510] = "NotExtended";
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_13("Status", Status);
            exports_13("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/_io", ["https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/textproto/mod", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/http/server", "https://deno.land/std@0.73.0/http/http_status"], function (exports_14, context_14) {
    "use strict";
    var bufio_ts_1, mod_ts_3, assert_ts_2, utf8_ts_2, server_ts_1, http_status_ts_1;
    var __moduleName = context_14 && context_14.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_14("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_14("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        const tp = new mod_ts_3.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_2.assert(chunkSize === 0);
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_14("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_3.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_14("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_1.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_2.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_2.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_2.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_14("writeChunkedBody", writeChunkedBody);
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_1.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_2.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_2.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_14("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_1.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_1.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_2.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_2.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_2.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_2.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_2.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_2.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_14("writeResponse", writeResponse);
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_14("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_3.TextProtoReader(bufr);
        const firstLine = await tp.readLine();
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_1.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_14("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_1_1) {
                bufio_ts_1 = bufio_ts_1_1;
            },
            function (mod_ts_3_1) {
                mod_ts_3 = mod_ts_3_1;
            },
            function (assert_ts_2_1) {
                assert_ts_2 = assert_ts_2_1;
            },
            function (utf8_ts_2_1) {
                utf8_ts_2 = utf8_ts_2_1;
            },
            function (server_ts_1_1) {
                server_ts_1 = server_ts_1_1;
            },
            function (http_status_ts_1_1) {
                http_status_ts_1 = http_status_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/server", ["https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/async/mod", "https://deno.land/std@0.73.0/http/_io"], function (exports_15, context_15) {
    "use strict";
    var utf8_ts_3, bufio_ts_2, assert_ts_3, mod_ts_4, _io_ts_1, ServerRequest, Server;
    var __moduleName = context_15 && context_15.id;
    function _parseAddrFromStr(addr) {
        let url;
        try {
            const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
            url = new URL(`http://${host}`);
        }
        catch {
            throw new TypeError("Invalid address.");
        }
        if (url.username ||
            url.password ||
            url.pathname != "/" ||
            url.search ||
            url.hash) {
            throw new TypeError("Invalid address.");
        }
        return {
            hostname: url.hostname,
            port: url.port === "" ? 80 : Number(url.port),
        };
    }
    exports_15("_parseAddrFromStr", _parseAddrFromStr);
    function serve(addr) {
        if (typeof addr === "string") {
            addr = _parseAddrFromStr(addr);
        }
        const listener = Deno.listen(addr);
        return new Server(listener);
    }
    exports_15("serve", serve);
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_15("listenAndServe", listenAndServe);
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = Deno.listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_15("serveTLS", serveTLS);
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_15("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_3_1) {
                utf8_ts_3 = utf8_ts_3_1;
            },
            function (bufio_ts_2_1) {
                bufio_ts_2 = bufio_ts_2_1;
            },
            function (assert_ts_3_1) {
                assert_ts_3 = assert_ts_3_1;
            },
            function (mod_ts_4_1) {
                mod_ts_4 = mod_ts_4_1;
            },
            function (_io_ts_1_1) {
                _io_ts_1 = _io_ts_1_1;
            }
        ],
        execute: function () {
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_4.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                get contentLength() {
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_1.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_3.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_1.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                this._body = _io_ts_1.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        await _io_ts_1.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            this.conn.close();
                        }
                        catch {
                        }
                        err = e;
                    }
                    this.done.resolve(err);
                    if (err) {
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                    }
                    this.finalized = true;
                }
            };
            exports_15("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_2.BufReader(conn);
                    const writer = new bufio_ts_2.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_1.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                await _io_ts_1.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_3.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        const responseError = await request.done;
                        if (responseError) {
                            this.untrackConnection(request.conn);
                            return;
                        }
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_4.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_15("Server", Server);
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_constants", [], function (exports_16, context_16) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, NATIVE_OS, navigator, isWindows;
    var __moduleName = context_16 && context_16.id;
    return {
        setters: [],
        execute: function () {
            exports_16("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65);
            exports_16("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97);
            exports_16("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90);
            exports_16("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122);
            exports_16("CHAR_DOT", CHAR_DOT = 46);
            exports_16("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47);
            exports_16("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92);
            exports_16("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124);
            exports_16("CHAR_COLON", CHAR_COLON = 58);
            exports_16("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63);
            exports_16("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95);
            exports_16("CHAR_LINE_FEED", CHAR_LINE_FEED = 10);
            exports_16("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13);
            exports_16("CHAR_TAB", CHAR_TAB = 9);
            exports_16("CHAR_FORM_FEED", CHAR_FORM_FEED = 12);
            exports_16("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33);
            exports_16("CHAR_HASH", CHAR_HASH = 35);
            exports_16("CHAR_SPACE", CHAR_SPACE = 32);
            exports_16("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160);
            exports_16("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279);
            exports_16("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91);
            exports_16("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93);
            exports_16("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60);
            exports_16("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62);
            exports_16("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123);
            exports_16("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125);
            exports_16("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45);
            exports_16("CHAR_PLUS", CHAR_PLUS = 43);
            exports_16("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34);
            exports_16("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39);
            exports_16("CHAR_PERCENT", CHAR_PERCENT = 37);
            exports_16("CHAR_SEMICOLON", CHAR_SEMICOLON = 59);
            exports_16("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94);
            exports_16("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96);
            exports_16("CHAR_AT", CHAR_AT = 64);
            exports_16("CHAR_AMPERSAND", CHAR_AMPERSAND = 38);
            exports_16("CHAR_EQUAL", CHAR_EQUAL = 61);
            exports_16("CHAR_0", CHAR_0 = 48);
            exports_16("CHAR_9", CHAR_9 = 57);
            NATIVE_OS = "linux";
            exports_16("NATIVE_OS", NATIVE_OS);
            navigator = globalThis.navigator;
            if (globalThis.Deno != null) {
                exports_16("NATIVE_OS", NATIVE_OS = Deno.build.os);
            }
            else if (navigator?.appVersion?.includes?.("Win") ?? false) {
                exports_16("NATIVE_OS", NATIVE_OS = "windows");
            }
            exports_16("isWindows", isWindows = NATIVE_OS == "windows");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_interface", [], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_util", ["https://deno.land/std@0.73.0/path/_constants"], function (exports_18, context_18) {
    "use strict";
    var _constants_ts_1;
    var __moduleName = context_18 && context_18.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_18("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_1.CHAR_FORWARD_SLASH;
    }
    exports_18("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_1.CHAR_BACKWARD_SLASH;
    }
    exports_18("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_1.CHAR_LOWERCASE_A && code <= _constants_ts_1.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_1.CHAR_UPPERCASE_A && code <= _constants_ts_1.CHAR_UPPERCASE_Z));
    }
    exports_18("isWindowsDeviceRoot", isWindowsDeviceRoot);
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_1.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_1.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_1.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_1.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_18("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base ||
            (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_18("_format", _format);
    return {
        setters: [
            function (_constants_ts_1_1) {
                _constants_ts_1 = _constants_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/win32", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/_util", "https://deno.land/std@0.73.0/_util/assert"], function (exports_19, context_19) {
    "use strict";
    var _constants_ts_2, _util_ts_1, assert_ts_4, sep, delimiter;
    var __moduleName = context_19 && context_19.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_1.assertPath(path);
            const len = path.length;
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len > 1) {
                if (_util_ts_1.isPathSeparator(code)) {
                    isAbsolute = true;
                    if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                        let j = 2;
                        let last = j;
                        for (; j < len; ++j) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            last = j;
                            for (; j < len; ++j) {
                                if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                last = j;
                                for (; j < len; ++j) {
                                    if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                    if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        resolvedTail = _util_ts_1.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_1.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_19("resolve", resolve);
    function normalize(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                isAbsolute = true;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_1.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_1.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_1.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_19("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_1.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_1.isWindowsDeviceRoot(code)) {
            if (len > 2 && path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_19("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_1.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_4.assert(firstPart != null);
        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_1.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_19("join", join);
    function relative(from, to) {
        _util_ts_1.assertPath(from);
        _util_ts_1.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_2.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_2.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_19("relative", relative);
    function toNamespacedPath(path) {
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_2.CHAR_QUESTION_MARK && code !== _constants_ts_2.CHAR_DOT) {
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_19("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = offset = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return path;
                            }
                            if (j !== last) {
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_19("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_1.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_1.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_1.isPathSeparator(code)) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_19("basename", basename);
    function extname(path) {
        _util_ts_1.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
            _util_ts_1.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_19("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_1._format("\\", pathObject);
    }
    exports_19("format", format);
    function parse(path) {
        _util_ts_1.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_19("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        let path = decodeURIComponent(url.pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\")
            .replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
        if (url.hostname != "") {
            path = `\\\\${url.hostname}${path}`;
        }
        return path;
    }
    exports_19("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_2_1) {
                _constants_ts_2 = _constants_ts_2_1;
            },
            function (_util_ts_1_1) {
                _util_ts_1 = _util_ts_1_1;
            },
            function (assert_ts_4_1) {
                assert_ts_4 = assert_ts_4_1;
            }
        ],
        execute: function () {
            exports_19("sep", sep = "\\");
            exports_19("delimiter", delimiter = ";");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/posix", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/_util"], function (exports_20, context_20) {
    "use strict";
    var _constants_ts_3, _util_ts_2, sep, delimiter;
    var __moduleName = context_20 && context_20.id;
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_2.assertPath(path);
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        }
        resolvedPath = _util_ts_2.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_20("resolve", resolve);
    function normalize(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_3.CHAR_FORWARD_SLASH;
        path = _util_ts_2.normalizeString(path, !isAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_20("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_2.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
    }
    exports_20("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_2.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_20("join", join);
    function relative(from, to) {
        _util_ts_2.assertPath(from);
        _util_ts_2.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_3.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_3.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_20("relative", relative);
    function toNamespacedPath(path) {
        return path;
    }
    exports_20("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_20("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_2.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_20("basename", basename);
    function extname(path) {
        _util_ts_2.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_20("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_2._format("/", pathObject);
    }
    exports_20("format", format);
    function parse(path) {
        _util_ts_2.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_20("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    }
    exports_20("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_3_1) {
                _constants_ts_3 = _constants_ts_3_1;
            },
            function (_util_ts_2_1) {
                _util_ts_2 = _util_ts_2_1;
            }
        ],
        execute: function () {
            exports_20("sep", sep = "/");
            exports_20("delimiter", delimiter = ":");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/separator", ["https://deno.land/std@0.73.0/path/_constants"], function (exports_21, context_21) {
    "use strict";
    var _constants_ts_4, SEP, SEP_PATTERN;
    var __moduleName = context_21 && context_21.id;
    return {
        setters: [
            function (_constants_ts_4_1) {
                _constants_ts_4 = _constants_ts_4_1;
            }
        ],
        execute: function () {
            exports_21("SEP", SEP = _constants_ts_4.isWindows ? "\\" : "/");
            exports_21("SEP_PATTERN", SEP_PATTERN = _constants_ts_4.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/common", ["https://deno.land/std@0.73.0/path/separator"], function (exports_22, context_22) {
    "use strict";
    var separator_ts_1;
    var __moduleName = context_22 && context_22.id;
    function common(paths, sep = separator_ts_1.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_22("common", common);
    return {
        setters: [
            function (separator_ts_1_1) {
                separator_ts_1 = separator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/glob", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/mod", "https://deno.land/std@0.73.0/path/separator"], function (exports_23, context_23) {
    "use strict";
    var _constants_ts_5, mod_ts_5, separator_ts_2, regExpEscapeChars, rangeEscapeChars;
    var __moduleName = context_23 && context_23.id;
    function globToRegExp(glob, { extended = true, globstar: globstarOption = true, os = _constants_ts_5.NATIVE_OS } = {}) {
        if (glob == "") {
            return /(?!)/;
        }
        const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
        const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
        const seps = os == "windows" ? ["\\", "/"] : ["/"];
        const globstar = os == "windows"
            ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*"
            : "(?:[^/]*(?:/|$)+)*";
        const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
        const escapePrefix = os == "windows" ? "`" : "\\";
        let newLength = glob.length;
        for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--)
            ;
        glob = glob.slice(0, newLength);
        let regExpString = "";
        for (let j = 0; j < glob.length;) {
            let segment = "";
            const groupStack = [];
            let inRange = false;
            let inEscape = false;
            let endsWithSep = false;
            let i = j;
            for (; i < glob.length && !seps.includes(glob[i]); i++) {
                if (inEscape) {
                    inEscape = false;
                    const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                    segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                    continue;
                }
                if (glob[i] == escapePrefix) {
                    inEscape = true;
                    continue;
                }
                if (glob[i] == "[") {
                    if (!inRange) {
                        inRange = true;
                        segment += "[";
                        if (glob[i + 1] == "!") {
                            i++;
                            segment += "^";
                        }
                        else if (glob[i + 1] == "^") {
                            i++;
                            segment += "\\^";
                        }
                        continue;
                    }
                    else if (glob[i + 1] == ":") {
                        let k = i + 1;
                        let value = "";
                        while (glob[k + 1] != null && glob[k + 1] != ":") {
                            value += glob[k + 1];
                            k++;
                        }
                        if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                            i = k + 2;
                            if (value == "alnum")
                                segment += "\\dA-Za-z";
                            else if (value == "alpha")
                                segment += "A-Za-z";
                            else if (value == "ascii")
                                segment += "\x00-\x7F";
                            else if (value == "blank")
                                segment += "\t ";
                            else if (value == "cntrl")
                                segment += "\x00-\x1F\x7F";
                            else if (value == "digit")
                                segment += "\\d";
                            else if (value == "graph")
                                segment += "\x21-\x7E";
                            else if (value == "lower")
                                segment += "a-z";
                            else if (value == "print")
                                segment += "\x20-\x7E";
                            else if (value == "punct") {
                                segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~";
                            }
                            else if (value == "space")
                                segment += "\\s\v";
                            else if (value == "upper")
                                segment += "A-Z";
                            else if (value == "word")
                                segment += "\\w";
                            else if (value == "xdigit")
                                segment += "\\dA-Fa-f";
                            continue;
                        }
                    }
                }
                if (glob[i] == "]" && inRange) {
                    inRange = false;
                    segment += "]";
                    continue;
                }
                if (inRange) {
                    if (glob[i] == "\\") {
                        segment += `\\\\`;
                    }
                    else {
                        segment += glob[i];
                    }
                    continue;
                }
                if (glob[i] == ")" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += ")";
                    const type = groupStack.pop();
                    if (type == "!") {
                        segment += wildcard;
                    }
                    else if (type != "@") {
                        segment += type;
                    }
                    continue;
                }
                if (glob[i] == "|" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("+");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("@");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "?") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("?");
                        segment += "(?:";
                    }
                    else {
                        segment += ".";
                    }
                    continue;
                }
                if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("!");
                    segment += "(?!";
                    continue;
                }
                if (glob[i] == "{") {
                    groupStack.push("BRACE");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                    groupStack.pop();
                    segment += ")";
                    continue;
                }
                if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "*") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("*");
                        segment += "(?:";
                    }
                    else {
                        const prevChar = glob[i - 1];
                        let numStars = 1;
                        while (glob[i + 1] == "*") {
                            i++;
                            numStars++;
                        }
                        const nextChar = glob[i + 1];
                        if (globstarOption && numStars == 2 &&
                            [...seps, undefined].includes(prevChar) &&
                            [...seps, undefined].includes(nextChar)) {
                            segment += globstar;
                            endsWithSep = true;
                        }
                        else {
                            segment += wildcard;
                        }
                    }
                    continue;
                }
                segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
            }
            if (groupStack.length > 0 || inRange || inEscape) {
                segment = "";
                for (const c of glob.slice(j, i)) {
                    segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                    endsWithSep = false;
                }
            }
            regExpString += segment;
            if (!endsWithSep) {
                regExpString += i < glob.length ? sep : sepMaybe;
                endsWithSep = true;
            }
            while (seps.includes(glob[i]))
                i++;
            if (!(i > j)) {
                throw new Error("Assertion failure: i > j (potential infinite loop)");
            }
            j = i;
        }
        regExpString = `^${regExpString}$`;
        return new RegExp(regExpString);
    }
    exports_23("globToRegExp", globToRegExp);
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_23("isGlob", isGlob);
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_5.normalize(glob);
        }
        const s = separator_ts_2.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_5.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_23("normalizeGlob", normalizeGlob);
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_5.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_2.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_23("joinGlobs", joinGlobs);
    return {
        setters: [
            function (_constants_ts_5_1) {
                _constants_ts_5 = _constants_ts_5_1;
            },
            function (mod_ts_5_1) {
                mod_ts_5 = mod_ts_5_1;
            },
            function (separator_ts_2_1) {
                separator_ts_2 = separator_ts_2_1;
            }
        ],
        execute: function () {
            regExpEscapeChars = ["!", "$", "(", ")", "*", "+", ".", "=", "?", "[", "\\", "^", "{", "|"];
            rangeEscapeChars = ["-", "\\", "]"];
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/mod", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/win32", "https://deno.land/std@0.73.0/path/posix", "https://deno.land/std@0.73.0/path/common", "https://deno.land/std@0.73.0/path/separator", "https://deno.land/std@0.73.0/path/_interface", "https://deno.land/std@0.73.0/path/glob"], function (exports_24, context_24) {
    "use strict";
    var _constants_ts_6, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_24 && context_24.id;
    var exportedNames_1 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_24(exports);
    }
    return {
        setters: [
            function (_constants_ts_6_1) {
                _constants_ts_6 = _constants_ts_6_1;
            },
            function (_win32_1) {
                _win32 = _win32_1;
            },
            function (_posix_1) {
                _posix = _posix_1;
            },
            function (common_ts_1_1) {
                exportStar_2(common_ts_1_1);
            },
            function (separator_ts_3_1) {
                exports_24({
                    "SEP": separator_ts_3_1["SEP"],
                    "SEP_PATTERN": separator_ts_3_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_1_1) {
                exportStar_2(_interface_ts_1_1);
            },
            function (glob_ts_1_1) {
                exportStar_2(glob_ts_1_1);
            }
        ],
        execute: function () {
            path = _constants_ts_6.isWindows ? _win32 : _posix;
            exports_24("win32", win32 = _win32);
            exports_24("posix", posix = _posix);
            exports_24("basename", basename = path.basename), exports_24("delimiter", delimiter = path.delimiter), exports_24("dirname", dirname = path.dirname), exports_24("extname", extname = path.extname), exports_24("format", format = path.format), exports_24("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_24("isAbsolute", isAbsolute = path.isAbsolute), exports_24("join", join = path.join), exports_24("normalize", normalize = path.normalize), exports_24("parse", parse = path.parse), exports_24("relative", relative = path.relative), exports_24("resolve", resolve = path.resolve), exports_24("sep", sep = path.sep), exports_24("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.73.0/fmt/colors", [], function (exports_25, context_25) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_25 && context_25.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_25("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_25("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_25("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_25("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_25("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_25("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_25("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_25("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_25("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_25("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_25("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_25("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_25("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_25("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_25("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_25("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_25("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_25("white", white);
    function gray(str) {
        return brightBlack(str);
    }
    exports_25("gray", gray);
    function brightBlack(str) {
        return run(str, code([90], 39));
    }
    exports_25("brightBlack", brightBlack);
    function brightRed(str) {
        return run(str, code([91], 39));
    }
    exports_25("brightRed", brightRed);
    function brightGreen(str) {
        return run(str, code([92], 39));
    }
    exports_25("brightGreen", brightGreen);
    function brightYellow(str) {
        return run(str, code([93], 39));
    }
    exports_25("brightYellow", brightYellow);
    function brightBlue(str) {
        return run(str, code([94], 39));
    }
    exports_25("brightBlue", brightBlue);
    function brightMagenta(str) {
        return run(str, code([95], 39));
    }
    exports_25("brightMagenta", brightMagenta);
    function brightCyan(str) {
        return run(str, code([96], 39));
    }
    exports_25("brightCyan", brightCyan);
    function brightWhite(str) {
        return run(str, code([97], 39));
    }
    exports_25("brightWhite", brightWhite);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_25("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_25("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_25("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_25("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_25("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_25("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_25("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_25("bgWhite", bgWhite);
    function bgBrightBlack(str) {
        return run(str, code([100], 49));
    }
    exports_25("bgBrightBlack", bgBrightBlack);
    function bgBrightRed(str) {
        return run(str, code([101], 49));
    }
    exports_25("bgBrightRed", bgBrightRed);
    function bgBrightGreen(str) {
        return run(str, code([102], 49));
    }
    exports_25("bgBrightGreen", bgBrightGreen);
    function bgBrightYellow(str) {
        return run(str, code([103], 49));
    }
    exports_25("bgBrightYellow", bgBrightYellow);
    function bgBrightBlue(str) {
        return run(str, code([104], 49));
    }
    exports_25("bgBrightBlue", bgBrightBlue);
    function bgBrightMagenta(str) {
        return run(str, code([105], 49));
    }
    exports_25("bgBrightMagenta", bgBrightMagenta);
    function bgBrightCyan(str) {
        return run(str, code([106], 49));
    }
    exports_25("bgBrightCyan", bgBrightCyan);
    function bgBrightWhite(str) {
        return run(str, code([107], 49));
    }
    exports_25("bgBrightWhite", bgBrightWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_25("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_25("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_25("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_25("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_25("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/std@0.73.0/testing/_diff", [], function (exports_26, context_26) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_26 && context_26.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_26("diff", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_26("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
System.register("https://deno.land/std@0.73.0/testing/asserts", ["https://deno.land/std@0.73.0/fmt/colors", "https://deno.land/std@0.73.0/testing/_diff"], function (exports_27, context_27) {
    "use strict";
    var colors_ts_1, _diff_ts_1, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_27 && context_27.id;
    function _format(v) {
        return globalThis.Deno
            ? Deno.inspect(v, {
                depth: Infinity,
                sorted: true,
                trailingComma: true,
                compact: false,
                iterableLimit: Infinity,
            })
            : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
    }
    exports_27("_format", _format);
    function createColor(diffType) {
        switch (diffType) {
            case _diff_ts_1.DiffType.added:
                return (s) => colors_ts_1.green(colors_ts_1.bold(s));
            case _diff_ts_1.DiffType.removed:
                return (s) => colors_ts_1.red(colors_ts_1.bold(s));
            default:
                return colors_ts_1.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case _diff_ts_1.DiffType.added:
                return "+   ";
            case _diff_ts_1.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_1.gray(colors_ts_1.bold("[Diff]"))} ${colors_ts_1.red(colors_ts_1.bold("Actual"))} / ${colors_ts_1.green(colors_ts_1.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof URL && b instanceof URL))) {
                return String(a) === String(b);
            }
            if (a instanceof Date && b instanceof Date) {
                const aTime = a.getTime();
                const bTime = b.getTime();
                if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                    return true;
                }
                return a.getTime() === b.getTime();
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_27("equal", equal);
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_27("assert", assert);
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = _format(actual);
        const expectedString = _format(expected);
        try {
            const diffResult = _diff_ts_1.diff(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult).join("\n");
            message = `Values are not equal:\n${diffMsg}`;
        }
        catch (e) {
            message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_27("assertEquals", assertEquals);
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_27("assertNotEquals", assertNotEquals);
    function assertStrictEquals(actual, expected, msg) {
        if (actual === expected) {
            return;
        }
        let message;
        if (msg) {
            message = msg;
        }
        else {
            const actualString = _format(actual);
            const expectedString = _format(expected);
            if (actualString === expectedString) {
                const withOffset = actualString
                    .split("\n")
                    .map((l) => `    ${l}`)
                    .join("\n");
                message =
                    `Values have the same structure but are not reference-equal:\n\n${colors_ts_1.red(withOffset)}\n`;
            }
            else {
                try {
                    const diffResult = _diff_ts_1.diff(actualString.split("\n"), expectedString.split("\n"));
                    const diffMsg = buildMessage(diffResult).join("\n");
                    message = `Values are not strictly equal:\n${diffMsg}`;
                }
                catch (e) {
                    message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
                }
            }
        }
        throw new AssertionError(message);
    }
    exports_27("assertStrictEquals", assertStrictEquals);
    function assertNotStrictEquals(actual, expected, msg) {
        if (actual !== expected) {
            return;
        }
        throw new AssertionError(msg ?? `Expected "actual" to be strictly unequal to: ${_format(actual)}\n`);
    }
    exports_27("assertNotStrictEquals", assertNotStrictEquals);
    function assertStringContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contain: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertStringContains", assertStringContains);
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${_format(actual)}" expected to contain: "${_format(expected)}"\nmissing: ${_format(missing)}`;
        }
        throw new AssertionError(msg);
    }
    exports_27("assertArrayContains", assertArrayContains);
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertMatch", assertMatch);
    function assertNotMatch(actual, expected, msg) {
        if (expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to not match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertNotMatch", assertNotMatch);
    function fail(msg) {
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_27("fail", fail);
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_27("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown or rejected.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_27("assertThrowsAsync", assertThrowsAsync);
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_27("unimplemented", unimplemented);
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_27("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_1_1) {
                colors_ts_1 = colors_ts_1_1;
            },
            function (_diff_ts_1_1) {
                _diff_ts_1 = _diff_ts_1_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_27("AssertionError", AssertionError);
        }
    };
});
System.register("https://deno.land/std@0.73.0/_util/has_own_property", [], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_28("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/io/ioutil", ["https://deno.land/std@0.73.0/_util/assert"], function (exports_29, context_29) {
    "use strict";
    var assert_ts_5, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_29 && context_29.id;
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_5.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_29("copyN", copyN);
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_29("readShort", readShort);
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_29("readInt", readInt);
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_29("readLong", readLong);
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_29("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_5_1) {
                assert_ts_5 = assert_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
System.register("https://deno.land/std@0.73.0/ws/mod", ["https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/_util/has_own_property", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/io/ioutil", "https://deno.land/std@0.73.0/hash/sha1", "https://deno.land/std@0.73.0/http/_io", "https://deno.land/std@0.73.0/textproto/mod", "https://deno.land/std@0.73.0/async/deferred", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/bytes/mod"], function (exports_30, context_30) {
    "use strict";
    var utf8_ts_4, has_own_property_ts_1, bufio_ts_3, ioutil_ts_1, sha1_ts_1, _io_ts_2, mod_ts_6, deferred_ts_3, assert_ts_6, mod_ts_7, OpCode, WebSocketImpl, kGUID, kSecChars;
    var __moduleName = context_30 && context_30.id;
    function isWebSocketCloseEvent(a) {
        return has_own_property_ts_1.hasOwnProperty(a, "code");
    }
    exports_30("isWebSocketCloseEvent", isWebSocketCloseEvent);
    function isWebSocketPingEvent(a) {
        return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
    }
    exports_30("isWebSocketPingEvent", isWebSocketPingEvent);
    function isWebSocketPongEvent(a) {
        return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
    }
    exports_30("isWebSocketPongEvent", isWebSocketPongEvent);
    function unmask(payload, mask) {
        if (mask) {
            for (let i = 0, len = payload.length; i < len; i++) {
                payload[i] ^= mask[i & 3];
            }
        }
    }
    exports_30("unmask", unmask);
    async function writeFrame(frame, writer) {
        const payloadLength = frame.payload.byteLength;
        let header;
        const hasMask = frame.mask ? 0x80 : 0;
        if (frame.mask && frame.mask.byteLength !== 4) {
            throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
        }
        if (payloadLength < 126) {
            header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
        }
        else if (payloadLength < 0xffff) {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111110,
                payloadLength >>> 8,
                payloadLength & 0x00ff,
            ]);
        }
        else {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111111,
                ...ioutil_ts_1.sliceLongToBytes(payloadLength),
            ]);
        }
        if (frame.mask) {
            header = mod_ts_7.concat(header, frame.mask);
        }
        unmask(frame.payload, frame.mask);
        header = mod_ts_7.concat(header, frame.payload);
        const w = bufio_ts_3.BufWriter.create(writer);
        await w.write(header);
        await w.flush();
    }
    exports_30("writeFrame", writeFrame);
    async function readFrame(buf) {
        let b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        let isLastFrame = false;
        switch (b >>> 4) {
            case 0b1000:
                isLastFrame = true;
                break;
            case 0b0000:
                isLastFrame = false;
                break;
            default:
                throw new Error("invalid signature");
        }
        const opcode = b & 0x0f;
        b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        const hasMask = b >>> 7;
        let payloadLength = b & 0b01111111;
        if (payloadLength === 126) {
            const l = await ioutil_ts_1.readShort(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = l;
        }
        else if (payloadLength === 127) {
            const l = await ioutil_ts_1.readLong(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = Number(l);
        }
        let mask;
        if (hasMask) {
            mask = new Uint8Array(4);
            assert_ts_6.assert((await buf.readFull(mask)) !== null);
        }
        const payload = new Uint8Array(payloadLength);
        assert_ts_6.assert((await buf.readFull(payload)) !== null);
        return {
            isLastFrame,
            opcode,
            mask,
            payload,
        };
    }
    exports_30("readFrame", readFrame);
    function acceptable(req) {
        const upgrade = req.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = req.headers.get("sec-websocket-key");
        return (req.headers.has("sec-websocket-key") &&
            typeof secKey === "string" &&
            secKey.length > 0);
    }
    exports_30("acceptable", acceptable);
    function createSecAccept(nonce) {
        const sha1 = new sha1_ts_1.Sha1();
        sha1.update(nonce + kGUID);
        const bytes = sha1.digest();
        return btoa(String.fromCharCode(...bytes));
    }
    exports_30("createSecAccept", createSecAccept);
    async function acceptWebSocket(req) {
        const { conn, headers, bufReader, bufWriter } = req;
        if (acceptable(req)) {
            const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
            const secKey = headers.get("sec-websocket-key");
            if (typeof secKey !== "string") {
                throw new Error("sec-websocket-key is not provided");
            }
            const secAccept = createSecAccept(secKey);
            await _io_ts_2.writeResponse(bufWriter, {
                status: 101,
                headers: new Headers({
                    Upgrade: "websocket",
                    Connection: "Upgrade",
                    "Sec-WebSocket-Accept": secAccept,
                }),
            });
            return sock;
        }
        throw new Error("request is not acceptable");
    }
    exports_30("acceptWebSocket", acceptWebSocket);
    function createSecKey() {
        let key = "";
        for (let i = 0; i < 16; i++) {
            const j = Math.floor(Math.random() * kSecChars.length);
            key += kSecChars[j];
        }
        return btoa(key);
    }
    exports_30("createSecKey", createSecKey);
    async function handshake(url, headers, bufReader, bufWriter) {
        const { hostname, pathname, search } = url;
        const key = createSecKey();
        if (!headers.has("host")) {
            headers.set("host", hostname);
        }
        headers.set("upgrade", "websocket");
        headers.set("connection", "upgrade");
        headers.set("sec-websocket-key", key);
        headers.set("sec-websocket-version", "13");
        let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
        for (const [key, value] of headers) {
            headerStr += `${key}: ${value}\r\n`;
        }
        headerStr += "\r\n";
        await bufWriter.write(utf8_ts_4.encode(headerStr));
        await bufWriter.flush();
        const tpReader = new mod_ts_6.TextProtoReader(bufReader);
        const statusLine = await tpReader.readLine();
        if (statusLine === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
        if (!m) {
            throw new Error("ws: invalid status line: " + statusLine);
        }
        assert_ts_6.assert(m.groups);
        const { version, statusCode } = m.groups;
        if (version !== "HTTP/1.1" || statusCode !== "101") {
            throw new Error(`ws: server didn't accept handshake: ` +
                `version=${version}, statusCode=${statusCode}`);
        }
        const responseHeaders = await tpReader.readMIMEHeader();
        if (responseHeaders === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const expectedSecAccept = createSecAccept(key);
        const secAccept = responseHeaders.get("sec-websocket-accept");
        if (secAccept !== expectedSecAccept) {
            throw new Error(`ws: unexpected sec-websocket-accept header: ` +
                `expected=${expectedSecAccept}, actual=${secAccept}`);
        }
    }
    exports_30("handshake", handshake);
    function createWebSocket(params) {
        return new WebSocketImpl(params);
    }
    exports_30("createWebSocket", createWebSocket);
    return {
        setters: [
            function (utf8_ts_4_1) {
                utf8_ts_4 = utf8_ts_4_1;
            },
            function (has_own_property_ts_1_1) {
                has_own_property_ts_1 = has_own_property_ts_1_1;
            },
            function (bufio_ts_3_1) {
                bufio_ts_3 = bufio_ts_3_1;
            },
            function (ioutil_ts_1_1) {
                ioutil_ts_1 = ioutil_ts_1_1;
            },
            function (sha1_ts_1_1) {
                sha1_ts_1 = sha1_ts_1_1;
            },
            function (_io_ts_2_1) {
                _io_ts_2 = _io_ts_2_1;
            },
            function (mod_ts_6_1) {
                mod_ts_6 = mod_ts_6_1;
            },
            function (deferred_ts_3_1) {
                deferred_ts_3 = deferred_ts_3_1;
            },
            function (assert_ts_6_1) {
                assert_ts_6 = assert_ts_6_1;
            },
            function (mod_ts_7_1) {
                mod_ts_7 = mod_ts_7_1;
            }
        ],
        execute: function () {
            (function (OpCode) {
                OpCode[OpCode["Continue"] = 0] = "Continue";
                OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
                OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
                OpCode[OpCode["Close"] = 8] = "Close";
                OpCode[OpCode["Ping"] = 9] = "Ping";
                OpCode[OpCode["Pong"] = 10] = "Pong";
            })(OpCode || (OpCode = {}));
            exports_30("OpCode", OpCode);
            WebSocketImpl = class WebSocketImpl {
                constructor({ conn, bufReader, bufWriter, mask, }) {
                    this.sendQueue = [];
                    this._isClosed = false;
                    this.conn = conn;
                    this.mask = mask;
                    this.bufReader = bufReader || new bufio_ts_3.BufReader(conn);
                    this.bufWriter = bufWriter || new bufio_ts_3.BufWriter(conn);
                }
                async *[Symbol.asyncIterator]() {
                    let frames = [];
                    let payloadsLength = 0;
                    while (!this._isClosed) {
                        let frame;
                        try {
                            frame = await readFrame(this.bufReader);
                        }
                        catch (e) {
                            this.ensureSocketClosed();
                            break;
                        }
                        unmask(frame.payload, frame.mask);
                        switch (frame.opcode) {
                            case OpCode.TextFrame:
                            case OpCode.BinaryFrame:
                            case OpCode.Continue:
                                frames.push(frame);
                                payloadsLength += frame.payload.length;
                                if (frame.isLastFrame) {
                                    const concat = new Uint8Array(payloadsLength);
                                    let offs = 0;
                                    for (const frame of frames) {
                                        concat.set(frame.payload, offs);
                                        offs += frame.payload.length;
                                    }
                                    if (frames[0].opcode === OpCode.TextFrame) {
                                        yield utf8_ts_4.decode(concat);
                                    }
                                    else {
                                        yield concat;
                                    }
                                    frames = [];
                                    payloadsLength = 0;
                                }
                                break;
                            case OpCode.Close: {
                                const code = (frame.payload[0] << 8) | frame.payload[1];
                                const reason = utf8_ts_4.decode(frame.payload.subarray(2, frame.payload.length));
                                await this.close(code, reason);
                                yield { code, reason };
                                return;
                            }
                            case OpCode.Ping:
                                await this.enqueue({
                                    opcode: OpCode.Pong,
                                    payload: frame.payload,
                                    isLastFrame: true,
                                });
                                yield ["ping", frame.payload];
                                break;
                            case OpCode.Pong:
                                yield ["pong", frame.payload];
                                break;
                            default:
                        }
                    }
                }
                dequeue() {
                    const [entry] = this.sendQueue;
                    if (!entry)
                        return;
                    if (this._isClosed)
                        return;
                    const { d, frame } = entry;
                    writeFrame(frame, this.bufWriter)
                        .then(() => d.resolve())
                        .catch((e) => d.reject(e))
                        .finally(() => {
                        this.sendQueue.shift();
                        this.dequeue();
                    });
                }
                enqueue(frame) {
                    if (this._isClosed) {
                        throw new Deno.errors.ConnectionReset("Socket has already been closed");
                    }
                    const d = deferred_ts_3.deferred();
                    this.sendQueue.push({ d, frame });
                    if (this.sendQueue.length === 1) {
                        this.dequeue();
                    }
                    return d;
                }
                send(data) {
                    const opcode = typeof data === "string"
                        ? OpCode.TextFrame
                        : OpCode.BinaryFrame;
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const isLastFrame = true;
                    const frame = {
                        isLastFrame,
                        opcode,
                        payload,
                        mask: this.mask,
                    };
                    return this.enqueue(frame);
                }
                ping(data = "") {
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const frame = {
                        isLastFrame: true,
                        opcode: OpCode.Ping,
                        mask: this.mask,
                        payload,
                    };
                    return this.enqueue(frame);
                }
                get isClosed() {
                    return this._isClosed;
                }
                async close(code = 1000, reason) {
                    try {
                        const header = [code >>> 8, code & 0x00ff];
                        let payload;
                        if (reason) {
                            const reasonBytes = utf8_ts_4.encode(reason);
                            payload = new Uint8Array(2 + reasonBytes.byteLength);
                            payload.set(header);
                            payload.set(reasonBytes, 2);
                        }
                        else {
                            payload = new Uint8Array(header);
                        }
                        await this.enqueue({
                            isLastFrame: true,
                            opcode: OpCode.Close,
                            mask: this.mask,
                            payload,
                        });
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.ensureSocketClosed();
                    }
                }
                closeForce() {
                    this.ensureSocketClosed();
                }
                ensureSocketClosed() {
                    if (this.isClosed)
                        return;
                    try {
                        this.conn.close();
                    }
                    catch (e) {
                        console.error(e);
                    }
                    finally {
                        this._isClosed = true;
                        const rest = this.sendQueue;
                        this.sendQueue = [];
                        rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
                    }
                }
            };
            kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-db and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2020 the Deno authors
 * Copyright (c) 2020 the oak authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.5.1/db", [], function (exports_31, context_31) {
    "use strict";
    var db;
    var __moduleName = context_31 && context_31.id;
    return {
        setters: [],
        execute: function () {
            exports_31("db", db = JSON.parse(`{
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamcontrol+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomdeleted"]
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    "source": "iana"
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["held"]
  },
  "application/atsc-rdt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsat"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xcs"]
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/captive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cbor-seq": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdfx"]
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/clue+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dots+cbor": {
    "source": "iana"
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ecma","es"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/emergencycalldata.cap+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emotionml"]
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fdt"]
  },
  "application/fhir+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/flexfec": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink","inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["its"]
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar","war","ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js","mjs"]
  },
  "application/jf2feed+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json","map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/kpml-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/lgr+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lgr"]
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/load-control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lost+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lpf+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma","nb","mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mathml-presentation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-deregister+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-envelope+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-protection-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-reception-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-schedule+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/media_control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mipc": {
    "source": "iana"
  },
  "application/mmt-aei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["maei"]
  },
  "application/mmt-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musd"]
  },
  "application/mods+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21","mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4s","m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/mrb-publish+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/msc-ivr+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msc-mixer+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc","dot"]
  },
  "application/mud+json": {
    "source": "iana",
    "compressible": true
  },
  "application/multipart-core": {
    "source": "iana"
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/n-quads": {
    "source": "iana",
    "extensions": ["nq"]
  },
  "application/n-triples": {
    "source": "iana",
    "extensions": ["nt"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-groupinfo": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/node": {
    "source": "iana",
    "extensions": ["cjs"]
  },
  "application/nss": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]
  },
  "application/opc-nodeset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/oscore": {
    "source": "iana"
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p2p-overlay+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["relo"]
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/passport": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pem-certificate-chain": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana"
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["asc","sig"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pidf-diff+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m","p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkcs8-encrypted": {
    "source": "iana"
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai","eps","ps"]
  },
  "application/ppsp-tracker+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/provenance+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["provx"]
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.hpub+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pskc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pskcxml"]
  },
  "application/pvd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raml+yaml": {
    "compressible": true,
    "extensions": ["raml"]
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf","owl"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "iana"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rls-services+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rs"]
  },
  "application/route-apd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rapd"]
  },
  "application/route-s-tsid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sls"]
  },
  "application/route-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rusd"]
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-publication": {
    "source": "iana"
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/samlmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sbe": {
    "source": "iana"
  },
  "application/sbml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/secevent+jwt": {
    "source": "iana"
  },
  "application/senml+cbor": {
    "source": "iana"
  },
  "application/senml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["senmlx"]
  },
  "application/senml-etch+cbor": {
    "source": "iana"
  },
  "application/senml-etch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml-exi": {
    "source": "iana"
  },
  "application/sensml+cbor": {
    "source": "iana"
  },
  "application/sensml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sensmlx"]
  },
  "application/sensml-exi": {
    "source": "iana"
  },
  "application/sep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana",
    "extensions": ["siv","sieve"]
  },
  "application/simple-filter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/sipc": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "iana"
  },
  "application/smil+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["smi","smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["srx"]
  },
  "application/spirits-event+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sql": {
    "source": "iana"
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ssml"]
  },
  "application/stix+json": {
    "source": "iana",
    "compressible": true
  },
  "application/swid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["swidtag"]
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/taxii+json": {
    "source": "iana",
    "compressible": true
  },
  "application/td+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tei","teicorpus"]
  },
  "application/tetra_isi": {
    "source": "iana"
  },
  "application/thraud+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/tlsrpt+gzip": {
    "source": "iana"
  },
  "application/tlsrpt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tnauthlist": {
    "source": "iana"
  },
  "application/toml": {
    "compressible": true,
    "extensions": ["toml"]
  },
  "application/trickle-ice-sdpfrag": {
    "source": "iana"
  },
  "application/trig": {
    "source": "iana"
  },
  "application/ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttml"]
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/tzif": {
    "source": "iana"
  },
  "application/tzif-leap": {
    "source": "iana"
  },
  "application/ubjson": {
    "compressible": false,
    "extensions": ["ubj"]
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-ressheet+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsheet"]
  },
  "application/urc-targetdesc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["td"]
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["1km"]
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gmop+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-payload": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    "source": "iana"
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc","acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp","fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-charset": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    "source": "iana"
  },
  "application/vnd.afpc.modca": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    "source": "iana"
  },
  "application/vnd.ah-barcode": {
    "source": "iana"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amadeus+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    "source": "iana"
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.android.ota": {
    "source": "iana"
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.aplextor.warrp+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apothekende.reservation+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    "source": "iana",
    "extensions": ["key"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    "source": "iana",
    "extensions": ["numbers"]
  },
  "application/vnd.apple.pages": {
    "source": "iana",
    "extensions": ["pages"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "iana"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artisan+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avalon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.avistar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmml"]
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.banana-accounting": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.error": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bint.med-content": {
    "source": "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.blink-idb-value-wrapper": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.bpf": {
    "source": "iana"
  },
  "application/vnd.bpf3": {
    "source": "iana"
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.capasystems-pg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    "source": "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.ciedi": {
    "source": "iana"
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csl"]
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g","c4d","c4f","c4p","c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.comicbook+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.comicbook-rar": {
    "source": "iana"
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wbs"]
  },
  "application/vnd.cryptii.pipe+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.crypto-shade-file": {
    "source": "iana"
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.d3m-dataset": {
    "source": "iana"
  },
  "application/vnd.d3m-problem": {
    "source": "iana"
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.datapackage+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dataresource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dbf": {
    "source": "iana",
    "extensions": ["dbf"]
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf","uvvf","uvd","uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uvt","uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx","uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz","uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbisl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecip.rlp": {
    "source": "iana"
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.efi.img": {
    "source": "iana"
  },
  "application/vnd.efi.iso": {
    "source": "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.espass-espass+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es3","et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    "source": "iana"
  },
  "application/vnd.exstream-empower+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.exstream-package": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed","dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm","frame","maker","book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "iana",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "iana",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.futoin+cbor": {
    "source": "iana"
  },
  "application/vnd.futoin+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.gentics.grd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geo+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex","gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf","gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.hdt": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyper-item+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "iana"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "iana",
    "extensions": ["afp","listafp","list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc","icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.imagemeter.image+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informix-visionary": {
    "source": "iana"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw","xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.iso11783-10+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz","ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr","kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd","kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne","knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp","skd","skt","skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las": {
    "source": "iana"
  },
  "application/vnd.las.las+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lasxml"]
  },
  "application/vnd.laszip": {
    "source": "iana"
  },
  "application/vnd.leap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lbe"]
  },
  "application/vnd.logipipe.circuit+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.loom": {
    "source": "iana"
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-outlook": {
    "compressible": false,
    "extensions": ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt","pps","pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-printschematicket+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp","mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps","wks","wcm","wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nearst.inv+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nimn": {
    "source": "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf","nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ac"]
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "iana",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "iana",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.ocf+cbor": {
    "source": "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+cbor": {
    "source": "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+tlv": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-email+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-file+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.onepager": {
    "source": "iana"
  },
  "application/vnd.onepagertamp": {
    "source": "iana"
  },
  "application/vnd.onepagertamx": {
    "source": "iana"
  },
  "application/vnd.onepagertat": {
    "source": "iana"
  },
  "application/vnd.onepagertatp": {
    "source": "iana"
  },
  "application/vnd.onepagertatx": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["obgx"]
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osm"]
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "iana",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "iana",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "iana",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb","pqa","oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "iana"
  },
  "application/vnd.patentdive": {
    "source": "iana"
  },
  "application/vnd.patientecommsdoc": {
    "source": "iana"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.psfs": {
    "source": "iana"
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quarantainenet": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.rar": {
    "source": "iana",
    "extensions": ["rar"]
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.restful+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sar": {
    "source": "iana"
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shade-save-file": {
    "source": "iana"
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.shootproof+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shopkick+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shp": {
    "source": "iana"
  },
  "application/vnd.shx": {
    "source": "iana"
  },
  "application/vnd.sigrok.session": {
    "source": "iana"
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd","twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.snesdev-page-table": {
    "source": "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fo"]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sdkm","sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sqlite3": {
    "source": "iana"
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw","vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus","susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.sycle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis","sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["ddf"]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tableschema+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap","cap","dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.tri.onesource": {
    "source": "iana"
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd","ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.vel+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.veryant.thin": {
    "source": "iana"
  },
  "application/vnd.ves.encrypted": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd","vst","vss","vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.youtube.yt": {
    "source": "iana"
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir","zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vxml"]
  },
  "application/voucher-cms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/wasm": {
    "compressible": true,
    "extensions": ["wasm"]
  },
  "application/watcherinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/webpush-options+json": {
    "source": "iana",
    "compressible": true
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-arj": {
    "compressible": false,
    "extensions": ["arj"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab","x32","u32","vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb","blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2","boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr","cba","cbt","cbz","cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb","udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa","pfb","pfm","afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-keepass2": {
    "extensions": ["kdbx"]
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh","lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc","mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe","dll","com","bat","msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb","m13","m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf","wmz","emf","emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc","cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl","pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc","pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12","pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b","spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-pki-message": {
    "source": "iana"
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl","tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo","texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    "compressible": true,
    "extensions": ["hdd"]
  },
  "application/x-virtualbox-ova": {
    "compressible": true,
    "extensions": ["ova"]
  },
  "application/x-virtualbox-ovf": {
    "compressible": true,
    "extensions": ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    "compressible": true,
    "extensions": ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    "compressible": false,
    "extensions": ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    "compressible": true,
    "extensions": ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    "compressible": true,
    "extensions": ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    "compressible": true,
    "extensions": ["vmdk"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "iana",
    "extensions": ["der","crt","pem"]
  },
  "application/x-x509-ca-ra-cert": {
    "source": "iana"
  },
  "application/x-x509-next-ca-cert": {
    "source": "iana"
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xaml+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xav"]
  },
  "application/xcap-caps+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xca"]
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xel"]
  },
  "application/xcap-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/xcap-ns+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xns"]
  },
  "application/xcon-conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xenc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xenc"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml","xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/xliff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml","xsl","xsd","rng"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xmpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsl","xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mxml","xhvml","xvml","xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yang-data+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yin+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "application/zstd": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana",
    "compressible": false,
    "extensions": ["3gpp"]
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/aac": {
    "source": "iana"
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana"
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au","snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/flexfec": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/melp": {
    "source": "iana"
  },
  "audio/melp1200": {
    "source": "iana"
  },
  "audio/melp2400": {
    "source": "iana"
  },
  "audio/melp600": {
    "source": "iana"
  },
  "audio/mhas": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid","midi","kar","rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana",
    "extensions": ["mxmf"]
  },
  "audio/mp3": {
    "compressible": false,
    "extensions": ["mp3"]
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["m4a","mp4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga","ogg","spx"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sofa": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tetra_acelp": {
    "source": "iana"
  },
  "audio/tetra_acelp_bb": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/tsvcis": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/usac": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva","uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    "source": "iana"
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.presonus.multitrack": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif","aiff","aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram","ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/collection": {
    "source": "iana",
    "extensions": ["ttc"]
  },
  "font/otf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["otf"]
  },
  "font/sfnt": {
    "source": "iana"
  },
  "font/ttf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttf"]
  },
  "font/woff": {
    "source": "iana",
    "extensions": ["woff"]
  },
  "font/woff2": {
    "source": "iana",
    "extensions": ["woff2"]
  },
  "image/aces": {
    "source": "iana",
    "extensions": ["exr"]
  },
  "image/apng": {
    "compressible": false,
    "extensions": ["apng"]
  },
  "image/avci": {
    "source": "iana"
  },
  "image/avcs": {
    "source": "iana"
  },
  "image/avif": {
    "compressible": false,
    "extensions": ["avif"]
  },
  "image/bmp": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/dicom-rle": {
    "source": "iana",
    "extensions": ["drle"]
  },
  "image/emf": {
    "source": "iana",
    "extensions": ["emf"]
  },
  "image/fits": {
    "source": "iana",
    "extensions": ["fits"]
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/heic": {
    "source": "iana",
    "extensions": ["heic"]
  },
  "image/heic-sequence": {
    "source": "iana",
    "extensions": ["heics"]
  },
  "image/heif": {
    "source": "iana",
    "extensions": ["heif"]
  },
  "image/heif-sequence": {
    "source": "iana",
    "extensions": ["heifs"]
  },
  "image/hej2k": {
    "source": "iana",
    "extensions": ["hej2"]
  },
  "image/hsj2": {
    "source": "iana",
    "extensions": ["hsj2"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jls": {
    "source": "iana",
    "extensions": ["jls"]
  },
  "image/jp2": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jp2","jpg2"]
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg","jpg","jpe"]
  },
  "image/jph": {
    "source": "iana",
    "extensions": ["jph"]
  },
  "image/jphc": {
    "source": "iana",
    "extensions": ["jhc"]
  },
  "image/jpm": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpm"]
  },
  "image/jpx": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpx","jpf"]
  },
  "image/jxr": {
    "source": "iana",
    "extensions": ["jxr"]
  },
  "image/jxra": {
    "source": "iana",
    "extensions": ["jxra"]
  },
  "image/jxrs": {
    "source": "iana",
    "extensions": ["jxrs"]
  },
  "image/jxs": {
    "source": "iana",
    "extensions": ["jxs"]
  },
  "image/jxsc": {
    "source": "iana",
    "extensions": ["jxsc"]
  },
  "image/jxsi": {
    "source": "iana",
    "extensions": ["jxsi"]
  },
  "image/jxss": {
    "source": "iana",
    "extensions": ["jxss"]
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/ktx2": {
    "source": "iana",
    "extensions": ["ktx2"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif"]
  },
  "image/prs.pti": {
    "source": "iana",
    "extensions": ["pti"]
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg","svgz"]
  },
  "image/t38": {
    "source": "iana",
    "extensions": ["t38"]
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tif","tiff"]
  },
  "image/tiff-fx": {
    "source": "iana",
    "extensions": ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana",
    "extensions": ["azv"]
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi","uvvi","uvg","uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu","djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana",
    "extensions": ["ico"]
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-dds": {
    "extensions": ["dds"]
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.pco.b16": {
    "source": "iana",
    "extensions": ["b16"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana",
    "extensions": ["tap"]
  },
  "image/vnd.valve.source.texture": {
    "source": "iana",
    "extensions": ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana",
    "extensions": ["pcx"]
  },
  "image/webp": {
    "source": "apache",
    "extensions": ["webp"]
  },
  "image/wmf": {
    "source": "iana",
    "extensions": ["wmf"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh","fhc","fh4","fh5","fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic","pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana",
    "extensions": [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana",
    "extensions": ["u8msg"]
  },
  "message/global-delivery-status": {
    "source": "iana",
    "extensions": ["u8dsn"]
  },
  "message/global-disposition-notification": {
    "source": "iana",
    "extensions": ["u8mdn"]
  },
  "message/global-headers": {
    "source": "iana",
    "extensions": ["u8hdr"]
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "iana"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml","mime"]
  },
  "message/s-http": {
    "source": "iana"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "iana"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana",
    "extensions": ["wsc"]
  },
  "model/3mf": {
    "source": "iana",
    "extensions": ["3mf"]
  },
  "model/e57": {
    "source": "iana"
  },
  "model/gltf+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gltf"]
  },
  "model/gltf-binary": {
    "source": "iana",
    "compressible": true,
    "extensions": ["glb"]
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs","iges"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh","mesh","silo"]
  },
  "model/mtl": {
    "source": "iana",
    "extensions": ["mtl"]
  },
  "model/obj": {
    "source": "iana",
    "extensions": ["obj"]
  },
  "model/stl": {
    "source": "iana",
    "extensions": ["stl"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana",
    "extensions": ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana",
    "extensions": ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana",
    "extensions": ["x_t"]
  },
  "model/vnd.rosette.annotated-data-model": {
    "source": "iana"
  },
  "model/vnd.usdz+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana",
    "extensions": ["bsp"]
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl","vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db","x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana",
    "extensions": ["x3db"]
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv","x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d","x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana",
    "extensions": ["x3dv"]
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana"
  },
  "multipart/multilingual": {
    "source": "iana"
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/vnd.bint.med-plus": {
    "source": "iana"
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache","manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics","ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee","litcoffee"]
  },
  "text/css": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "iana"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/flexfec": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/gff3": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html","htm","shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "compressible": true
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "compressible": true,
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana",
    "compressible": true,
    "extensions": ["markdown","md"]
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mdx": {
    "compressible": true,
    "extensions": ["mdx"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt","text","conf","def","list","log","in","ini"]
  },
  "text/provenance-notation": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/prs.prop.logic": {
    "source": "iana"
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml","sgm"]
  },
  "text/shaclc": {
    "source": "iana"
  },
  "text/shex": {
    "extensions": ["shex"]
  },
  "text/slim": {
    "extensions": ["slim","slm"]
  },
  "text/spdx": {
    "source": "iana",
    "extensions": ["spdx"]
  },
  "text/strings": {
    "source": "iana"
  },
  "text/stylus": {
    "extensions": ["stylus","styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t","tr","roff","man","me","ms"]
  },
  "text/turtle": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri","uris","urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.ascii-art": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.ficlab.flt": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.gml": {
    "source": "iana"
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.hans": {
    "source": "iana"
  },
  "text/vnd.hgl": {
    "source": "iana"
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.senx.warpscript": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "iana"
  },
  "text/vnd.sosi": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s","asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f","for","f77","f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-org": {
    "compressible": true,
    "extensions": ["org"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p","pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "extensions": ["yaml","yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "video/3gpp": {
    "source": "iana",
    "extensions": ["3gp","3gpp"]
  },
  "video/3gpp-tt": {
    "source": "iana"
  },
  "video/3gpp2": {
    "source": "iana",
    "extensions": ["3g2"]
  },
  "video/bmpeg": {
    "source": "iana"
  },
  "video/bt656": {
    "source": "iana"
  },
  "video/celb": {
    "source": "iana"
  },
  "video/dv": {
    "source": "iana"
  },
  "video/encaprtp": {
    "source": "iana"
  },
  "video/flexfec": {
    "source": "iana"
  },
  "video/h261": {
    "source": "iana",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "iana",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "iana"
  },
  "video/h263-2000": {
    "source": "iana"
  },
  "video/h264": {
    "source": "iana",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "iana"
  },
  "video/h264-svc": {
    "source": "iana"
  },
  "video/h265": {
    "source": "iana"
  },
  "video/iso.segment": {
    "source": "iana"
  },
  "video/jpeg": {
    "source": "iana",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "iana"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm","jpgm"]
  },
  "video/mj2": {
    "source": "iana",
    "extensions": ["mj2","mjp2"]
  },
  "video/mp1s": {
    "source": "iana"
  },
  "video/mp2p": {
    "source": "iana"
  },
  "video/mp2t": {
    "source": "iana",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4","mp4v","mpg4"]
  },
  "video/mp4v-es": {
    "source": "iana"
  },
  "video/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]
  },
  "video/mpeg4-generic": {
    "source": "iana"
  },
  "video/mpv": {
    "source": "iana"
  },
  "video/nv": {
    "source": "iana"
  },
  "video/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "iana"
  },
  "video/pointer": {
    "source": "iana"
  },
  "video/quicktime": {
    "source": "iana",
    "compressible": false,
    "extensions": ["qt","mov"]
  },
  "video/raptorfec": {
    "source": "iana"
  },
  "video/raw": {
    "source": "iana"
  },
  "video/rtp-enc-aescm128": {
    "source": "iana"
  },
  "video/rtploopback": {
    "source": "iana"
  },
  "video/rtx": {
    "source": "iana"
  },
  "video/smpte291": {
    "source": "iana"
  },
  "video/smpte292m": {
    "source": "iana"
  },
  "video/ulpfec": {
    "source": "iana"
  },
  "video/vc1": {
    "source": "iana"
  },
  "video/vc2": {
    "source": "iana"
  },
  "video/vnd.cctv": {
    "source": "iana"
  },
  "video/vnd.dece.hd": {
    "source": "iana",
    "extensions": ["uvh","uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "iana",
    "extensions": ["uvm","uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "iana"
  },
  "video/vnd.dece.pd": {
    "source": "iana",
    "extensions": ["uvp","uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "iana",
    "extensions": ["uvs","uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "iana",
    "extensions": ["uvv","uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dvb.file": {
    "source": "iana",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "iana",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "iana"
  },
  "video/vnd.motorola.video": {
    "source": "iana"
  },
  "video/vnd.motorola.videop": {
    "source": "iana"
  },
  "video/vnd.mpegurl": {
    "source": "iana",
    "extensions": ["mxu","m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "iana",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "iana"
  },
  "video/vnd.nokia.mp4vr": {
    "source": "iana"
  },
  "video/vnd.nokia.videovoip": {
    "source": "iana"
  },
  "video/vnd.objectvideo": {
    "source": "iana"
  },
  "video/vnd.radgamettools.bink": {
    "source": "iana"
  },
  "video/vnd.radgamettools.smacker": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "iana"
  },
  "video/vnd.sealed.swf": {
    "source": "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "iana"
  },
  "video/vnd.uvvu.mp4": {
    "source": "iana",
    "extensions": ["uvu","uvvu"]
  },
  "video/vnd.vivo": {
    "source": "iana",
    "extensions": ["viv"]
  },
  "video/vnd.youtube.yt": {
    "source": "iana"
  },
  "video/vp8": {
    "source": "iana"
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv","mk3d","mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf","asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
}`));
        }
    };
});
System.register("https://deno.land/x/media_types@v2.5.1/deps", ["https://deno.land/std@0.73.0/path/mod"], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [
            function (mod_ts_8_1) {
                exports_32({
                    "extname": mod_ts_8_1["extname"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-types and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015 Douglas Christopher Wilson <doug@somethingdoug.com>
 * Copyright (c) 2020 the Deno authors
 * Copyright (c) 2020 the oak authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.5.1/mod", ["https://deno.land/x/media_types@v2.5.1/db", "https://deno.land/x/media_types@v2.5.1/deps"], function (exports_33, context_33) {
    "use strict";
    var db_ts_1, deps_ts_1, EXTRACT_TYPE_REGEXP, TEXT_TYPE_REGEXP, extensions, types;
    var __moduleName = context_33 && context_33.id;
    function populateMaps(extensions, types) {
        const preference = ["nginx", "apache", undefined, "iana"];
        for (const type of Object.keys(db_ts_1.db)) {
            const mime = db_ts_1.db[type];
            const exts = mime.extensions;
            if (!exts || !exts.length) {
                continue;
            }
            extensions.set(type, exts);
            for (const ext of exts) {
                const current = types.get(ext);
                if (current) {
                    const from = preference.indexOf(db_ts_1.db[current].source);
                    const to = preference.indexOf(mime.source);
                    if (current !== "application/octet-stream" &&
                        (from > to ||
                            (from === to && current.substr(0, 12) === "application/"))) {
                        continue;
                    }
                }
                types.set(ext, type);
            }
        }
    }
    function charset(type) {
        const m = EXTRACT_TYPE_REGEXP.exec(type);
        if (!m) {
            return;
        }
        const [match] = m;
        const mime = db_ts_1.db[match.toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (TEXT_TYPE_REGEXP.test(match)) {
            return "UTF-8";
        }
    }
    exports_33("charset", charset);
    function lookup(path) {
        const extension = deps_ts_1.extname("x." + path)
            .toLowerCase()
            .substr(1);
        return types.get(extension);
    }
    exports_33("lookup", lookup);
    function contentType(str) {
        let mime = str.includes("/") ? str : lookup(str);
        if (!mime) {
            return;
        }
        if (!mime.includes("charset")) {
            const cs = charset(mime);
            if (cs) {
                mime += `; charset=${cs.toLowerCase()}`;
            }
        }
        return mime;
    }
    exports_33("contentType", contentType);
    function extension(type) {
        const match = EXTRACT_TYPE_REGEXP.exec(type);
        if (!match) {
            return;
        }
        const exts = extensions.get(match[1].toLowerCase());
        if (!exts || !exts.length) {
            return;
        }
        return exts[0];
    }
    exports_33("extension", extension);
    return {
        setters: [
            function (db_ts_1_1) {
                db_ts_1 = db_ts_1_1;
            },
            function (deps_ts_1_1) {
                deps_ts_1 = deps_ts_1_1;
            }
        ],
        execute: function () {
            EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            TEXT_TYPE_REGEXP = /^text\//i;
            exports_33("extensions", extensions = new Map());
            exports_33("types", types = new Map());
            populateMaps(extensions, types);
        }
    };
});
System.register("https://deno.land/x/path_to_regexp@v6.2.0/index", [], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    function lexer(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                let name = "";
                let j = i + 1;
                while (j < str.length) {
                    const code = str.charCodeAt(j);
                    if ((code >= 48 && code <= 57) ||
                        (code >= 65 && code <= 90) ||
                        (code >= 97 && code <= 122) ||
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError(`Missing parameter name at ${i}`);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                let count = 1;
                let pattern = "";
                let j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError(`Pattern cannot start with "?" at ${j}`);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError(`Capturing groups are not allowed at ${j}`);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError(`Unbalanced pattern at ${i}`);
                if (!pattern)
                    throw new TypeError(`Missing pattern at ${i}`);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    function parse(str, options = {}) {
        const tokens = lexer(str);
        const { prefixes = "./" } = options;
        const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
        const result = [];
        let key = 0;
        let i = 0;
        let path = "";
        const tryConsume = (type) => {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        const mustConsume = (type) => {
            const value = tryConsume(type);
            if (value !== undefined)
                return value;
            const { type: nextType, index } = tokens[i];
            throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
        };
        const consumeText = () => {
            let result = "";
            let value;
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            const char = tryConsume("CHAR");
            const name = tryConsume("NAME");
            const pattern = tryConsume("PATTERN");
            if (name || pattern) {
                let prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            const value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            const open = tryConsume("OPEN");
            if (open) {
                const prefix = consumeText();
                const name = tryConsume("NAME") || "";
                const pattern = tryConsume("PATTERN") || "";
                const suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name || (pattern ? key++ : ""),
                    pattern: name && !pattern ? defaultPattern : pattern,
                    prefix,
                    suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    exports_34("parse", parse);
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    exports_34("compile", compile);
    function tokensToFunction(tokens, options = {}) {
        const reFlags = flags(options);
        const { encode = (x) => x, validate = true } = options;
        const matches = tokens.map(token => {
            if (typeof token === "object") {
                return new RegExp(`^(?:${token.pattern})$`, reFlags);
            }
        });
        return (data) => {
            let path = "";
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                const value = data ? data[token.name] : undefined;
                const optional = token.modifier === "?" || token.modifier === "*";
                const repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError(`Expected "${token.name}" to not be empty`);
                    }
                    for (let j = 0; j < value.length; j++) {
                        const segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    const segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                const typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
            }
            return path;
        };
    }
    exports_34("tokensToFunction", tokensToFunction);
    function match(str, options) {
        const keys = [];
        const re = pathToRegexp(str, keys, options);
        return regexpToFunction(re, keys, options);
    }
    exports_34("match", match);
    function regexpToFunction(re, keys, options = {}) {
        const { decode = (x) => x } = options;
        return function (pathname) {
            const m = re.exec(pathname);
            if (!m)
                return false;
            const { 0: path, index } = m;
            const params = Object.create(null);
            for (let i = 1; i < m.length; i++) {
                if (m[i] === undefined)
                    continue;
                const key = keys[i - 1];
                if (key.modifier === "*" || key.modifier === "+") {
                    params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {
                        return decode(value, key);
                    });
                }
                else {
                    params[key.name] = decode(m[i], key);
                }
            }
            return { path, index, params };
        };
    }
    exports_34("regexpToFunction", regexpToFunction);
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        const groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
        let index = 0;
        let execResult = groupsRegex.exec(path.source);
        while (execResult) {
            keys.push({
                name: execResult[1] || index++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
            execResult = groupsRegex.exec(path.source);
        }
        return path;
    }
    function arrayToRegexp(paths, keys, options) {
        const parts = paths.map(path => pathToRegexp(path, keys, options).source);
        return new RegExp(`(?:${parts.join("|")})`, flags(options));
    }
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options = {}) {
        const { strict = false, start = true, end = true, encode = (x) => x } = options;
        const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
        const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
        let route = start ? "^" : "";
        for (const token of tokens) {
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                const prefix = escapeString(encode(token.prefix));
                const suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            const mod = token.modifier === "*" ? "?" : "";
                            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                        }
                        else {
                            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                        }
                    }
                    else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
                else {
                    route += `(?:${prefix}${suffix})${token.modifier}`;
                }
            }
        }
        if (end) {
            if (!strict)
                route += `${delimiter}?`;
            route += !options.endsWith ? "$" : `(?=${endsWith})`;
        }
        else {
            const endToken = tokens[tokens.length - 1];
            const isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                :
                    endToken === undefined;
            if (!strict) {
                route += `(?:${delimiter}(?=${endsWith}))?`;
            }
            if (!isEndDelimited) {
                route += `(?=${delimiter}|${endsWith})`;
            }
        }
        return new RegExp(route, flags(options));
    }
    exports_34("tokensToRegexp", tokensToRegexp);
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }
    exports_34("pathToRegexp", pathToRegexp);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/deps", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/hash/sha1", "https://deno.land/std@0.73.0/hash/sha256", "https://deno.land/std@0.73.0/http/server", "https://deno.land/std@0.73.0/http/http_status", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/path/mod", "https://deno.land/std@0.73.0/testing/asserts", "https://deno.land/std@0.73.0/ws/mod", "https://deno.land/x/media_types@v2.5.1/mod", "https://deno.land/x/path_to_regexp@v6.2.0/index"], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    return {
        setters: [
            function (mod_ts_9_1) {
                exports_35({
                    "copyBytes": mod_ts_9_1["copyBytes"],
                    "equal": mod_ts_9_1["equal"]
                });
            },
            function (sha1_ts_2_1) {
                exports_35({
                    "Sha1": sha1_ts_2_1["Sha1"]
                });
            },
            function (sha256_ts_1_1) {
                exports_35({
                    "HmacSha256": sha256_ts_1_1["HmacSha256"]
                });
            },
            function (server_ts_2_1) {
                exports_35({
                    "serve": server_ts_2_1["serve"],
                    "serveTLS": server_ts_2_1["serveTLS"]
                });
            },
            function (http_status_ts_2_1) {
                exports_35({
                    "Status": http_status_ts_2_1["Status"],
                    "STATUS_TEXT": http_status_ts_2_1["STATUS_TEXT"]
                });
            },
            function (bufio_ts_4_1) {
                exports_35({
                    "BufReader": bufio_ts_4_1["BufReader"],
                    "BufWriter": bufio_ts_4_1["BufWriter"]
                });
            },
            function (mod_ts_10_1) {
                exports_35({
                    "basename": mod_ts_10_1["basename"],
                    "extname": mod_ts_10_1["extname"],
                    "isAbsolute": mod_ts_10_1["isAbsolute"],
                    "join": mod_ts_10_1["join"],
                    "normalize": mod_ts_10_1["normalize"],
                    "parse": mod_ts_10_1["parse"],
                    "sep": mod_ts_10_1["sep"]
                });
            },
            function (asserts_ts_1_1) {
                exports_35({
                    "assert": asserts_ts_1_1["assert"]
                });
            },
            function (mod_ts_11_1) {
                exports_35({
                    "acceptable": mod_ts_11_1["acceptable"],
                    "acceptWebSocket": mod_ts_11_1["acceptWebSocket"]
                });
            },
            function (mod_ts_12_1) {
                exports_35({
                    "contentType": mod_ts_12_1["contentType"],
                    "extension": mod_ts_12_1["extension"],
                    "lookup": mod_ts_12_1["lookup"]
                });
            },
            function (index_ts_1_1) {
                exports_35({
                    "compile": index_ts_1_1["compile"],
                    "pathParse": index_ts_1_1["parse"],
                    "pathToRegexp": index_ts_1_1["pathToRegexp"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/tssCompare", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_36, context_36) {
    "use strict";
    var deps_ts_2;
    var __moduleName = context_36 && context_36.id;
    function compareArrayBuffer(a, b) {
        deps_ts_2.assert(a.byteLength === b.byteLength, "ArrayBuffer lengths must match.");
        const va = new DataView(a);
        const vb = new DataView(b);
        const length = va.byteLength;
        let out = 0;
        let i = -1;
        while (++i < length) {
            out |= va.getUint8(i) ^ vb.getUint8(i);
        }
        return out === 0;
    }
    function compare(a, b) {
        const key = new Uint8Array(32);
        globalThis.crypto.getRandomValues(key);
        const ah = (new deps_ts_2.HmacSha256(key)).update(a).arrayBuffer();
        const bh = (new deps_ts_2.HmacSha256(key)).update(b).arrayBuffer();
        return compareArrayBuffer(ah, bh);
    }
    exports_36("compare", compare);
    return {
        setters: [
            function (deps_ts_2_1) {
                deps_ts_2 = deps_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/keyStack", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/tssCompare"], function (exports_37, context_37) {
    "use strict";
    var deps_ts_3, tssCompare_ts_1, replacements, KeyStack;
    var __moduleName = context_37 && context_37.id;
    return {
        setters: [
            function (deps_ts_3_1) {
                deps_ts_3 = deps_ts_3_1;
            },
            function (tssCompare_ts_1_1) {
                tssCompare_ts_1 = tssCompare_ts_1_1;
            }
        ],
        execute: function () {
            replacements = {
                "/": "_",
                "+": "-",
                "=": "",
            };
            KeyStack = class KeyStack {
                constructor(keys) {
                    this.#sign = (data, key) => {
                        return btoa(String.fromCharCode.apply(undefined, new Uint8Array(new deps_ts_3.HmacSha256(key).update(data).arrayBuffer())))
                            .replace(/\/|\+|=/g, (c) => replacements[c]);
                    };
                    if (!(0 in keys)) {
                        throw new TypeError("keys must contain at least one value");
                    }
                    this.#keys = keys;
                }
                #keys;
                #sign;
                sign(data) {
                    return this.#sign(data, this.#keys[0]);
                }
                verify(data, digest) {
                    return this.indexOf(data, digest) > -1;
                }
                indexOf(data, digest) {
                    for (let i = 0; i < this.#keys.length; i++) {
                        if (tssCompare_ts_1.compare(digest, this.#sign(data, this.#keys[i]))) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
            exports_37("KeyStack", KeyStack);
        }
    };
});
/*!
 * Adapted directly from http-errors at https://github.com/jshttp/http-errors
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong me@jongleberry.com
 * Copyright (c) 2016 Douglas Christopher Wilson doug@somethingdoug.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/httpError", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_38, context_38) {
    "use strict";
    var deps_ts_4, errorStatusMap, HttpError, httpErrors;
    var __moduleName = context_38 && context_38.id;
    function createHttpErrorConstructor(status) {
        const name = `${deps_ts_4.Status[status]}Error`;
        const Ctor = class extends HttpError {
            constructor(message) {
                super();
                this.message = message || deps_ts_4.STATUS_TEXT.get(status);
                this.status = status;
                this.expose = status >= 400 && status < 500 ? true : false;
                Object.defineProperty(this, "name", {
                    configurable: true,
                    enumerable: false,
                    value: name,
                    writable: true,
                });
            }
        };
        return Ctor;
    }
    function createHttpError(status = 500, message) {
        return new httpErrors[deps_ts_4.Status[status]](message);
    }
    exports_38("createHttpError", createHttpError);
    function isHttpError(value) {
        return value instanceof HttpError;
    }
    exports_38("isHttpError", isHttpError);
    return {
        setters: [
            function (deps_ts_4_1) {
                deps_ts_4 = deps_ts_4_1;
            }
        ],
        execute: function () {
            errorStatusMap = {
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "RequestEntityTooLarge": 413,
                "RequestURITooLong": 414,
                "UnsupportedMediaType": 415,
                "RequestedRangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "Teapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HTTPVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511,
            };
            HttpError = class HttpError extends Error {
                constructor() {
                    super(...arguments);
                    this.expose = false;
                    this.status = deps_ts_4.Status.InternalServerError;
                }
            };
            exports_38("HttpError", HttpError);
            exports_38("httpErrors", httpErrors = {});
            for (const [key, value] of Object.entries(errorStatusMap)) {
                httpErrors[key] = createHttpErrorConstructor(value);
            }
        }
    };
});
/*!
 * Adapted directly from media-typer at https://github.com/jshttp/media-typer/
 * which is licensed as follows:
 *
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.3.1/mediaTyper", [], function (exports_39, context_39) {
    "use strict";
    var SUBTYPE_NAME_REGEXP, TYPE_NAME_REGEXP, TYPE_REGEXP, MediaType;
    var __moduleName = context_39 && context_39.id;
    function format(obj) {
        const { subtype, suffix, type } = obj;
        if (!TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("Invalid type.");
        }
        if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("Invalid subtype.");
        }
        let str = `${type}/${subtype}`;
        if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
                throw new TypeError("Invalid suffix.");
            }
            str += `+${suffix}`;
        }
        return str;
    }
    exports_39("format", format);
    function parse(str) {
        const match = TYPE_REGEXP.exec(str.toLowerCase());
        if (!match) {
            throw new TypeError("Invalid media type.");
        }
        let [, type, subtype] = match;
        let suffix;
        const idx = subtype.lastIndexOf("+");
        if (idx !== -1) {
            suffix = subtype.substr(idx + 1);
            subtype = subtype.substr(0, idx);
        }
        return new MediaType(type, subtype, suffix);
    }
    exports_39("parse", parse);
    return {
        setters: [],
        execute: function () {
            SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            MediaType = class MediaType {
                constructor(type, subtype, suffix) {
                    this.type = type;
                    this.subtype = subtype;
                    this.suffix = suffix;
                }
            };
        }
    };
});
/*!
 * Adapted directly from type-is at https://github.com/jshttp/type-is/
 * which is licensed as follows:
 *
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.3.1/isMediaType", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/mediaTyper"], function (exports_40, context_40) {
    "use strict";
    var deps_ts_5, mediaTyper_ts_1;
    var __moduleName = context_40 && context_40.id;
    function mimeMatch(expected, actual) {
        if (expected === undefined) {
            return false;
        }
        const actualParts = actual.split("/");
        const expectedParts = expected.split("/");
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        const [actualType, actualSubtype] = actualParts;
        const [expectedType, expectedSubtype] = expectedParts;
        if (expectedType !== "*" && expectedType !== actualType) {
            return false;
        }
        if (expectedSubtype.substr(0, 2) === "*+") {
            return (expectedSubtype.length <= actualSubtype.length + 1 &&
                expectedSubtype.substr(1) ===
                    actualSubtype.substr(1 - expectedSubtype.length));
        }
        if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
            return false;
        }
        return true;
    }
    function normalize(type) {
        if (type === "urlencoded") {
            return "application/x-www-form-urlencoded";
        }
        else if (type === "multipart") {
            return "multipart/*";
        }
        else if (type[0] === "+") {
            return `*/*${type}`;
        }
        return type.includes("/") ? type : deps_ts_5.lookup(type);
    }
    function normalizeType(value) {
        try {
            const val = value.split(";");
            const type = mediaTyper_ts_1.parse(val[0]);
            return mediaTyper_ts_1.format(type);
        }
        catch {
            return;
        }
    }
    function isMediaType(value, types) {
        const val = normalizeType(value);
        if (!val) {
            return false;
        }
        if (!types.length) {
            return val;
        }
        for (const type of types) {
            if (mimeMatch(normalize(type), val)) {
                return type[0] === "+" || type.includes("*") ? val : type;
            }
        }
        return false;
    }
    exports_40("isMediaType", isMediaType);
    return {
        setters: [
            function (deps_ts_5_1) {
                deps_ts_5 = deps_ts_5_1;
            },
            function (mediaTyper_ts_1_1) {
                mediaTyper_ts_1 = mediaTyper_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/util", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError"], function (exports_41, context_41) {
    "use strict";
    var deps_ts_6, httpError_ts_1, ENCODE_CHARS_REGEXP, HTAB, SPACE, CR, LF, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, UP_PATH_REGEXP;
    var __moduleName = context_41 && context_41.id;
    function decodeComponent(text) {
        try {
            return decodeURIComponent(text);
        }
        catch {
            return text;
        }
    }
    exports_41("decodeComponent", decodeComponent);
    function encodeUrl(url) {
        return String(url)
            .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
            .replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    exports_41("encodeUrl", encodeUrl);
    function getRandomFilename(prefix = "", extension = "") {
        return `${prefix}${new deps_ts_6.Sha1().update(crypto.getRandomValues(new Uint8Array(256))).hex()}${extension ? `.${extension}` : ""}`;
    }
    exports_41("getRandomFilename", getRandomFilename);
    function isErrorStatus(value) {
        return [
            deps_ts_6.Status.BadRequest,
            deps_ts_6.Status.Unauthorized,
            deps_ts_6.Status.PaymentRequired,
            deps_ts_6.Status.Forbidden,
            deps_ts_6.Status.NotFound,
            deps_ts_6.Status.MethodNotAllowed,
            deps_ts_6.Status.NotAcceptable,
            deps_ts_6.Status.ProxyAuthRequired,
            deps_ts_6.Status.RequestTimeout,
            deps_ts_6.Status.Conflict,
            deps_ts_6.Status.Gone,
            deps_ts_6.Status.LengthRequired,
            deps_ts_6.Status.PreconditionFailed,
            deps_ts_6.Status.RequestEntityTooLarge,
            deps_ts_6.Status.RequestURITooLong,
            deps_ts_6.Status.UnsupportedMediaType,
            deps_ts_6.Status.RequestedRangeNotSatisfiable,
            deps_ts_6.Status.ExpectationFailed,
            deps_ts_6.Status.Teapot,
            deps_ts_6.Status.MisdirectedRequest,
            deps_ts_6.Status.UnprocessableEntity,
            deps_ts_6.Status.Locked,
            deps_ts_6.Status.FailedDependency,
            deps_ts_6.Status.UpgradeRequired,
            deps_ts_6.Status.PreconditionRequired,
            deps_ts_6.Status.TooManyRequests,
            deps_ts_6.Status.RequestHeaderFieldsTooLarge,
            deps_ts_6.Status.UnavailableForLegalReasons,
            deps_ts_6.Status.InternalServerError,
            deps_ts_6.Status.NotImplemented,
            deps_ts_6.Status.BadGateway,
            deps_ts_6.Status.ServiceUnavailable,
            deps_ts_6.Status.GatewayTimeout,
            deps_ts_6.Status.HTTPVersionNotSupported,
            deps_ts_6.Status.VariantAlsoNegotiates,
            deps_ts_6.Status.InsufficientStorage,
            deps_ts_6.Status.LoopDetected,
            deps_ts_6.Status.NotExtended,
            deps_ts_6.Status.NetworkAuthenticationRequired,
        ].includes(value);
    }
    exports_41("isErrorStatus", isErrorStatus);
    function isRedirectStatus(value) {
        return [
            deps_ts_6.Status.MultipleChoices,
            deps_ts_6.Status.MovedPermanently,
            deps_ts_6.Status.Found,
            deps_ts_6.Status.SeeOther,
            deps_ts_6.Status.UseProxy,
            deps_ts_6.Status.TemporaryRedirect,
            deps_ts_6.Status.PermanentRedirect,
        ].includes(value);
    }
    exports_41("isRedirectStatus", isRedirectStatus);
    function isHtml(value) {
        return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
    }
    exports_41("isHtml", isHtml);
    function skipLWSPChar(u8) {
        const result = new Uint8Array(u8.length);
        let j = 0;
        for (let i = 0; i < u8.length; i++) {
            if (u8[i] === SPACE || u8[i] === HTAB)
                continue;
            result[j++] = u8[i];
        }
        return result.slice(0, j);
    }
    exports_41("skipLWSPChar", skipLWSPChar);
    function stripEol(value) {
        if (value[value.byteLength - 1] == LF) {
            let drop = 1;
            if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
                drop = 2;
            }
            return value.subarray(0, value.byteLength - drop);
        }
        return value;
    }
    exports_41("stripEol", stripEol);
    function resolvePath(rootPath, relativePath) {
        let path = relativePath;
        let root = rootPath;
        if (relativePath === undefined) {
            path = rootPath;
            root = ".";
        }
        if (path == null) {
            throw new TypeError("Argument relativePath is required.");
        }
        if (path.includes("\0")) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (deps_ts_6.isAbsolute(path)) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (UP_PATH_REGEXP.test(deps_ts_6.normalize("." + deps_ts_6.sep + path))) {
            throw httpError_ts_1.createHttpError(403);
        }
        return deps_ts_6.normalize(deps_ts_6.join(root, path));
    }
    exports_41("resolvePath", resolvePath);
    return {
        setters: [
            function (deps_ts_6_1) {
                deps_ts_6 = deps_ts_6_1;
            },
            function (httpError_ts_1_1) {
                httpError_ts_1 = httpError_ts_1_1;
            }
        ],
        execute: function () {
            ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
            UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
            UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/buf_reader", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_42, context_42) {
    "use strict";
    var deps_ts_7, util_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, BufReader;
    var __moduleName = context_42 && context_42.id;
    return {
        setters: [
            function (deps_ts_7_1) {
                deps_ts_7 = deps_ts_7_1;
            },
            function (util_ts_1_1) {
                util_ts_1 = util_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_42("BufferFullError", BufferFullError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.#posRead = 0;
                    this.#posWrite = 0;
                    this.#eof = false;
                    this.#fill = async () => {
                        if (this.#posRead > 0) {
                            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
                            this.#posWrite -= this.#posRead;
                            this.#posRead = 0;
                        }
                        if (this.#posWrite >= this.#buffer.byteLength) {
                            throw Error("bufio: tried to fill full buffer");
                        }
                        for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
                            if (rr === null) {
                                this.#eof = true;
                                return;
                            }
                            deps_ts_7.assert(rr >= 0, "negative read");
                            this.#posWrite += rr;
                            if (rr > 0) {
                                return;
                            }
                        }
                        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                    };
                    this.#reset = (buffer, reader) => {
                        this.#buffer = buffer;
                        this.#reader = reader;
                        this.#eof = false;
                    };
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this.#reset(new Uint8Array(size), rd);
                }
                #buffer;
                #reader;
                #posRead;
                #posWrite;
                #eof;
                #fill;
                #reset;
                buffered() {
                    return this.#posWrite - this.#posRead;
                }
                async readLine(strip = true) {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        deps_ts_7.assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.#eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            deps_ts_7.assert(this.#posRead > 0, "Tried to rewind past start of buffer");
                            this.#posRead--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { bytes: partial, eol: this.#eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { bytes: line, eol: true };
                    }
                    if (strip) {
                        line = util_ts_1.stripEol(line);
                    }
                    return { bytes: line, eol: true };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.#buffer.subarray(this.#posRead + s, this.#posWrite).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.#buffer.subarray(this.#posRead, this.#posRead + i + 1);
                            this.#posRead += i + 1;
                            break;
                        }
                        if (this.#eof) {
                            if (this.#posRead === this.#posWrite) {
                                return null;
                            }
                            slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                            this.#posRead = this.#posWrite;
                            break;
                        }
                        if (this.buffered() >= this.#buffer.byteLength) {
                            this.#posRead = this.#posWrite;
                            const oldbuf = this.#buffer;
                            const newbuf = this.#buffer.slice(0);
                            this.#buffer = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.#posWrite - this.#posRead;
                        try {
                            await this.#fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
            };
            exports_42("BufReader", BufReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/headers", ["https://deno.land/x/oak@v6.3.1/httpError"], function (exports_43, context_43) {
    "use strict";
    var httpError_ts_2, COLON, HTAB, SPACE, decoder;
    var __moduleName = context_43 && context_43.id;
    function toParamRegExp(attributePattern, flags) {
        return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` +
            `(` +
            `[^";\\s][^;\\s]*` +
            `|` +
            `"(?:[^"\\\\]|\\\\"?)+"?` +
            `)`, flags);
    }
    exports_43("toParamRegExp", toParamRegExp);
    async function readHeaders(body) {
        const headers = {};
        let readResult = await body.readLine();
        while (readResult) {
            const { bytes } = readResult;
            if (!bytes.length) {
                return headers;
            }
            let i = bytes.indexOf(COLON);
            if (i === -1) {
                throw new httpError_ts_2.httpErrors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
            }
            const key = decoder.decode(bytes.subarray(0, i)).trim().toLowerCase();
            if (key === "") {
                throw new httpError_ts_2.httpErrors.BadRequest("Invalid header key.");
            }
            i++;
            while (i < bytes.byteLength && (bytes[i] === SPACE || bytes[i] === HTAB)) {
                i++;
            }
            const value = decoder.decode(bytes.subarray(i)).trim();
            headers[key] = value;
            readResult = await body.readLine();
        }
        throw new httpError_ts_2.httpErrors.BadRequest("Unexpected end of body reached.");
    }
    exports_43("readHeaders", readHeaders);
    function unquote(value) {
        if (value.startsWith(`"`)) {
            const parts = value.slice(1).split(`\\"`);
            for (let i = 0; i < parts.length; ++i) {
                const quoteIndex = parts[i].indexOf(`"`);
                if (quoteIndex !== -1) {
                    parts[i] = parts[i].slice(0, quoteIndex);
                    parts.length = i + 1;
                }
                parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join(`"`);
        }
        return value;
    }
    exports_43("unquote", unquote);
    return {
        setters: [
            function (httpError_ts_2_1) {
                httpError_ts_2 = httpError_ts_2_1;
            }
        ],
        execute: function () {
            COLON = ":".charCodeAt(0);
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            decoder = new TextDecoder();
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/content_disposition", ["https://deno.land/x/oak@v6.3.1/headers"], function (exports_44, context_44) {
    "use strict";
    var headers_ts_1, needsEncodingFixup, FILENAME_STAR_REGEX, FILENAME_START_ITER_REGEX, FILENAME_REGEX;
    var __moduleName = context_44 && context_44.id;
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textDecode("utf-8", value);
            if (needsEncodingFixup) {
                value = textDecode("iso-8859-1", value);
            }
        }
        return value;
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
        }
        return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text) => {
            if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                return textDecode(charset, text);
            }
            try {
                text = atob(text);
            }
            catch { }
            return textDecode(charset, text);
        });
    }
    function rfc2231getParam(header) {
        const matches = [];
        let match;
        while ((match = FILENAME_START_ITER_REGEX.exec(header))) {
            const [, ns, quote, part] = match;
            const n = parseInt(ns, 10);
            if (n in matches) {
                if (n === 0) {
                    break;
                }
                continue;
            }
            matches[n] = [quote, part];
        }
        const parts = [];
        for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
                break;
            }
            let [quote, part] = matches[n];
            part = headers_ts_1.unquote(part);
            if (quote) {
                part = unescape(part);
                if (n === 0) {
                    part = rfc5987decode(part);
                }
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc5987decode(value) {
        const encodingEnd = value.indexOf(`'`);
        if (encodingEnd === -1) {
            return value;
        }
        const encoding = value.slice(0, encodingEnd);
        const langValue = value.slice(encodingEnd + 1);
        return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
    }
    function textDecode(encoding, value) {
        if (encoding) {
            try {
                const decoder = new TextDecoder(encoding, { fatal: true });
                const bytes = Array.from(value, (c) => c.charCodeAt(0));
                if (bytes.every((code) => code <= 0xFF)) {
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                }
            }
            catch { }
        }
        return value;
    }
    function getFilename(header) {
        needsEncodingFixup = true;
        let matches = FILENAME_STAR_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(rfc5987decode(unescape(headers_ts_1.unquote(filename)))));
        }
        const filename = rfc2231getParam(header);
        if (filename) {
            return fixupEncoding(rfc2047decode(filename));
        }
        matches = FILENAME_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(headers_ts_1.unquote(filename)));
        }
        return "";
    }
    exports_44("getFilename", getFilename);
    return {
        setters: [
            function (headers_ts_1_1) {
                headers_ts_1 = headers_ts_1_1;
            }
        ],
        execute: function () {
            needsEncodingFixup = false;
            FILENAME_STAR_REGEX = headers_ts_1.toParamRegExp("filename\\*", "i");
            FILENAME_START_ITER_REGEX = headers_ts_1.toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            FILENAME_REGEX = headers_ts_1.toParamRegExp("filename", "i");
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/multipart", ["https://deno.land/x/oak@v6.3.1/buf_reader", "https://deno.land/x/oak@v6.3.1/content_disposition", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/headers", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/util"], function (exports_45, context_45) {
    "use strict";
    var buf_reader_ts_1, content_disposition_ts_1, deps_ts_8, headers_ts_2, httpError_ts_3, util_ts_2, decoder, encoder, BOUNDARY_PARAM_REGEX, DEFAULT_BUFFER_SIZE, DEFAULT_MAX_FILE_SIZE, DEFAULT_MAX_SIZE, NAME_PARAM_REGEX, FormDataReader;
    var __moduleName = context_45 && context_45.id;
    function append(a, b) {
        const ab = new Uint8Array(a.length + b.length);
        ab.set(a, 0);
        ab.set(b, a.length);
        return ab;
    }
    function isEqual(a, b) {
        return deps_ts_8.equal(util_ts_2.skipLWSPChar(a), b);
    }
    async function readToStartOrEnd(body, start, end) {
        let lineResult;
        while ((lineResult = await body.readLine())) {
            if (isEqual(lineResult.bytes, start)) {
                return true;
            }
            if (isEqual(lineResult.bytes, end)) {
                return false;
            }
        }
        throw new httpError_ts_3.httpErrors.BadRequest("Unable to find multi-part boundary.");
    }
    async function* parts({ body, final, part, maxFileSize, maxSize, outPath, prefix }) {
        async function getFile(contentType) {
            const ext = deps_ts_8.extension(contentType);
            if (!ext) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Invalid media type for part: ${ext}`);
            }
            if (!outPath) {
                outPath = await Deno.makeTempDir();
            }
            const filename = `${outPath}/${util_ts_2.getRandomFilename(prefix, ext)}`;
            const file = await Deno.open(filename, { write: true, createNew: true });
            return [filename, file];
        }
        while (true) {
            const headers = await headers_ts_2.readHeaders(body);
            const contentType = headers["content-type"];
            const contentDisposition = headers["content-disposition"];
            if (!contentDisposition) {
                throw new httpError_ts_3.httpErrors.BadRequest("Form data part missing content-disposition header");
            }
            if (!contentDisposition.match(/^form-data;/i)) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
            }
            const matches = NAME_PARAM_REGEX.exec(contentDisposition);
            if (!matches) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unable to determine name of form body part`);
            }
            let [, name] = matches;
            name = headers_ts_2.unquote(name);
            if (contentType) {
                const originalName = content_disposition_ts_1.getFilename(contentDisposition);
                let byteLength = 0;
                let file;
                let filename;
                let buf;
                if (maxSize) {
                    buf = new Uint8Array();
                }
                else {
                    const result = await getFile(contentType);
                    filename = result[0];
                    file = result[1];
                }
                while (true) {
                    const readResult = await body.readLine(false);
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    let { bytes } = readResult;
                    const strippedBytes = util_ts_2.stripEol(bytes);
                    if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                        if (file) {
                            file.close();
                        }
                        yield [
                            name,
                            {
                                content: buf,
                                contentType,
                                name,
                                filename,
                                originalName,
                            },
                        ];
                        if (isEqual(strippedBytes, final)) {
                            return;
                        }
                        break;
                    }
                    byteLength += bytes.byteLength;
                    if (byteLength > maxFileSize) {
                        if (file) {
                            file.close();
                        }
                        throw new httpError_ts_3.httpErrors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                    }
                    if (buf) {
                        if (byteLength > maxSize) {
                            const result = await getFile(contentType);
                            filename = result[0];
                            file = result[1];
                            await Deno.writeAll(file, buf);
                            buf = undefined;
                        }
                        else {
                            buf = append(buf, bytes);
                        }
                    }
                    if (file) {
                        await Deno.writeAll(file, bytes);
                    }
                }
            }
            else {
                const lines = [];
                while (true) {
                    const readResult = await body.readLine();
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    const { bytes } = readResult;
                    if (isEqual(bytes, part) || isEqual(bytes, final)) {
                        yield [name, lines.join("\n")];
                        if (isEqual(bytes, final)) {
                            return;
                        }
                        break;
                    }
                    lines.push(decoder.decode(bytes));
                }
            }
        }
    }
    return {
        setters: [
            function (buf_reader_ts_1_1) {
                buf_reader_ts_1 = buf_reader_ts_1_1;
            },
            function (content_disposition_ts_1_1) {
                content_disposition_ts_1 = content_disposition_ts_1_1;
            },
            function (deps_ts_8_1) {
                deps_ts_8 = deps_ts_8_1;
            },
            function (headers_ts_2_1) {
                headers_ts_2 = headers_ts_2_1;
            },
            function (httpError_ts_3_1) {
                httpError_ts_3 = httpError_ts_3_1;
            },
            function (util_ts_2_1) {
                util_ts_2 = util_ts_2_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
            BOUNDARY_PARAM_REGEX = headers_ts_2.toParamRegExp("boundary", "i");
            DEFAULT_BUFFER_SIZE = 1048576;
            DEFAULT_MAX_FILE_SIZE = 10485760;
            DEFAULT_MAX_SIZE = 0;
            NAME_PARAM_REGEX = headers_ts_2.toParamRegExp("name", "i");
            FormDataReader = class FormDataReader {
                constructor(contentType, body) {
                    this.#reading = false;
                    const matches = contentType.match(BOUNDARY_PARAM_REGEX);
                    if (!matches) {
                        throw new httpError_ts_3.httpErrors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
                    }
                    let [, boundary] = matches;
                    boundary = headers_ts_2.unquote(boundary);
                    this.#boundaryPart = encoder.encode(`--${boundary}`);
                    this.#boundaryFinal = encoder.encode(`--${boundary}--`);
                    this.#body = body;
                }
                #body;
                #boundaryFinal;
                #boundaryPart;
                #reading;
                async read(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    const result = { fields: {} };
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return result;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            const [key, value] = part;
                            if (typeof value === "string") {
                                result.fields[key] = value;
                            }
                            else {
                                if (!result.files) {
                                    result.files = [];
                                }
                                result.files.push(value);
                            }
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                    return result;
                }
                async *stream(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            yield part;
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            };
            exports_45("FormDataReader", FormDataReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/body", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/isMediaType", "https://deno.land/x/oak@v6.3.1/multipart"], function (exports_46, context_46) {
    "use strict";
    var deps_ts_9, httpError_ts_4, isMediaType_ts_1, multipart_ts_1, defaultBodyContentTypes, decoder, RequestBody;
    var __moduleName = context_46 && context_46.id;
    return {
        setters: [
            function (deps_ts_9_1) {
                deps_ts_9 = deps_ts_9_1;
            },
            function (httpError_ts_4_1) {
                httpError_ts_4 = httpError_ts_4_1;
            },
            function (isMediaType_ts_1_1) {
                isMediaType_ts_1 = isMediaType_ts_1_1;
            },
            function (multipart_ts_1_1) {
                multipart_ts_1 = multipart_ts_1_1;
            }
        ],
        execute: function () {
            defaultBodyContentTypes = {
                json: ["json", "application/*+json", "application/csp-report"],
                form: ["urlencoded"],
                formData: ["multipart"],
                text: ["text"],
            };
            decoder = new TextDecoder();
            RequestBody = class RequestBody {
                constructor(request) {
                    this.#valuePromise = () => {
                        return this.#readAllBody ?? (this.#readAllBody = Deno.readAll(this.#body));
                    };
                    const { body, headers } = request;
                    this.#body = body;
                    this.#headers = headers;
                }
                #body;
                #formDataReader;
                #has;
                #headers;
                #readAllBody;
                #type;
                #valuePromise;
                get({ type, contentTypes }) {
                    if (type === "reader" && this.#type && this.#type !== "reader") {
                        throw new TypeError("Body already consumed and cannot be returned as a reader.");
                    }
                    if (type === "form-data" && this.#type && this.#type !== "form-data") {
                        throw new TypeError("Body already consumed and cannot be returned as form data.");
                    }
                    if (this.#type === "reader" && type !== "reader") {
                        throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
                    }
                    if (this.#type === "form-data" && type !== "form-data") {
                        throw new TypeError("Body already consumed as form data and can only be returned as form data.");
                    }
                    if (type && contentTypes) {
                        throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
                    }
                    if (type === "reader") {
                        this.#type = "reader";
                        return { type, value: this.#body };
                    }
                    if (!this.has()) {
                        this.#type = "undefined";
                    }
                    else if (!this.#type) {
                        const encoding = this.#headers.get("content-encoding") ?? "identity";
                        if (encoding !== "identity") {
                            throw new httpError_ts_4.httpErrors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
                        }
                    }
                    if (this.#type === "undefined") {
                        if (type) {
                            throw new TypeError(`Body is undefined and cannot be returned as "${type}".`);
                        }
                        return { type: "undefined", value: undefined };
                    }
                    if (!type) {
                        const contentType = this.#headers.get("content-type");
                        deps_ts_9.assert(contentType);
                        contentTypes = contentTypes ?? {};
                        const contentTypesJson = [
                            ...defaultBodyContentTypes.json,
                            ...(contentTypes.json ?? []),
                        ];
                        const contentTypesForm = [
                            ...defaultBodyContentTypes.form,
                            ...(contentTypes.form ?? []),
                        ];
                        const contentTypesFormData = [
                            ...defaultBodyContentTypes.formData,
                            ...(contentTypes.formData ?? []),
                        ];
                        const contentTypesText = [
                            ...defaultBodyContentTypes.text,
                            ...(contentTypes.text ?? []),
                        ];
                        if (contentTypes.raw && isMediaType_ts_1.isMediaType(contentType, contentTypes.raw)) {
                            type = "raw";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesJson)) {
                            type = "json";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesForm)) {
                            type = "form";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesFormData)) {
                            type = "form-data";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesText)) {
                            type = "text";
                        }
                        else {
                            type = "raw";
                        }
                    }
                    deps_ts_9.assert(type);
                    let value;
                    switch (type) {
                        case "form":
                            this.#type = "raw";
                            value = async () => new URLSearchParams(decoder.decode(await this.#valuePromise()).replace(/\+/g, " "));
                            break;
                        case "form-data":
                            this.#type = "form-data";
                            value = () => {
                                const contentType = this.#headers.get("content-type");
                                deps_ts_9.assert(contentType);
                                return this.#formDataReader ??
                                    (this.#formDataReader = new multipart_ts_1.FormDataReader(contentType, this.#body));
                            };
                            break;
                        case "json":
                            this.#type = "raw";
                            value = async () => JSON.parse(decoder.decode(await this.#valuePromise()));
                            break;
                        case "raw":
                            this.#type = "raw";
                            value = () => this.#valuePromise();
                            break;
                        case "text":
                            this.#type = "raw";
                            value = async () => decoder.decode(await this.#valuePromise());
                            break;
                        default:
                            throw new TypeError(`Invalid body type: "${type}"`);
                    }
                    return {
                        type,
                        get value() {
                            return value();
                        },
                    };
                }
                has() {
                    return this.#has !== undefined
                        ? this.#has
                        : (this.#has = this.#headers.get("transfer-encoding") !== null ||
                            !!parseInt(this.#headers.get("content-length") ?? "", 10));
                }
            };
            exports_46("RequestBody", RequestBody);
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/common", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    function compareSpecs(a, b) {
        return (b.q - a.q ||
            (b.s ?? 0) - (a.s ?? 0) ||
            (a.o ?? 0) - (b.o ?? 0) ||
            a.i - b.i ||
            0);
    }
    exports_47("compareSpecs", compareSpecs);
    function isQuality(spec) {
        return spec.q > 0;
    }
    exports_47("isQuality", isQuality);
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/charset", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_48, context_48) {
    "use strict";
    var common_ts_2, SIMPLE_CHARSET_REGEXP;
    var __moduleName = context_48 && context_48.id;
    function parseCharset(str, i) {
        const match = SIMPLE_CHARSET_REGEXP.exec(str);
        if (!match) {
            return;
        }
        const [, charset] = match;
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { charset, q, i };
    }
    function parseAcceptCharset(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                result.push(charset);
            }
        }
        return result;
    }
    function specify(charset, spec, i) {
        let s = 0;
        if (spec.charset.toLowerCase() === charset.toLocaleLowerCase()) {
            s |= 1;
        }
        else if (spec.charset !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getCharsetPriority(charset, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(charset, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredCharsets(accept = "*", provided) {
        const accepts = parseAcceptCharset(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_2.isQuality)
                .sort(common_ts_2.compareSpecs)
                .map((spec) => spec.charset);
        }
        const priorities = provided
            .map((type, index) => getCharsetPriority(type, accepts, index));
        return priorities
            .filter(common_ts_2.isQuality)
            .sort(common_ts_2.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_48("preferredCharsets", preferredCharsets);
    return {
        setters: [
            function (common_ts_2_1) {
                common_ts_2 = common_ts_2_1;
            }
        ],
        execute: function () {
            SIMPLE_CHARSET_REGEXP = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/encoding", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_49, context_49) {
    "use strict";
    var common_ts_3, simpleEncodingRegExp;
    var __moduleName = context_49 && context_49.id;
    function parseEncoding(str, i) {
        const match = simpleEncodingRegExp.exec(str);
        if (!match) {
            return undefined;
        }
        const encoding = match[1];
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const p = param.trim().split("=");
                if (p[0] === "q") {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return { encoding, q, i };
    }
    function specify(encoding, spec, i = -1) {
        if (!spec.encoding) {
            return;
        }
        let s = 0;
        if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
            s = 1;
        }
        else if (spec.encoding !== "*") {
            return;
        }
        return {
            i,
            o: spec.i,
            q: spec.q,
            s,
        };
    }
    function parseAcceptEncoding(accept) {
        const accepts = accept.split(",");
        const parsedAccepts = [];
        let hasIdentity = false;
        let minQuality = 1;
        for (let i = 0; i < accepts.length; i++) {
            const encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                parsedAccepts.push(encoding);
                hasIdentity = hasIdentity || !!specify("identity", encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            parsedAccepts.push({
                encoding: "identity",
                q: minQuality,
                i: accepts.length - 1,
            });
        }
        return parsedAccepts;
    }
    function getEncodingPriority(encoding, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: 0 };
        for (const s of accepted) {
            const spec = specify(encoding, s, index);
            if (spec &&
                (priority.s - spec.s || priority.q - spec.q ||
                    priority.o - spec.o) <
                    0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredEncodings(accept, provided) {
        const accepts = parseAcceptEncoding(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_3.isQuality)
                .sort(common_ts_3.compareSpecs)
                .map((spec) => spec.encoding);
        }
        const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
        return priorities
            .filter(common_ts_3.isQuality)
            .sort(common_ts_3.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_49("preferredEncodings", preferredEncodings);
    return {
        setters: [
            function (common_ts_3_1) {
                common_ts_3 = common_ts_3_1;
            }
        ],
        execute: function () {
            simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/language", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_50, context_50) {
    "use strict";
    var common_ts_4, SIMPLE_LANGUAGE_REGEXP;
    var __moduleName = context_50 && context_50.id;
    function parseLanguage(str, i) {
        const match = SIMPLE_LANGUAGE_REGEXP.exec(str);
        if (!match) {
            return undefined;
        }
        const [, prefix, suffix] = match;
        const full = suffix ? `${prefix}-${suffix}` : prefix;
        let q = 1;
        if (match[3]) {
            const params = match[3].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { prefix, suffix, full, q, i };
    }
    function parseAcceptLanguage(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                result.push(language);
            }
        }
        return result;
    }
    function specify(language, spec, i) {
        const p = parseLanguage(language, i);
        if (!p) {
            return undefined;
        }
        let s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        }
        else if (spec.prefix.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 2;
        }
        else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        }
        else if (spec.full !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getLanguagePriority(language, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(language, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredLanguages(accept = "*", provided) {
        const accepts = parseAcceptLanguage(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_4.isQuality)
                .sort(common_ts_4.compareSpecs)
                .map((spec) => spec.full);
        }
        const priorities = provided
            .map((type, index) => getLanguagePriority(type, accepts, index));
        return priorities
            .filter(common_ts_4.isQuality)
            .sort(common_ts_4.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_50("preferredLanguages", preferredLanguages);
    return {
        setters: [
            function (common_ts_4_1) {
                common_ts_4 = common_ts_4_1;
            }
        ],
        execute: function () {
            SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/mediaType", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_51, context_51) {
    "use strict";
    var common_ts_5, simpleMediaTypeRegExp;
    var __moduleName = context_51 && context_51.id;
    function quoteCount(str) {
        let count = 0;
        let index = 0;
        while ((index = str.indexOf(`"`, index)) !== -1) {
            count++;
            index++;
        }
        return count;
    }
    function splitMediaTypes(accept) {
        const accepts = accept.split(",");
        let j = 0;
        for (let i = 1; i < accepts.length; i++) {
            if (quoteCount(accepts[j]) % 2 === 0) {
                accepts[++j] = accepts[i];
            }
            else {
                accepts[j] += `,${accepts[i]}`;
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        const parameters = str.split(";");
        let j = 0;
        for (let i = 1; i < parameters.length; i++) {
            if (quoteCount(parameters[j]) % 2 === 0) {
                parameters[++j] = parameters[i];
            }
            else {
                parameters[j] += `;${parameters[i]}`;
            }
        }
        parameters.length = j + 1;
        return parameters.map((p) => p.trim());
    }
    function splitKeyValuePair(str) {
        const [key, value] = str.split("=");
        return [key.toLowerCase(), value];
    }
    function parseMediaType(str, i) {
        const match = simpleMediaTypeRegExp.exec(str);
        if (!match) {
            return;
        }
        const params = Object.create(null);
        let q = 1;
        const [, type, subtype, parameters] = match;
        if (parameters) {
            const kvps = splitParameters(parameters).map(splitKeyValuePair);
            for (const [key, val] of kvps) {
                const value = val && val[0] === `"` && val[val.length - 1] === `"`
                    ? val.substr(1, val.length - 2)
                    : val;
                if (key === "q" && value) {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return { type, subtype, params, q, i };
    }
    function parseAccept(accept) {
        const accepts = splitMediaTypes(accept);
        const mediaTypes = [];
        for (let i = 0; i < accepts.length; i++) {
            const mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                mediaTypes.push(mediaType);
            }
        }
        return mediaTypes;
    }
    function getFullType(spec) {
        return `${spec.type}/${spec.subtype}`;
    }
    function specify(type, spec, index) {
        const p = parseMediaType(type, index);
        if (!p) {
            return;
        }
        let s = 0;
        if (spec.type.toLowerCase() === p.type.toLowerCase()) {
            s |= 4;
        }
        else if (spec.type !== "*") {
            return;
        }
        if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
            s |= 2;
        }
        else if (spec.subtype !== "*") {
            return;
        }
        const keys = Object.keys(spec.params);
        if (keys.length) {
            if (keys.every((key) => (spec.params[key] || "").toLowerCase() ===
                (p.params[key] || "").toLowerCase())) {
                s |= 1;
            }
            else {
                return;
            }
        }
        return {
            i: index,
            o: spec.o,
            q: spec.q,
            s,
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: index };
        for (const accepts of accepted) {
            const spec = specify(type, accepts, index);
            if (spec &&
                ((priority.s || 0) - (spec.s || 0) ||
                    (priority.q || 0) - (spec.q || 0) ||
                    (priority.o || 0) - (spec.o || 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredMediaTypes(accept, provided) {
        const accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
            return accepts
                .filter(common_ts_5.isQuality)
                .sort(common_ts_5.compareSpecs)
                .map(getFullType);
        }
        const priorities = provided.map((type, index) => {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities
            .filter(common_ts_5.isQuality)
            .sort(common_ts_5.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_51("preferredMediaTypes", preferredMediaTypes);
    return {
        setters: [
            function (common_ts_5_1) {
                common_ts_5 = common_ts_5_1;
            }
        ],
        execute: function () {
            simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/request", ["https://deno.land/x/oak@v6.3.1/body", "https://deno.land/x/oak@v6.3.1/negotiation/charset", "https://deno.land/x/oak@v6.3.1/negotiation/encoding", "https://deno.land/x/oak@v6.3.1/negotiation/language", "https://deno.land/x/oak@v6.3.1/negotiation/mediaType"], function (exports_52, context_52) {
    "use strict";
    var body_ts_1, charset_ts_1, encoding_ts_1, language_ts_1, mediaType_ts_1, decoder, Request;
    var __moduleName = context_52 && context_52.id;
    return {
        setters: [
            function (body_ts_1_1) {
                body_ts_1 = body_ts_1_1;
            },
            function (charset_ts_1_1) {
                charset_ts_1 = charset_ts_1_1;
            },
            function (encoding_ts_1_1) {
                encoding_ts_1 = encoding_ts_1_1;
            },
            function (language_ts_1_1) {
                language_ts_1 = language_ts_1_1;
            },
            function (mediaType_ts_1_1) {
                mediaType_ts_1 = mediaType_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            Request = class Request {
                constructor(serverRequest, proxy = false, secure = false) {
                    this.#proxy = proxy;
                    this.#secure = secure;
                    this.#serverRequest = serverRequest;
                    this.#body = new body_ts_1.RequestBody(serverRequest);
                }
                #body;
                #proxy;
                #secure;
                #serverRequest;
                #url;
                get hasBody() {
                    return this.#body.has();
                }
                get headers() {
                    return this.#serverRequest.headers;
                }
                get ip() {
                    return this.#proxy
                        ? this.ips[0]
                        : this.#serverRequest.conn.remoteAddr.hostname;
                }
                get ips() {
                    return this.#proxy
                        ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                            this.#serverRequest.conn.remoteAddr.hostname).split(/\s*,\s*/)
                        : [];
                }
                get method() {
                    return this.#serverRequest.method;
                }
                get secure() {
                    return this.#secure;
                }
                get serverRequest() {
                    return this.#serverRequest;
                }
                get url() {
                    if (!this.#url) {
                        const serverRequest = this.#serverRequest;
                        let proto;
                        let host;
                        if (this.#proxy) {
                            proto = serverRequest
                                .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                                "http";
                            host = serverRequest.headers.get("x-forwarded-host") ??
                                serverRequest.headers.get("host") ?? "";
                        }
                        else {
                            proto = this.#secure ? "https" : "http";
                            host = serverRequest.headers.get("host") ?? "";
                        }
                        this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
                    }
                    return this.#url;
                }
                accepts(...types) {
                    const acceptValue = this.#serverRequest.headers.get("Accept");
                    if (!acceptValue) {
                        return;
                    }
                    if (types.length) {
                        return mediaType_ts_1.preferredMediaTypes(acceptValue, types)[0];
                    }
                    return mediaType_ts_1.preferredMediaTypes(acceptValue);
                }
                acceptsCharsets(...charsets) {
                    const acceptCharsetValue = this.#serverRequest.headers.get("Accept-Charset");
                    if (!acceptCharsetValue) {
                        return;
                    }
                    if (charsets.length) {
                        return charset_ts_1.preferredCharsets(acceptCharsetValue, charsets)[0];
                    }
                    return charset_ts_1.preferredCharsets(acceptCharsetValue);
                }
                acceptsEncodings(...encodings) {
                    const acceptEncodingValue = this.#serverRequest.headers.get("Accept-Encoding");
                    if (!acceptEncodingValue) {
                        return;
                    }
                    if (encodings.length) {
                        return encoding_ts_1.preferredEncodings(acceptEncodingValue, encodings)[0];
                    }
                    return encoding_ts_1.preferredEncodings(acceptEncodingValue);
                }
                acceptsLanguages(...langs) {
                    const acceptLanguageValue = this.#serverRequest.headers.get("Accept-Language");
                    if (!acceptLanguageValue) {
                        return;
                    }
                    if (langs.length) {
                        return language_ts_1.preferredLanguages(acceptLanguageValue, langs)[0];
                    }
                    return language_ts_1.preferredLanguages(acceptLanguageValue);
                }
                body(options = {}) {
                    return this.#body.get(options);
                }
            };
            exports_52("Request", Request);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/response", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_53, context_53) {
    "use strict";
    var deps_ts_10, util_ts_3, REDIRECT_BACK, BODY_TYPES, encoder, Response;
    var __moduleName = context_53 && context_53.id;
    function isReader(value) {
        return value && typeof value === "object" && "read" in value &&
            typeof value.read === "function";
    }
    async function convertBody(body, type) {
        let result;
        if (BODY_TYPES.includes(typeof body)) {
            const bodyText = String(body);
            result = encoder.encode(bodyText);
            type = type ?? (util_ts_3.isHtml(bodyText) ? "html" : "text/plain");
        }
        else if (body instanceof Uint8Array || isReader(body)) {
            result = body;
        }
        else if (body && typeof body === "object") {
            result = encoder.encode(JSON.stringify(body));
            type = type ?? "json";
        }
        else if (typeof body === "function") {
            const result = body.call(null);
            return convertBody(await result, type);
        }
        else if (body) {
            throw new TypeError("Response body was set but could not convert.");
        }
        return [result, type];
    }
    return {
        setters: [
            function (deps_ts_10_1) {
                deps_ts_10 = deps_ts_10_1;
            },
            function (util_ts_3_1) {
                util_ts_3 = util_ts_3_1;
            }
        ],
        execute: function () {
            exports_53("REDIRECT_BACK", REDIRECT_BACK = Symbol("redirect backwards"));
            BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
            encoder = new TextEncoder();
            Response = class Response {
                constructor(request) {
                    this.#headers = new Headers();
                    this.#resources = [];
                    this.#writable = true;
                    this.#getBody = async () => {
                        const [body, type] = await convertBody(this.body, this.type);
                        this.type = type;
                        return body;
                    };
                    this.#setContentType = () => {
                        if (this.type) {
                            const contentTypeString = deps_ts_10.contentType(this.type);
                            if (contentTypeString && !this.headers.has("Content-Type")) {
                                this.headers.append("Content-Type", contentTypeString);
                            }
                        }
                    };
                    this.#request = request;
                }
                #body;
                #headers;
                #request;
                #resources;
                #serverResponse;
                #status;
                #type;
                #writable;
                #getBody;
                #setContentType;
                get body() {
                    return this.#body;
                }
                set body(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#body = value;
                }
                get headers() {
                    return this.#headers;
                }
                set headers(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#headers = value;
                }
                get status() {
                    if (this.#status) {
                        return this.#status;
                    }
                    const typeofbody = typeof this.body;
                    return this.body &&
                        (BODY_TYPES.includes(typeofbody) || typeofbody === "object")
                        ? deps_ts_10.Status.OK
                        : deps_ts_10.Status.NotFound;
                }
                set status(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#status = value;
                }
                get type() {
                    return this.#type;
                }
                set type(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#type = value;
                }
                get writable() {
                    return this.#writable;
                }
                addResource(rid) {
                    this.#resources.push(rid);
                }
                destroy() {
                    this.#writable = false;
                    this.#body = undefined;
                    this.#serverResponse = undefined;
                    for (const rid of this.#resources) {
                        Deno.close(rid);
                    }
                }
                redirect(url, alt = "/") {
                    if (url === REDIRECT_BACK) {
                        url = this.#request.headers.get("Referrer") ?? String(alt);
                    }
                    else if (typeof url === "object") {
                        url = String(url);
                    }
                    this.headers.set("Location", util_ts_3.encodeUrl(url));
                    if (!this.status || !util_ts_3.isRedirectStatus(this.status)) {
                        this.status = deps_ts_10.Status.Found;
                    }
                    if (this.#request.accepts("html")) {
                        url = encodeURI(url);
                        this.type = "text/html; charset=utf-8";
                        this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                        return;
                    }
                    this.type = "text/plain; charset=utf-8";
                    this.body = `Redirecting to ${url}.`;
                }
                async toServerResponse() {
                    if (this.#serverResponse) {
                        return this.#serverResponse;
                    }
                    const body = await this.#getBody();
                    this.#setContentType();
                    const { headers } = this;
                    if (!(body ||
                        headers.has("Content-Type") ||
                        headers.has("Content-Length"))) {
                        headers.append("Content-Length", "0");
                    }
                    this.#writable = false;
                    return this.#serverResponse = {
                        status: this.#status ?? (body ? deps_ts_10.Status.OK : deps_ts_10.Status.NotFound),
                        body,
                        headers,
                    };
                }
            };
            exports_53("Response", Response);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/cookies", [], function (exports_54, context_54) {
    "use strict";
    var matchCache, FIELD_CONTENT_REGEXP, KEY_REGEXP, SAME_SITE_REGEXP, Cookie, Cookies;
    var __moduleName = context_54 && context_54.id;
    function getPattern(name) {
        if (name in matchCache) {
            return matchCache[name];
        }
        return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for (let i = headers.length - 1; i >= 0; i--) {
                if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    function validateCookieProperty(key, value) {
        if (value && !FIELD_CONTENT_REGEXP.test(value)) {
            throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
        }
    }
    return {
        setters: [],
        execute: function () {
            matchCache = {};
            FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
            KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
            SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
            Cookie = class Cookie {
                constructor(name, value, attributes) {
                    this.httpOnly = true;
                    this.overwrite = false;
                    this.path = "/";
                    this.sameSite = false;
                    this.secure = false;
                    validateCookieProperty("name", name);
                    validateCookieProperty("value", value);
                    this.name = name;
                    this.value = value ?? "";
                    Object.assign(this, attributes);
                    if (!this.value) {
                        this.expires = new Date(0);
                        this.maxAge = undefined;
                    }
                    validateCookieProperty("path", this.path);
                    validateCookieProperty("domain", this.domain);
                    if (this.sameSite && typeof this.sameSite === "string" &&
                        !SAME_SITE_REGEXP.test(this.sameSite)) {
                        throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
                    }
                }
                toHeader() {
                    let header = this.toString();
                    if (this.maxAge) {
                        this.expires = new Date(Date.now() + (this.maxAge * 1000));
                    }
                    if (this.path) {
                        header += `; path=${this.path}`;
                    }
                    if (this.expires) {
                        header += `; expires=${this.expires.toUTCString()}`;
                    }
                    if (this.domain) {
                        header += `; domain=${this.domain}`;
                    }
                    if (this.sameSite) {
                        header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
                    }
                    if (this.secure) {
                        header += "; secure";
                    }
                    if (this.httpOnly) {
                        header += "; httponly";
                    }
                    return header;
                }
                toString() {
                    return `${this.name}=${this.value}`;
                }
            };
            Cookies = class Cookies {
                constructor(request, response, options = {}) {
                    this.#requestKeys = () => {
                        if (this.#cookieKeys) {
                            return this.#cookieKeys;
                        }
                        const result = this.#cookieKeys = [];
                        const header = this.#request.headers.get("cookie");
                        if (!header) {
                            return result;
                        }
                        let matches;
                        while ((matches = KEY_REGEXP.exec(header))) {
                            const [, key] = matches;
                            result.push(key);
                        }
                        return result;
                    };
                    const { keys, secure } = options;
                    this.#keys = keys;
                    this.#request = request;
                    this.#response = response;
                    this.#secure = secure;
                }
                #cookieKeys;
                #keys;
                #request;
                #response;
                #secure;
                #requestKeys;
                delete(name, options = {}) {
                    this.set(name, null, options);
                    return true;
                }
                *entries() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
                forEach(callback, thisArg = null) {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            callback.call(thisArg, key, value, this);
                        }
                    }
                }
                get(name, options = {}) {
                    const signed = options.signed ?? !!this.#keys;
                    const nameSig = `${name}.sig`;
                    const header = this.#request.headers.get("cookie");
                    if (!header) {
                        return;
                    }
                    const match = header.match(getPattern(name));
                    if (!match) {
                        return;
                    }
                    const [, value] = match;
                    if (!signed) {
                        return value;
                    }
                    const digest = this.get(nameSig, { signed: false });
                    if (!digest) {
                        return;
                    }
                    const data = `${name}=${value}`;
                    if (!this.#keys) {
                        throw new TypeError("keys required for signed cookies");
                    }
                    const index = this.#keys.indexOf(data, digest);
                    if (index < 0) {
                        this.delete(nameSig, { path: "/", signed: false });
                    }
                    else {
                        if (index) {
                            this.set(nameSig, this.#keys.sign(data), { signed: false });
                        }
                        return value;
                    }
                }
                *keys() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield key;
                        }
                    }
                }
                set(name, value, options = {}) {
                    const request = this.#request;
                    const response = this.#response;
                    let headers = response.headers.get("Set-Cookie") ?? [];
                    if (typeof headers === "string") {
                        headers = [headers];
                    }
                    const secure = this.#secure !== undefined ? this.#secure : request.secure;
                    const signed = options.signed ?? !!this.#keys;
                    if (!secure && options.secure) {
                        throw new TypeError("Cannot send secure cookie over unencrypted connection.");
                    }
                    const cookie = new Cookie(name, value, options);
                    cookie.secure = options.secure ?? secure;
                    pushCookie(headers, cookie);
                    if (signed) {
                        if (!this.#keys) {
                            throw new TypeError(".keys required for signed cookies.");
                        }
                        cookie.value = this.#keys.sign(cookie.toString());
                        cookie.name += ".sig";
                        pushCookie(headers, cookie);
                    }
                    for (const header of headers) {
                        response.headers.append("Set-Cookie", header);
                    }
                    return this;
                }
                *values() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield value;
                        }
                    }
                }
                *[Symbol.iterator]() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
            };
            exports_54("Cookies", Cookies);
        }
    };
});
/*!
 * Adapted from koa-send at https://github.com/koajs/send and which is licensed
 * with the MIT license.
 */
System.register("https://deno.land/x/oak@v6.3.1/send", ["https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_55, context_55) {
    "use strict";
    var httpError_ts_5, deps_ts_11, util_ts_4;
    var __moduleName = context_55 && context_55.id;
    function isHidden(path) {
        const pathArr = path.split("/");
        for (const segment of pathArr) {
            if (segment[0] === "." && segment !== "." && segment !== "..") {
                return true;
            }
            return false;
        }
    }
    async function exists(path) {
        try {
            return (await Deno.stat(path)).isFile;
        }
        catch {
            return false;
        }
    }
    async function send({ request, response }, path, options = { root: "" }) {
        const { brotli = true, extensions, format = true, gzip = true, hidden = false, immutable = false, index, maxage = 0, root, } = options;
        const trailingSlash = path[path.length - 1] === "/";
        path = util_ts_4.decodeComponent(path.substr(deps_ts_11.parse(path).root.length));
        if (index && trailingSlash) {
            path += index;
        }
        if (!hidden && isHidden(path)) {
            throw httpError_ts_5.createHttpError(403);
        }
        path = util_ts_4.resolvePath(root, path);
        let encodingExt = "";
        if (brotli &&
            request.acceptsEncodings("br", "identity") === "br" &&
            (await exists(`${path}.br`))) {
            path = `${path}.br`;
            response.headers.set("Content-Encoding", "br");
            response.headers.delete("Content-Length");
            encodingExt = ".br";
        }
        else if (gzip &&
            request.acceptsEncodings("gzip", "identity") === "gzip" &&
            (await exists(`${path}.gz`))) {
            path = `${path}.gz`;
            response.headers.set("Content-Encoding", "gzip");
            response.headers.delete("Content-Length");
            encodingExt = ".gz";
        }
        if (extensions && !/\.[^/]*$/.exec(path)) {
            for (let ext of extensions) {
                if (!/^\./.exec(ext)) {
                    ext = `.${ext}`;
                }
                if (await exists(`${path}${ext}`)) {
                    path += ext;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await Deno.stat(path);
            if (stats.isDirectory) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await Deno.stat(path);
                }
                else {
                    return;
                }
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                throw httpError_ts_5.createHttpError(404, err.message);
            }
            throw httpError_ts_5.createHttpError(500, err.message);
        }
        response.headers.set("Content-Length", String(stats.size));
        if (!response.headers.has("Last-Modified") && stats.mtime) {
            response.headers.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!response.headers.has("Cache-Control")) {
            const directives = [`max-age=${(maxage / 1000) | 0}`];
            if (immutable) {
                directives.push("immutable");
            }
            response.headers.set("Cache-Control", directives.join(","));
        }
        if (!response.type) {
            response.type = encodingExt !== ""
                ? deps_ts_11.extname(deps_ts_11.basename(path, encodingExt))
                : deps_ts_11.extname(path);
        }
        const file = await Deno.open(path, { read: true });
        response.addResource(file.rid);
        response.body = file;
        return path;
    }
    exports_55("send", send);
    return {
        setters: [
            function (httpError_ts_5_1) {
                httpError_ts_5 = httpError_ts_5_1;
            },
            function (deps_ts_11_1) {
                deps_ts_11 = deps_ts_11_1;
            },
            function (util_ts_4_1) {
                util_ts_4 = util_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/server_sent_event", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_56, context_56) {
    "use strict";
    var deps_ts_12, encoder, CloseEvent, ServerSentEvent, response, responseHeaders, ServerSentEventTarget;
    var __moduleName = context_56 && context_56.id;
    return {
        setters: [
            function (deps_ts_12_1) {
                deps_ts_12 = deps_ts_12_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            CloseEvent = class CloseEvent extends Event {
                constructor(eventInit) {
                    super("close", eventInit);
                }
            };
            ServerSentEvent = class ServerSentEvent extends Event {
                constructor(type, data, { replacer, space, ...eventInit } = {}) {
                    super(type, eventInit);
                    this.#type = type;
                    try {
                        this.#data = typeof data === "string"
                            ? data
                            : JSON.stringify(data, replacer, space);
                    }
                    catch (e) {
                        deps_ts_12.assert(e instanceof Error);
                        throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
                    }
                    const { id } = eventInit;
                    this.#id = id;
                }
                #data;
                #id;
                #type;
                get data() {
                    return this.#data;
                }
                get id() {
                    return this.#id;
                }
                toString() {
                    const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
                    return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
                }
            };
            exports_56("ServerSentEvent", ServerSentEvent);
            response = `HTTP/1.1 200 OK\n`;
            responseHeaders = new Headers([
                ["Connection", "Keep-Alive"],
                ["Content-Type", "text/event-stream"],
                ["Cache-Control", "no-cache"],
                ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
            ]);
            ServerSentEventTarget = class ServerSentEventTarget extends EventTarget {
                constructor(app, serverRequest, { headers } = {}) {
                    super();
                    this.#closed = false;
                    this.#prev = Promise.resolve();
                    this.#send = async (payload, prev) => {
                        if (this.#closed) {
                            return;
                        }
                        if (this.#ready !== true) {
                            await this.#ready;
                            this.#ready = true;
                        }
                        try {
                            await prev;
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                        }
                    };
                    this.#setup = async (overrideHeaders) => {
                        const headers = new Headers(responseHeaders);
                        if (overrideHeaders) {
                            for (const [key, value] of overrideHeaders) {
                                headers.set(key, value);
                            }
                        }
                        let payload = response;
                        for (const [key, value] of headers) {
                            payload += `${key}: ${value}\n`;
                        }
                        payload += `\n`;
                        try {
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                            throw error;
                        }
                    };
                    this.#app = app;
                    this.#serverRequest = serverRequest;
                    this.#writer = this.#serverRequest.w;
                    this.addEventListener("close", () => {
                        this.#closed = true;
                        try {
                            this.#serverRequest.conn.close();
                        }
                        catch (error) {
                            if (!(error instanceof Deno.errors.BadResource)) {
                                const errorEvent = new ErrorEvent("error", { error });
                                this.dispatchEvent(errorEvent);
                                this.#app.dispatchEvent(errorEvent);
                            }
                        }
                    });
                    this.#ready = this.#setup(headers);
                }
                #app;
                #closed;
                #prev;
                #ready;
                #serverRequest;
                #writer;
                #send;
                #setup;
                get closed() {
                    return this.#closed;
                }
                async close() {
                    if (this.#ready !== true) {
                        await this.#ready;
                    }
                    await this.#prev;
                    this.dispatchEvent(new CloseEvent({ cancelable: false }));
                }
                dispatchComment(comment) {
                    this.#prev = this.#send(`: ${comment.split("\n").join("\n: ")}\n\n`, this.#prev);
                    return true;
                }
                dispatchMessage(data) {
                    const event = new ServerSentEvent("__message", data);
                    return this.dispatchEvent(event);
                }
                dispatchEvent(event) {
                    let dispatched = super.dispatchEvent(event);
                    if (dispatched && event instanceof ServerSentEvent) {
                        this.#prev = this.#send(String(event), this.#prev);
                    }
                    return dispatched;
                }
            };
            exports_56("ServerSentEventTarget", ServerSentEventTarget);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/context", ["https://deno.land/x/oak@v6.3.1/cookies", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/request", "https://deno.land/x/oak@v6.3.1/response", "https://deno.land/x/oak@v6.3.1/send", "https://deno.land/x/oak@v6.3.1/server_sent_event"], function (exports_57, context_57) {
    "use strict";
    var cookies_ts_1, deps_ts_13, httpError_ts_6, request_ts_1, response_ts_1, send_ts_1, server_sent_event_ts_1, Context;
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [
            function (cookies_ts_1_1) {
                cookies_ts_1 = cookies_ts_1_1;
            },
            function (deps_ts_13_1) {
                deps_ts_13 = deps_ts_13_1;
            },
            function (httpError_ts_6_1) {
                httpError_ts_6 = httpError_ts_6_1;
            },
            function (request_ts_1_1) {
                request_ts_1 = request_ts_1_1;
            },
            function (response_ts_1_1) {
                response_ts_1 = response_ts_1_1;
            },
            function (send_ts_1_1) {
                send_ts_1 = send_ts_1_1;
            },
            function (server_sent_event_ts_1_1) {
                server_sent_event_ts_1 = server_sent_event_ts_1_1;
            }
        ],
        execute: function () {
            Context = class Context {
                constructor(app, serverRequest, secure = false) {
                    this.app = app;
                    this.state = app.state;
                    this.request = new request_ts_1.Request(serverRequest, app.proxy, secure);
                    this.respond = true;
                    this.response = new response_ts_1.Response(this.request);
                    this.cookies = new cookies_ts_1.Cookies(this.request, this.response, {
                        keys: this.app.keys,
                        secure: this.request.secure,
                    });
                }
                #socket;
                #sse;
                get isUpgradable() {
                    return deps_ts_13.acceptable(this.request);
                }
                get socket() {
                    return this.#socket;
                }
                assert(condition, errorStatus = 500, message, props) {
                    if (condition) {
                        return;
                    }
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                send(options) {
                    const { path = this.request.url.pathname, ...sendOptions } = options;
                    return send_ts_1.send(this, path, sendOptions);
                }
                sendEvents(options) {
                    if (this.#sse) {
                        return this.#sse;
                    }
                    this.respond = false;
                    return this.#sse = new server_sent_event_ts_1.ServerSentEventTarget(this.app, this.request.serverRequest, options);
                }
                throw(errorStatus, message, props) {
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                async upgrade() {
                    if (this.#socket) {
                        return this.#socket;
                    }
                    const { conn, r: bufReader, w: bufWriter, headers } = this.request.serverRequest;
                    this.#socket = await deps_ts_13.acceptWebSocket({ conn, bufReader, bufWriter, headers });
                    this.respond = false;
                    return this.#socket;
                }
            };
            exports_57("Context", Context);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/middleware", [], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    function compose(middleware) {
        return function composedMiddleware(context, next) {
            let index = -1;
            async function dispatch(i) {
                if (i <= index) {
                    throw new Error("next() called multiple times.");
                }
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) {
                    fn = next;
                }
                if (!fn) {
                    return;
                }
                await fn(context, dispatch.bind(null, i + 1));
            }
            return dispatch(0);
        };
    }
    exports_58("compose", compose);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/application", ["https://deno.land/x/oak@v6.3.1/context", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/keyStack", "https://deno.land/x/oak@v6.3.1/middleware"], function (exports_59, context_59) {
    "use strict";
    var context_ts_1, deps_ts_14, keyStack_ts_1, middleware_ts_1, ADDR_REGEXP, ApplicationErrorEvent, ApplicationListenEvent, Application;
    var __moduleName = context_59 && context_59.id;
    function isOptionsTls(options) {
        return options.secure === true;
    }
    return {
        setters: [
            function (context_ts_1_1) {
                context_ts_1 = context_ts_1_1;
            },
            function (deps_ts_14_1) {
                deps_ts_14 = deps_ts_14_1;
            },
            function (keyStack_ts_1_1) {
                keyStack_ts_1 = keyStack_ts_1_1;
            },
            function (middleware_ts_1_1) {
                middleware_ts_1 = middleware_ts_1_1;
            }
        ],
        execute: function () {
            ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
            ApplicationErrorEvent = class ApplicationErrorEvent extends ErrorEvent {
                constructor(eventInitDict) {
                    super("error", eventInitDict);
                    this.context = eventInitDict.context;
                }
            };
            exports_59("ApplicationErrorEvent", ApplicationErrorEvent);
            ApplicationListenEvent = class ApplicationListenEvent extends Event {
                constructor(eventInitDict) {
                    super("listen", eventInitDict);
                    this.hostname = eventInitDict.hostname;
                    this.port = eventInitDict.port;
                    this.secure = eventInitDict.secure;
                }
            };
            exports_59("ApplicationListenEvent", ApplicationListenEvent);
            Application = class Application extends EventTarget {
                constructor(options = {}) {
                    super();
                    this.#middleware = [];
                    this.#getComposed = () => {
                        if (!this.#composedMiddleware) {
                            this.#composedMiddleware = middleware_ts_1.compose(this.#middleware);
                        }
                        return this.#composedMiddleware;
                    };
                    this.#handleError = (context, error) => {
                        if (!(error instanceof Error)) {
                            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
                        }
                        const { message } = error;
                        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
                        if (!context.response.writable) {
                            return;
                        }
                        for (const key of context.response.headers.keys()) {
                            context.response.headers.delete(key);
                        }
                        if (error.headers && error.headers instanceof Headers) {
                            for (const [key, value] of error.headers) {
                                context.response.headers.set(key, value);
                            }
                        }
                        context.response.type = "text";
                        const status = context.response.status =
                            error instanceof Deno.errors.NotFound
                                ? 404
                                : error.status && typeof error.status === "number"
                                    ? error.status
                                    : 500;
                        context.response.body = error.expose
                            ? error.message
                            : deps_ts_14.STATUS_TEXT.get(status);
                    };
                    this.#handleRequest = async (request, secure, state) => {
                        const context = new context_ts_1.Context(this, request, secure);
                        let resolve;
                        const handlingPromise = new Promise((res) => resolve = res);
                        state.handling.add(handlingPromise);
                        if (!state.closing && !state.closed) {
                            try {
                                await this.#getComposed()(context);
                            }
                            catch (err) {
                                this.#handleError(context, err);
                            }
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                            return;
                        }
                        try {
                            await request.respond(await context.response.toServerResponse());
                            if (state.closing) {
                                state.server.close();
                                state.closed = true;
                            }
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        finally {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                        }
                    };
                    this.handle = async (request, secure = false) => {
                        if (!this.#middleware.length) {
                            throw new TypeError("There is no middleware to process requests.");
                        }
                        const context = new context_ts_1.Context(this, request, secure);
                        try {
                            await this.#getComposed()(context);
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            return;
                        }
                        try {
                            const response = await context.response.toServerResponse();
                            context.response.destroy();
                            return response;
                        }
                        catch (err) {
                            this.#handleError(context, err);
                            throw err;
                        }
                    };
                    const { state, keys, proxy, serve = deps_ts_14.serve, serveTls = deps_ts_14.serveTLS, } = options;
                    this.proxy = proxy ?? false;
                    this.keys = keys;
                    this.state = state ?? {};
                    this.#serve = serve;
                    this.#serveTls = serveTls;
                }
                #composedMiddleware;
                #keys;
                #middleware;
                #serve;
                #serveTls;
                get keys() {
                    return this.#keys;
                }
                set keys(keys) {
                    if (!keys) {
                        this.#keys = undefined;
                        return;
                    }
                    else if (Array.isArray(keys)) {
                        this.#keys = new keyStack_ts_1.KeyStack(keys);
                    }
                    else {
                        this.#keys = keys;
                    }
                }
                #getComposed;
                #handleError;
                #handleRequest;
                addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                }
                async listen(options) {
                    if (!this.#middleware.length) {
                        throw new TypeError("There is no middleware to process requests.");
                    }
                    if (typeof options === "string") {
                        const match = ADDR_REGEXP.exec(options);
                        if (!match) {
                            throw TypeError(`Invalid address passed: "${options}"`);
                        }
                        const [, hostname, portStr] = match;
                        options = { hostname, port: parseInt(portStr, 10) };
                    }
                    const server = isOptionsTls(options)
                        ? this.#serveTls(options)
                        : this.#serve(options);
                    const { signal } = options;
                    const state = {
                        closed: false,
                        closing: false,
                        handling: new Set(),
                        server,
                    };
                    if (signal) {
                        signal.addEventListener("abort", () => {
                            if (!state.handling.size) {
                                server.close();
                                state.closed = true;
                            }
                            state.closing = true;
                        });
                    }
                    const { hostname, port, secure = false } = options;
                    this.dispatchEvent(new ApplicationListenEvent({ hostname, port, secure }));
                    try {
                        for await (const request of server) {
                            this.#handleRequest(request, secure, state);
                        }
                        await Promise.all(state.handling);
                    }
                    catch (error) {
                        const message = error instanceof Error
                            ? error.message
                            : "Application Error";
                        this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
                    }
                }
                use(...middleware) {
                    this.#middleware.push(...middleware);
                    this.#composedMiddleware = undefined;
                    return this;
                }
            };
            exports_59("Application", Application);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/router", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/middleware", "https://deno.land/x/oak@v6.3.1/util"], function (exports_60, context_60) {
    "use strict";
    var deps_ts_15, httpError_ts_7, middleware_ts_2, util_ts_5, Layer, Router;
    var __moduleName = context_60 && context_60.id;
    function toUrl(url, params = {}, options) {
        const tokens = deps_ts_15.pathParse(url);
        let replace = {};
        if (tokens.some((token) => typeof token === "object")) {
            replace = params;
        }
        else {
            options = params;
        }
        const toPath = deps_ts_15.compile(url, options);
        let replaced = toPath(replace);
        if (options && options.query) {
            const url = new URL(replaced, "http://oak");
            if (typeof options.query === "string") {
                url.search = options.query;
            }
            else {
                url.search = String(options.query instanceof URLSearchParams
                    ? options.query
                    : new URLSearchParams(options.query));
            }
            return `${url.pathname}${url.search}${url.hash}`;
        }
        return replaced;
    }
    return {
        setters: [
            function (deps_ts_15_1) {
                deps_ts_15 = deps_ts_15_1;
            },
            function (httpError_ts_7_1) {
                httpError_ts_7 = httpError_ts_7_1;
            },
            function (middleware_ts_2_1) {
                middleware_ts_2 = middleware_ts_2_1;
            },
            function (util_ts_5_1) {
                util_ts_5 = util_ts_5_1;
            }
        ],
        execute: function () {
            Layer = class Layer {
                constructor(path, methods, middleware, { name, ...opts } = {}) {
                    this.#paramNames = [];
                    this.#opts = opts;
                    this.name = name;
                    this.methods = [...methods];
                    if (this.methods.includes("GET")) {
                        this.methods.unshift("HEAD");
                    }
                    this.stack = Array.isArray(middleware) ? middleware : [middleware];
                    this.path = path;
                    this.#regexp = deps_ts_15.pathToRegexp(path, this.#paramNames, this.#opts);
                }
                #opts;
                #paramNames;
                #regexp;
                match(path) {
                    return this.#regexp.test(path);
                }
                params(captures, existingParams = {}) {
                    const params = existingParams;
                    for (let i = 0; i < captures.length; i++) {
                        if (this.#paramNames[i]) {
                            const c = captures[i];
                            params[this.#paramNames[i].name] = c ? util_ts_5.decodeComponent(c) : c;
                        }
                    }
                    return params;
                }
                captures(path) {
                    if (this.#opts.ignoreCaptures) {
                        return [];
                    }
                    return path.match(this.#regexp)?.slice(1) ?? [];
                }
                url(params = {}, options) {
                    const url = this.path.replace(/\(\.\*\)/g, "");
                    return toUrl(url, params, options);
                }
                param(param, fn) {
                    const stack = this.stack;
                    const params = this.#paramNames;
                    const middleware = function (ctx, next) {
                        const p = ctx.params[param];
                        deps_ts_15.assert(p);
                        return fn.call(this, p, ctx, next);
                    };
                    middleware.param = param;
                    const names = params.map((p) => p.name);
                    const x = names.indexOf(param);
                    if (x >= 0) {
                        for (let i = 0; i < stack.length; i++) {
                            const fn = stack[i];
                            if (!fn.param || names.indexOf(fn.param) > x) {
                                stack.splice(i, 0, middleware);
                                break;
                            }
                        }
                    }
                    return this;
                }
                setPrefix(prefix) {
                    if (this.path) {
                        this.path = this.path !== "/" || this.#opts.strict === true
                            ? `${prefix}${this.path}`
                            : prefix;
                        this.#paramNames = [];
                        this.#regexp = deps_ts_15.pathToRegexp(this.path, this.#paramNames, this.#opts);
                    }
                    return this;
                }
                toJSON() {
                    return {
                        methods: [...this.methods],
                        middleware: [...this.stack],
                        paramNames: this.#paramNames.map((key) => key.name),
                        path: this.path,
                        regexp: this.#regexp,
                        options: { ...this.#opts },
                    };
                }
            };
            Router = class Router {
                constructor(opts = {}) {
                    this.#params = {};
                    this.#stack = [];
                    this.#match = (path, method) => {
                        const matches = {
                            path: [],
                            pathAndMethod: [],
                            route: false,
                        };
                        for (const route of this.#stack) {
                            if (route.match(path)) {
                                matches.path.push(route);
                                if (route.methods.length === 0 || route.methods.includes(method)) {
                                    matches.pathAndMethod.push(route);
                                    if (route.methods.length) {
                                        matches.route = true;
                                    }
                                }
                            }
                        }
                        return matches;
                    };
                    this.#register = (path, middleware, methods, options = {}) => {
                        if (Array.isArray(path)) {
                            for (const p of path) {
                                this.#register(p, middleware, methods, options);
                            }
                            return;
                        }
                        const { end, name, sensitive, strict, ignoreCaptures } = options;
                        const route = new Layer(path, methods, middleware, {
                            end: end === false ? end : true,
                            name,
                            sensitive: sensitive ?? this.#opts.sensitive ?? false,
                            strict: strict ?? this.#opts.strict ?? false,
                            ignoreCaptures,
                        });
                        if (this.#opts.prefix) {
                            route.setPrefix(this.#opts.prefix);
                        }
                        for (const [param, mw] of Object.entries(this.#params)) {
                            route.param(param, mw);
                        }
                        this.#stack.push(route);
                    };
                    this.#route = (name) => {
                        for (const route of this.#stack) {
                            if (route.name === name) {
                                return route;
                            }
                        }
                    };
                    this.#useVerb = (nameOrPath, pathOrMiddleware, middleware, methods) => {
                        let name = undefined;
                        let path;
                        if (typeof pathOrMiddleware === "string") {
                            name = nameOrPath;
                            path = pathOrMiddleware;
                        }
                        else {
                            path = nameOrPath;
                            middleware.unshift(pathOrMiddleware);
                        }
                        this.#register(path, middleware, methods, { name });
                    };
                    this.#opts = opts;
                    this.#methods = opts.methods ?? [
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT",
                    ];
                }
                #opts;
                #methods;
                #params;
                #stack;
                #match;
                #register;
                #route;
                #useVerb;
                all(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE", "GET", "POST", "PUT"]);
                    return this;
                }
                allowedMethods(options = {}) {
                    const implemented = this.#methods;
                    const allowedMethods = async (context, next) => {
                        const ctx = context;
                        await next();
                        if (!ctx.response.status || ctx.response.status === deps_ts_15.Status.NotFound) {
                            deps_ts_15.assert(ctx.matched);
                            const allowed = new Set();
                            for (const route of ctx.matched) {
                                for (const method of route.methods) {
                                    allowed.add(method);
                                }
                            }
                            const allowedStr = [...allowed].join(", ");
                            if (!implemented.includes(ctx.request.method)) {
                                if (options.throw) {
                                    throw options.notImplemented
                                        ? options.notImplemented()
                                        : new httpError_ts_7.httpErrors.NotImplemented();
                                }
                                else {
                                    ctx.response.status = deps_ts_15.Status.NotImplemented;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                            }
                            else if (allowed.size) {
                                if (ctx.request.method === "OPTIONS") {
                                    ctx.response.status = deps_ts_15.Status.OK;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                                else if (!allowed.has(ctx.request.method)) {
                                    if (options.throw) {
                                        throw options.methodNotAllowed
                                            ? options.methodNotAllowed()
                                            : new httpError_ts_7.httpErrors.MethodNotAllowed();
                                    }
                                    else {
                                        ctx.response.status = deps_ts_15.Status.MethodNotAllowed;
                                        ctx.response.headers.set("Allowed", allowedStr);
                                    }
                                }
                            }
                        }
                    };
                    return allowedMethods;
                }
                delete(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
                    return this;
                }
                *entries() {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        yield [value, value];
                    }
                }
                forEach(callback, thisArg = null) {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        callback.call(thisArg, value, value, this);
                    }
                }
                get(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["GET"]);
                    return this;
                }
                head(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
                    return this;
                }
                *keys() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                options(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
                    return this;
                }
                param(param, middleware) {
                    this.#params[param] = middleware;
                    for (const route of this.#stack) {
                        route.param(param, middleware);
                    }
                    return this;
                }
                patch(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
                    return this;
                }
                post(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["POST"]);
                    return this;
                }
                prefix(prefix) {
                    prefix = prefix.replace(/\/$/, "");
                    this.#opts.prefix = prefix;
                    for (const route of this.#stack) {
                        route.setPrefix(prefix);
                    }
                    return this;
                }
                put(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
                    return this;
                }
                redirect(source, destination, status = deps_ts_15.Status.Found) {
                    if (source[0] !== "/") {
                        const s = this.url(source);
                        if (!s) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        source = s;
                    }
                    if (destination[0] !== "/") {
                        const d = this.url(destination);
                        if (!d) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        destination = d;
                    }
                    this.all(source, (ctx) => {
                        ctx.response.redirect(destination);
                        ctx.response.status = status;
                    });
                    return this;
                }
                routes() {
                    const dispatch = (context, next) => {
                        const ctx = context;
                        const { url: { pathname }, method } = ctx.request;
                        const path = this.#opts.routerPath ?? ctx.routerPath ??
                            decodeURIComponent(pathname);
                        const matches = this.#match(path, method);
                        if (ctx.matched) {
                            ctx.matched.push(...matches.path);
                        }
                        else {
                            ctx.matched = [...matches.path];
                        }
                        ctx.router = this;
                        if (!matches.route)
                            return next();
                        const { pathAndMethod: matchedRoutes } = matches;
                        const chain = matchedRoutes.reduce((prev, route) => [
                            ...prev,
                            (ctx, next) => {
                                ctx.captures = route.captures(path);
                                ctx.params = route.params(ctx.captures, ctx.params);
                                ctx.routeName = route.name;
                                return next();
                            },
                            ...route.stack,
                        ], []);
                        return middleware_ts_2.compose(chain)(ctx, next);
                    };
                    dispatch.router = this;
                    return dispatch;
                }
                url(name, params, options) {
                    const route = this.#route(name);
                    if (route) {
                        return route.url(params, options);
                    }
                }
                use(pathOrMiddleware, ...middleware) {
                    let path;
                    if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
                        path = pathOrMiddleware;
                    }
                    else {
                        middleware.unshift(pathOrMiddleware);
                    }
                    this.#register(path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path });
                    return this;
                }
                *values() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                *[Symbol.iterator]() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                static url(path, params, options) {
                    return toUrl(path, params, options);
                }
            };
            exports_60("Router", Router);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/helpers", [], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    function isRouterContext(value) {
        return "params" in value;
    }
    function getQuery(ctx, { mergeParams, asMap } = {}) {
        const result = {};
        if (mergeParams && isRouterContext(ctx)) {
            Object.assign(result, ctx.params);
        }
        for (const [key, value] of ctx.request.url.searchParams) {
            result[key] = value;
        }
        return asMap ? new Map(Object.entries(result)) : result;
    }
    exports_61("getQuery", getQuery);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/mod", ["https://deno.land/x/oak@v6.3.1/application", "https://deno.land/x/oak@v6.3.1/context", "https://deno.land/x/oak@v6.3.1/helpers", "https://deno.land/x/oak@v6.3.1/cookies", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/middleware", "https://deno.land/x/oak@v6.3.1/multipart", "https://deno.land/x/oak@v6.3.1/request", "https://deno.land/x/oak@v6.3.1/response", "https://deno.land/x/oak@v6.3.1/router", "https://deno.land/x/oak@v6.3.1/send", "https://deno.land/x/oak@v6.3.1/server_sent_event", "https://deno.land/x/oak@v6.3.1/util", "https://deno.land/x/oak@v6.3.1/deps"], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    return {
        setters: [
            function (application_ts_1_1) {
                exports_62({
                    "Application": application_ts_1_1["Application"]
                });
            },
            function (context_ts_2_1) {
                exports_62({
                    "Context": context_ts_2_1["Context"]
                });
            },
            function (helpers_1) {
                exports_62("helpers", helpers_1);
            },
            function (cookies_ts_2_1) {
                exports_62({
                    "Cookies": cookies_ts_2_1["Cookies"]
                });
            },
            function (httpError_ts_8_1) {
                exports_62({
                    "HttpError": httpError_ts_8_1["HttpError"],
                    "httpErrors": httpError_ts_8_1["httpErrors"],
                    "isHttpError": httpError_ts_8_1["isHttpError"]
                });
            },
            function (middleware_ts_3_1) {
                exports_62({
                    "composeMiddleware": middleware_ts_3_1["compose"]
                });
            },
            function (multipart_ts_2_1) {
                exports_62({
                    "FormDataReader": multipart_ts_2_1["FormDataReader"]
                });
            },
            function (request_ts_2_1) {
                exports_62({
                    "Request": request_ts_2_1["Request"]
                });
            },
            function (response_ts_2_1) {
                exports_62({
                    "REDIRECT_BACK": response_ts_2_1["REDIRECT_BACK"],
                    "Response": response_ts_2_1["Response"]
                });
            },
            function (router_ts_1_1) {
                exports_62({
                    "Router": router_ts_1_1["Router"]
                });
            },
            function (send_ts_2_1) {
                exports_62({
                    "send": send_ts_2_1["send"]
                });
            },
            function (server_sent_event_ts_2_1) {
                exports_62({
                    "ServerSentEvent": server_sent_event_ts_2_1["ServerSentEvent"],
                    "ServerSentEventTarget": server_sent_event_ts_2_1["ServerSentEventTarget"]
                });
            },
            function (util_ts_6_1) {
                exports_62({
                    "isErrorStatus": util_ts_6_1["isErrorStatus"],
                    "isRedirectStatus": util_ts_6_1["isRedirectStatus"]
                });
            },
            function (deps_ts_16_1) {
                exports_62({
                    "Status": deps_ts_16_1["Status"],
                    "STATUS_TEXT": deps_ts_16_1["STATUS_TEXT"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Jira-Work-Logger/opn", [], function (exports_63, context_63) {
    "use strict";
    var run, build, isWsl;
    var __moduleName = context_63 && context_63.id;
    async function opn(target, opts) {
        const optsWithDefault = Object.assign({ wait: true, app: [] }, opts);
        let cmd;
        let args = [];
        const wait = optsWithDefault.wait;
        const appArgs = optsWithDefault.app?.slice(1) || [];
        const openApp = optsWithDefault.app ? optsWithDefault.app[0] : undefined;
        if (build.os === "darwin") {
            cmd = "open";
            if (wait) {
                args.push("-W");
            }
            if (openApp) {
                args.push("-a", openApp);
            }
        }
        else if (build.os === "windows" || isWsl) {
            cmd = "cmd" + (isWsl ? ".exe" : "");
            args.push("/c", "start", "/b");
            target = target.replace(/&/g, "^&");
            if (wait) {
                args.push("/wait");
            }
            if (openApp) {
                args.push(openApp);
            }
            if (appArgs.length > 0) {
                args = args.concat(appArgs);
            }
        }
        else {
            if (openApp) {
                cmd = openApp;
            }
            else {
                cmd = "gio";
                args.push("open");
            }
            if (appArgs.length > 0) {
                args = args.concat(appArgs);
            }
        }
        args.push(target);
        if (build.os === "darwin" && appArgs.length > 0) {
            args.push("--args");
            args = args.concat(appArgs);
        }
        if (opts?.checkDenoPermission) {
            if ((await Deno.permissions.query({ name: "run" })).state !== "granted") {
                throw new Error(`Missing Deno run permission"`);
            }
        }
        const process = run({
            cmd: [cmd, ...args],
            stdout: "inherit",
            stderr: "inherit",
        });
        if (wait) {
            return new Promise(async (resolve, reject) => {
                let status = await process.status();
                if (status.success) {
                    resolve(process);
                }
                else {
                    reject(new Error("Exited with code " + status.code));
                }
            });
        }
        return Promise.resolve(process);
    }
    exports_63("opn", opn);
    return {
        setters: [],
        execute: function () {
            run = Deno.run, build = Deno.build;
            isWsl = false;
        }
    };
});
System.register("file:///Jira-Work-Logger/filesContent", [], function (exports_64, context_64) {
    "use strict";
    var files;
    var __moduleName = context_64 && context_64.id;
    return {
        setters: [],
        execute: function () {
            exports_64("files", files = {
                "index.html": [
                    "PCFkb2N0eXBlIGh0bWw+PGh0bWwgbGFuZz0iZW4iPjxoZWFkPjxtZXRhIGNoYXJzZXQ9InV0Zi04Ii8+PGxpbmsgcmVsPSJpY29uIiBocmVmPSIvZmF2aWNvbi5pY28iLz48bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSIvPjxtZXRhIG5hbWU9InRoZW1lLWNvbG9yIiBjb250ZW50PSIjMDAwMDAwIi8+PHRpdGxlPkppcmEgV29yayBMb2dnZXI8L3RpdGxlPjxsaW5rIGhyZWY9Ii9zdGF0aWMvY3NzL21haW4uMTcyMDQwYmUuY2h1bmsuY3NzIiByZWw9InN0eWxlc2hlZXQiPjwvaGVhZD48Ym9keT48bm9zY3JpcHQ+WW91IG5lZWQgdG8gZW5hYmxlIEphdmFTY3JpcHQgdG8gcnVuIHRoaXMgYXBwLjwvbm9zY3JpcHQ+PGRpdiBpZD0icm9vdCI+PC9kaXY+PHNjcmlwdD4hZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihyKXtmb3IodmFyIG4sbCxpPXJbMF0sYT1yWzFdLGY9clsyXSxjPTAscz1bXTtjPGkubGVuZ3RoO2MrKylsPWlbY10sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sbCkmJm9bbF0mJnMucHVzaChvW2xdWzBdKSxvW2xdPTA7Zm9yKG4gaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxuKSYmKGVbbl09YVtuXSk7Zm9yKHAmJnAocik7cy5sZW5ndGg7KXMuc2hpZnQoKSgpO3JldHVybiB1LnB1c2guYXBwbHkodSxmfHxbXSksdCgpfWZ1bmN0aW9uIHQoKXtmb3IodmFyIGUscj0wO3I8dS5sZW5ndGg7",
                    "cisrKXtmb3IodmFyIHQ9dVtyXSxuPSEwLGk9MTtpPHQubGVuZ3RoO2krKyl7dmFyIGE9dFtpXTswIT09b1thXSYmKG49ITEpfW4mJih1LnNwbGljZShyLS0sMSksZT1sKGwucz10WzBdKSl9cmV0dXJuIGV9dmFyIG49e30sbz17MTowfSx1PVtdO2Z1bmN0aW9uIGwocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciB0PW5bcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwodC5leHBvcnRzLHQsdC5leHBvcnRzLGwpLHQubD0hMCx0LmV4cG9ydHN9bC5tPWUsbC5jPW4sbC5kPWZ1bmN0aW9uKGUscix0KXtsLm8oZSxyKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dH0pfSxsLnI9ZnVuY3Rpb24oZSl7InVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sbC50PWZ1bmN0aW9uKGUscil7aWYoMSZyJiYoZT1sKGUpKSw4JnIpcmV0dXJuIGU7aWYoNCZyJiYib2JqZWN0Ij09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGwucih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImciYmInN0cmluZyIh",
                    "PXR5cGVvZiBlKWZvcih2YXIgbiBpbiBlKWwuZCh0LG4sZnVuY3Rpb24ocil7cmV0dXJuIGVbcl19LmJpbmQobnVsbCxuKSk7cmV0dXJuIHR9LGwubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbC5kKHIsImEiLHIpLHJ9LGwubz1mdW5jdGlvbihlLHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKX0sbC5wPSIvIjt2YXIgaT10aGlzWyJ3ZWJwYWNrSnNvbnBqaXJhLXdvcmstbG9nZ2VyIl09dGhpc1sid2VicGFja0pzb25wamlyYS13b3JrLWxvZ2dlciJdfHxbXSxhPWkucHVzaC5iaW5kKGkpO2kucHVzaD1yLGk9aS5zbGljZSgpO2Zvcih2YXIgZj0wO2Y8aS5sZW5ndGg7ZisrKXIoaVtmXSk7dmFyIHA9YTt0KCl9KFtdKTwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvc3RhdGljL2pzLzIuZGVhZGQyNDQuY2h1bmsuanMiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvc3RhdGljL2pzL21haW4uMGI1NzcyMTYuY2h1bmsuanMiPjwvc2NyaXB0PjwvYm9keT48L2h0bWw+"
                ],
                "favicon.ico": [
                    "AAABAAQAEBAAAAAAAADvv70BAABGAAAAGBgAAAAAAAApAgAA77+9AQAAICAAAAAAAADvv70CAAACBAAAQEAAAAAAAADvv70FAADvv70GAADvv71QTkcNChoKAAAADUlIRFIAAAAQAAAAEAgDAAAAKC0PUwAAAO+/vVBMVEVi77+977+9Yu+/ve+/vWLvv73vv71i77+977+9N15pVe+/ve+/vUnvv73vv70yUVpG77+977+9RO+/ve+/vUF777+9P3bvv70+cu+/vTZbZl3vv73vv71Z77+977+9VO+/ve+/vUvvv73vv702WmQzVF4qO0Bd77+977+9T++/ve+/vU7vv73vv71M77+977+9PXB+OmZzOWRwMU9XMEpSKDM2Ye+/ve+/vWDvv73vv71X77+977+9SO+/ve+/vUTvv73vv704YGwtQEYsP0QkJiciIiJc77+977+9Su+/ve+/vUTvv73vv71D77+977+9PGt5O2p4KDI177+93rPvv70AAAADdFJOU++/vUpJUu+/vTZ3AAAA77+9SURBVBjvv71V77+9RxLvv70wFANQ77+977+977+977+9Xu+/vUnvv73vv73vv70dSe+/vQLvv73vv73vv73vv71tNCJb77+977+977+945Kl77+9A3ksVwJQJEXMuVck77+977+977+9Au+/vRRQ77+9Adew77+977+977+977+9X2Dvv73vv73vv73vv73vv71T0bIZdu+/ve+/vWYEC0MmTO+/vR1377+9Ju+/ve+/vQrvv70p77+977+9QFLvv70y77+9MO+/ve+/ve+/ve+/vdqA77+9JUFw77+9Te+/ve+/vXvvv70277+9OVhb77+9Ihrvv70dS++/vXDvv71S77+9b++/vQxSOVAG77+9MO+/ve+/vScHGe+/vV7vv73vv73vv73vv70iUe+/vQBWR1hg77+9P3/vv70BQu+/vQvbi20vGQAAAABJRU5E77+9QmDv",
                    "v73vv71QTkcNChoKAAAADUlIRFIAAAAYAAAAGAgDAAAA16nvv73vv70AAADvv71QTFRFYu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv70iIiJD77+977+9PGx6N15pM1NcLUJHKz1CVu+/ve+/vUvvv73vv702W2UqODxe77+977+9WO+/ve+/vUjvv73vv71Aeu+/vTpmczhgayUsLlLvv73vv71K77+977+9MElRKTU5JzI1JCcpXe+/ve+/vUzvv73vv71H77+977+9Qn3vv71Ad++/vT5y77+9NVhiYe+/ve+/vVzvv73vv71T77+977+9Ue+/ve+/vUbvv73vv704Y28vR01c77+977+9T++/ve+/vU7vv73vv71M77+977+9Se+/ve+/vWDvv73vv71a77+977+977+977+9HAAAAAd0Uk5T77+9Bu6Qie+/ve+/ve+/ve+/vSIAAAEySURBVCjvv71t77+977+9bu+/vTAMRe+/vdGS77+977+9e++/ve+/ve+/ve+/ve+/ve+/vVXvv73vv71AQO+/vQde77+977+9IO+/vWHvv71XFu+/ve+/ve+/vWptbe+/vR/vv71L77+9FO+/ve+/vX5bS34n77+977+977+977+9Iu+/vTnvv73vv70fMT9VYu+/vSPvv73vv73vv71sIe+/vT/vv70AOyrEqO+/vVNsAO+/vWrvv73vv709ZQbvv73vv73vv71VTl4pSe+/vQFyQUbvv73vv73vv70c77+9cO+/ve+/ve+/vRLvv73vv73vv71tZ++/vVHvv73vv71f77+9U++/ve+/vXgL77+9DQ9+LB7vv712NO+/ve+/ve+/vQ4T77+9ECNIMFTvv714V++/vRt0NQwA77+9Qe+/ve+/ve+/ve+/vSnQp3vvv70bEu+/ve+/vRwI77+9AO+/vWnvv70A77+9KWkY77+9",
                    "BBBFEFzvv73bkDRefu+/vQrvv71hUe+/ve+/ve+/vQhR77+977+977+9B++/vRjvv71077+9Uu+/ve+/vQZ7F++/ve+/vWfvv70HADYYIO+/vUHvv73vv73vv73vv71Q77+9BHpWB8Sj77+977+9Ce+/vQlc77+9DjUP77+9dWgASDxv77+9Be+/vTPvv70xMFfYjGTvv73vv71877+977+977+9W++/vWhf77+9fDYf77+977+9D++/ve+/vR5VMgLvv73vv70AAAAASUVORO+/vUJg77+977+9UE5HDQoaCgAAAA1JSERSAAAAIAAAACAIAwAAAETvv73vv73vv70AAADvv71QTFRFYu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vQAAAGLvv73vv71i77+977+9Yu+/ve+/vSIiIiUsLiMmJ0/vv73vv71M77+977+9MU1VL0dOLEBGR++/ve+/vVnvv73vv71R77+977+9Ue+/ve+/vUvvv73vv70oMzZe77+977+9Su+/ve+/vUXvv73vv71Cf++/vUB677+9OGJtNVlkMlBZYO+/ve+/vVrvv73vv71X77+977+9Ve+/ve+/vVTvv73vv71E77+977+9Q++/ve+/vTtreDpodTNTXC5ESycwMkbvv73vv709bnw0VmAwSlIrOj8pNztf77+977+9XO+/ve+/vVbvv73vv71S77+977+9P3Xvv71J77+977+9Se+/ve+/vWDvv73vv70/de+/vT5z77+9CO+/vWvvv70AAAAHdFJOU++/ve+/vSbvv70A77+9KGdvAwQAAAHvv71JREFUOMuF77+9CW/vv70wFO+/vd2077+9Ge+/ve+/vUBIQu+/vUDvv702ae+/ve+/ve+/ve+/ve+/ve+/vQ0BaS01HQlrQN+z77+977+9Pe+/ve+/vRNP77+9Rk/vv73vv70ieu+/vXjvv73vv70Q77+9d++/vWtr77+9Q++/ve+/",
                    "ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vT4U77+977+9Ru+/ve+/vQ3vv70s77+9A++/ve+/vXQU77+977+9BRdo77+9Au+/ve+/ve+/ve+/ve+/vUnvv73vv71AW++/ve+/ve+/vdKDUULvv73vv73vv71PFhDvv71aIO+/ve+/vdS3AO+/vTRr77+9aO+/ve+/vS7vv71a77+9WAJz77+9F9e90JkDcmQBQ3pS77+9ZynPpO+/vR7vv73vv70BYUoG77+977+9OiYew4BM77+9Dljvv73vv73vv70va3Dvv71v77+9Du+/ve+/ve+/vTnvv73vv71aNUBMf++/ve+/vVZTCRzvv70DUHnvv70IC++/vX0D77+9agLvv70B77+977+9Wnvvv73vv73eoDVh77+977+9LQfvv73NlX4M77+9E1FTNEVbCO+/ve+/ve+/vXpT77+9YWjvv70hbu+/vR1y77+9NQDvv71eBGzvv73vv70CBVkA77+9yZwh77+977+9NO+/ve+/vSXvv73vv715BG50WHPvv70S77+977+9Ku+/ve+/vXc5DCVZJu+/ve+/vR9HPCYlKe+/vVbvv73vv71JMu+/ve+/ve+/vSTvv71zY0Xvv73vv73vv71FLu+/vSxL77+9RjPIsQXvv70C77+9fjHvv73vv73vv73vv73vv73vv73vv71vGiYj77+977+9BRZw77+977+9bjvKs++/ve+/vTLvv73vv70z77+977+9Pe+/vVvvv73vv73vv73vv70udxQ/bn/vv73vv70A77+9JO+/ve+/vW4u77+9aO+/vW4w77+9Ue+/vU3vv73vv71FNzgCDyXvv73vv73vv73vv71977+9ce+/ve+/vQHvv73vv70w77+9Z++/ve+/ve+/vQAAAABJRU5E77+9QmDvv73vv71QTkcNChoKAAAADUlIRFIAAABAAAAAQAgDAAAA77+977+977+977+9AAAA",
                    "77+9UExURQAAAGLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv71i77+977+9Yu+/ve+/vWLvv73vv70iIiIoNDgkJylb77+977+9M1ReLkRLUO+/ve+/vUvvv73vv70wTFQtQUdc77+977+9WO+/ve+/vUrvv73vv71H77+977+9JSosT++/ve+/vUzvv73vv71E77+977+9PG17O2l3OGFtJi0vIyUmYO+/ve+/vVTvv73vv71T77+977+9Tu+/ve+/vT1x77+9N19rKzxBKjk+Xu+/ve+/vS9HTiw/RCcxNCMjJF3vv73vv71J77+977+9KTc7Ye+/ve+/vVrvv73vv71N77+977+9Se+/ve+/vUB377+9Xu+/ve+/vVjvv73vv71W77+977+9Q++/ve+/vUF677+9Ue+/ve+/vUbvv73vv702XGdf77+977+9Vu+/ve+/vTljbzVZYzNRWlLvv73vv71N77+977+9Qn3vv70yUFhQ77+977+977+977+977+9AAAADXRSTlMA77+9148rBu+/ve+/ve+/ve+/ve+/ve+/vQnvv70p77+977+9AAAETElEQVRYw6Xvv713Y++/vTAQ77+9Se+/ve+/ve+/ve+/ve+/vTDvv73vv70R77+9JmwCSe+/vW3vv73vv73vv71P77+977+9MlDThu+/vQ/vv70hPe+/vU7vv71OUu+/vcKH77+977+9G++/vT9xc3vvv70h77+977+977+9Z++/ve+/ve+/vcOe77+9TXo377+9fjQJPklX77+977+977+977+9NQQ3H0J377+9VnXvv71wbnDvv73vv73vv73vv70udHtseu+/vSnvv73vv73The+/vXrvv71rQC/vv712PO+/vTZ077+977+9L1zUnz1jRe+/vUXvv73Yh9CRIQ7vv73vv73vv702JlZ7",
                    "Yw0T77+9cu+/ve+/vV7vv71o77+9Me+/vRQm77+977+977+9OhBOWO+/vUUH77+977+977+9Se+/ve+/vQJB77+977+924o077+9VO+/ve+/vQzQru+/ve+/vSbvv71g77+9B++/ve+/vdujPO+/vUkCNe+/vXPvv73vv70PJO+/vQlJ77+977+9woTvv70y77+9SiBB77+9H++/vQLvv73cv0fvv71A77+9KDwK77+9QQnvv73vv71gSO+/ve+/vRJBRO+/vQ/dos+FKu+/vQMJIu+/vRED77+9Ogfvv70P77+977+977+9CSRY77+977+977+9KQVM77+977+9OEQ+C++/vUDvv71477+927Mw77+977+977+9Vu+/ve+/ve+/vRzvv73vv70lIWk2UWVcByPvv73vv73vv73vv705Be+/ve+/ve+/ve+/vWV/DRTvv73vv70JOe+/ve+/ve+/vQonUO+/vU02LTMNJkjvv73vv71QHHbvv70mOu+/vSIeCgExKE922JDvv71sB1bvv73vv73vv73vv73vv70K77+977+9JmPvv701VT5L77+9HGIj77+9KEvvv70i77+9JEDvv73Yl0YJ77+977+977+977+977+9Ke+/ve+/ve+/ve+/ve+/ve+/vTfvv712LHkWCe+/ve+/vWHvv710KVTvv71d77+9InVEMO+/vQDvv73vv73Mlkrvv73Kou+/vW3vv70/Pu+/ve+/vTVlbe+/ve+/ve+/vRzvv73vv70A25ZIEG9A77+9IW3vv73vv71LBu+/ve+/vWc5Z++/ve+/ve+/ve+/vRwVMe+/vRfvv70nJ03vv73vv71UPe+/vVET77+977+977+9YEPvv70FLO+/vXLvv70NSu+/vUnvv73vv73vv73vv71ecBoM77+9B++/vRzvv73vv73vv70A77+977+977+977+9Iu+/vRQj77+9VH0x77+9ewIV2pLvv70hEHXvv73v",
                    "v70e77+977+977+9QFMYFgPvv70l77+977+977+977+977+977+9ckDane+/ve+/vRfvv73vv71LEBVy77+977+9ez1H77+9au+/ve+/vXDvv73vv73vv73vv71K77+977+9xqkqKgfvv71OMe+/vSEM77+977+977+9Pu+/vQXvv73vv73vv704Mu+/ve+/vRPvv73vv70/77+9Ne+/vR92YSbvv73vv73vv70677+9yJpT77+9Wk1sNGbvv71jW28b77+9Cu+/vW15Qu+/vXdBdhwsGxRGJe+/ve+/ve+/vQo977+9Fe+/vV0UT0jRoTk/IUpZ77+9Ae+/ve+/ve+/vQ5dSlrvv70Pxodq77+9Oe+/vX9DVhrvv70rG++/ve+/ve+/ve+/vVEyZQ3vv73vv71K77+9Ke+/vT3Ziu+/vQAV77+9TjIlVu+/vWPvv73vv70077+91Zrvv73vv70e77+977+977+9Me+/ve+/vQQxDO+/vXFX77+9Su+/ve+/vWxB77+9Z++/vVgo6YWBbi3vv73vv70177+9F++/ve+/ve+/vVLvv717Se+/vWzvv73vv71px7Tvv71W77+977+9G3jQgu+/vQUzWO+/ve+/ve+/vVXvv70M77+977+9NCrvv73vv71Q77+927bvv71P77+977+9QAPvv70ea++/vWN1Be+/vUFkbmXvv71GM++/ve+/vUjvv707IkoZOycUb1bvv73vv70aSDAX77+9MGrvv71O77+9BTAX77+9GXw/77+977+9QCwt77+9fkvvv73vv73vv73vv73vv71L77+977+9L++/vQ1FHkLvv73vv71/Mu+/ve+/ve+/ve+/vV8rUO+/vQrvv71HGFxa77+9WO+/ve+/vQ1QEu+/vX/vv73vv70CE2Hvv70j77+977+9Bu+/ve+/ve+/ve+/ve+/ve+/ve+/vWQH77+9VO+/vRnvv71gIemHsjXXgO+/ve+/vVHvv70Z",
                    "Rh4FE++/vVwn77+9aQ/kt6Pvv73vv70v77+9cUHvv71977+9dzVlyZdC77+9d++/ve+/vSZNdu+/vQTvv71UHO+/ve+/ve+/ve+/vSkp77+977+9Wu+/vQ4UN++/ve+/vQdHE9Cj77+9Ce+/ve+/vSfvv70iXWnvv71777+977+9fD41fjHvv708V++/vTZ0dx3vv73vv73vv73Pvisf77+977+977+9fu+/vV7vv73vv71+77+977+977+977+977+977+977+9A++/vSgS77+9Gu+/ve+/vXwAAAAASUVORO+/vUJg77+9"
                ],
                "precache-manifest.36daccd0636b3f0d1da7b520f25d7d42.js": [
                    "c2VsZi5fX3ByZWNhY2hlTWFuaWZlc3QgPSAoc2VsZi5fX3ByZWNhY2hlTWFuaWZlc3QgfHwgW10pLmNvbmNhdChbCiAgewogICAgInJldmlzaW9uIjogImM0M2FlZmM2Y2ZlNTdhMGIwNjkyOWI1NWNlMTkzN2QwIiwKICAgICJ1cmwiOiAiL2luZGV4Lmh0bWwiCiAgfSwKICB7CiAgICAicmV2aXNpb24iOiAiNTg5OTRhMGFiZGUxZmMxNTQwZGUiLAogICAgInVybCI6ICIvc3RhdGljL2Nzcy9tYWluLjE3MjA0MGJlLmNodW5rLmNzcyIKICB9LAogIHsKICAgICJyZXZpc2lvbiI6ICJlOWVmNmY4YzRmZDY0ZTAyMWQxOCIsCiAgICAidXJsIjogIi9zdGF0aWMvanMvMi5kZWFkZDI0NC5jaHVuay5qcyIKICB9LAogIHsKICAgICJyZXZpc2lvbiI6ICIwNzQ5MTYzYjU5ZmJlZTMyMjI1MDU5Y2I2MGMxOGFmNiIsCiAgICAidXJsIjogIi9zdGF0aWMvanMvMi5kZWFkZDI0NC5jaHVuay5qcy5MSUNFTlNFLnR4dCIKICB9LAogIHsKICAgICJyZXZpc2lvbiI6ICI1ODk5NGEwYWJkZTFmYzE1NDBkZSIsCiAgICAidXJsIjogIi9zdGF0aWMvanMvbWFpbi4wYjU3NzIxNi5jaHVuay5qcyIKICB9LAogIHsKICAgICJyZXZpc2lvbiI6ICI3OTdiNmQyOTdkYzBjOWI5NGUwYSIsCiAgICAidXJsIjogIi9zdGF0aWMvanMvcnVudGltZS1tYWluLmFlNWEzMTI5LmpzIgogIH0KXSk7"
                ],
                "service-worker.js": [
                    "LyoqCiAqIFdlbGNvbWUgdG8geW91ciBXb3JrYm94LXBvd2VyZWQgc2VydmljZSB3b3JrZXIhCiAqCiAqIFlvdSdsbCBuZWVkIHRvIHJlZ2lzdGVyIHRoaXMgZmlsZSBpbiB5b3VyIHdlYiBhcHAgYW5kIHlvdSBzaG91bGQKICogZGlzYWJsZSBIVFRQIGNhY2hpbmcgZm9yIHRoaXMgZmlsZSB0b28uCiAqIFNlZSBodHRwczovL2dvby5nbC9uaFFoR3AKICoKICogVGhlIHJlc3Qgb2YgdGhlIGNvZGUgaXMgYXV0by1nZW5lcmF0ZWQuIFBsZWFzZSBkb24ndCB1cGRhdGUgdGhpcyBmaWxlCiAqIGRpcmVjdGx5OyBpbnN0ZWFkLCBtYWtlIGNoYW5nZXMgdG8geW91ciBXb3JrYm94IGJ1aWxkIGNvbmZpZ3VyYXRpb24KICogYW5kIHJlLXJ1biB5b3VyIGJ1aWxkIHByb2Nlc3MuCiAqIFNlZSBodHRwczovL2dvby5nbC8yYVJEc2gKICovCgppbXBvcnRTY3JpcHRzKCJodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vd29ya2JveC1jZG4vcmVsZWFzZXMvNC4zLjEvd29ya2JveC1zdy5qcyIpOwoKaW1wb3J0U2NyaXB0cygKICAiL3ByZWNhY2hlLW1hbmlmZXN0LjM2ZGFjY2QwNjM2YjNmMGQxZGE3YjUyMGYyNWQ3ZDQyLmpzIgopOwoKc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7CiAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlID09PSAnU0tJUF9XQUlUSU5HJykgewogICAgc2VsZi5za2lwV2FpdGluZygpOwogIH0KfSk7Cgp3b3JrYm94LmNvcmUuY2xpZW50c0NsYWltKCk7Cgov",
                    "KioKICogVGhlIHdvcmtib3hTVy5wcmVjYWNoZUFuZFJvdXRlKCkgbWV0aG9kIGVmZmljaWVudGx5IGNhY2hlcyBhbmQgcmVzcG9uZHMgdG8KICogcmVxdWVzdHMgZm9yIFVSTHMgaW4gdGhlIG1hbmlmZXN0LgogKiBTZWUgaHR0cHM6Ly9nb28uZ2wvUzlRUmFiCiAqLwpzZWxmLl9fcHJlY2FjaGVNYW5pZmVzdCA9IFtdLmNvbmNhdChzZWxmLl9fcHJlY2FjaGVNYW5pZmVzdCB8fCBbXSk7Cndvcmtib3gucHJlY2FjaGluZy5wcmVjYWNoZUFuZFJvdXRlKHNlbGYuX19wcmVjYWNoZU1hbmlmZXN0LCB7fSk7Cgp3b3JrYm94LnJvdXRpbmcucmVnaXN0ZXJOYXZpZ2F0aW9uUm91dGUod29ya2JveC5wcmVjYWNoaW5nLmdldENhY2hlS2V5Rm9yVVJMKCIvaW5kZXguaHRtbCIpLCB7CiAgCiAgYmxhY2tsaXN0OiBbL15cL18vLC9cL1teLz9dK1wuW14vXSskL10sCn0pOwo="
                ],
                "asset-manifest.json": [
                    "ewogICJmaWxlcyI6IHsKICAgICJtYWluLmNzcyI6ICIvc3RhdGljL2Nzcy9tYWluLjE3MjA0MGJlLmNodW5rLmNzcyIsCiAgICAibWFpbi5qcyI6ICIvc3RhdGljL2pzL21haW4uMGI1NzcyMTYuY2h1bmsuanMiLAogICAgInJ1bnRpbWUtbWFpbi5qcyI6ICIvc3RhdGljL2pzL3J1bnRpbWUtbWFpbi5hZTVhMzEyOS5qcyIsCiAgICAic3RhdGljL2pzLzIuZGVhZGQyNDQuY2h1bmsuanMiOiAiL3N0YXRpYy9qcy8yLmRlYWRkMjQ0LmNodW5rLmpzIiwKICAgICJpbmRleC5odG1sIjogIi9pbmRleC5odG1sIiwKICAgICJwcmVjYWNoZS1tYW5pZmVzdC4zNmRhY2NkMDYzNmIzZjBkMWRhN2I1MjBmMjVkN2Q0Mi5qcyI6ICIvcHJlY2FjaGUtbWFuaWZlc3QuMzZkYWNjZDA2MzZiM2YwZDFkYTdiNTIwZjI1ZDdkNDIuanMiLAogICAgInNlcnZpY2Utd29ya2VyLmpzIjogIi9zZXJ2aWNlLXdvcmtlci5qcyIsCiAgICAic3RhdGljL2pzLzIuZGVhZGQyNDQuY2h1bmsuanMuTElDRU5TRS50eHQiOiAiL3N0YXRpYy9qcy8yLmRlYWRkMjQ0LmNodW5rLmpzLkxJQ0VOU0UudHh0IgogIH0sCiAgImVudHJ5cG9pbnRzIjogWwogICAgInN0YXRpYy9qcy9ydW50aW1lLW1haW4uYWU1YTMxMjkuanMiLAogICAgInN0YXRpYy9qcy8yLmRlYWRkMjQ0LmNodW5rLmpzIiwKICAgICJzdGF0aWMvY3NzL21haW4uMTcyMDQwYmUuY2h1bmsuY3NzIiwKICAgICJzdGF0aWMvanMvbWFpbi4wYjU3NzIxNi5jaHVuay5qcyIKICBdCn0="
                ],
                "static/css/main.172040be.chunk.css": [
                    "Ym9keXtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCwiU2Vnb2UgVUkiLCJSb2JvdG8iLCJPeHlnZW4iLCJVYnVudHUiLCJDYW50YXJlbGwiLCJGaXJhIFNhbnMiLCJEcm9pZCBTYW5zIiwiSGVsdmV0aWNhIE5ldWUiLHNhbnMtc2VyaWY7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7YmFja2dyb3VuZC1jb2xvcjojZWVlfS5tYWluLGJvZHl7bWFyZ2luOjEwcHh9LmJ0bi1wYXJ0e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5idG4tcGFydCBidXR0b257bWFyZ2luOjEwcHh9Lk11aVRhYmxlQ2VsbC1yb290e3BhZGRpbmc6NHB4IWltcG9ydGFudH0ubGFzdC1pc3N1ZXMgYnV0dG9ue3RleHQtYWxpZ246bGVmdDttYXJnaW46NHB4fS5pc3N1ZS1idG57dGV4dC10cmFuc2Zvcm06bm9uZSFpbXBvcnRhbnR9Zm9ybSAuTXVpRm9ybUNvbnRyb2wtcm9vdHttYXJnaW46MjBweH1mb3Jte2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXJ9dGQsdGh7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNkZGR9LnJvdy1oZWFkZXJ7bWF4LXdpZHRoOjI1MHB4fXRyLm9kZHtiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y3Zjd9dHIub2RkIC50b3RhbHtiYWNrZ3JvdW5kLWNvbG9yOiNkZWRlZGV9dHIuZXZlbntiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9dHIuZXZlbiAudG90YWx7YmFja2dyb3Vu",
                    "ZC1jb2xvcjojY2ZjZmNmfS50b3RhbC1yb3d7YmFja2dyb3VuZC1jb2xvcjojYzJjNmRjfXRye3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuNnN9dHIgdGQsdHIgdGQgZGl2LHRyIHRoLHRyIHRoIGRpdnt0cmFuc2l0aW9uOm1heC1oZWlnaHQgLjZzLGxpbmUtaGVpZ2h0IC42cyxwYWRkaW5nIC42cyxib3JkZXIgLjZzLGJhY2tncm91bmQtY29sb3IgLjZzfS5pc3N1ZS1lbC1leGl0LWFjdGl2ZSB0ZCwuaXNzdWUtZWwtZXhpdC1hY3RpdmUgdGh7Ym9yZGVyOjAhaW1wb3J0YW50O3BhZGRpbmctdG9wOjAhaW1wb3J0YW50O3BhZGRpbmctYm90dG9tOjAhaW1wb3J0YW50O2xpbmUtaGVpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojZmZkY2RjIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWV4aXQtYWN0aXZlIHRkIGRpdiwuaXNzdWUtZWwtZXhpdC1hY3RpdmUgdGggZGl2e21heC1oZWlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmRjZGMhaW1wb3J0YW50fS5pc3N1ZS1lbC1lbnRlciB0ZCwuaXNzdWUtZWwtZW50ZXIgdGh7bGluZS1oZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWVudGVyIHRkIGRpdiwuaXNzdWUtZWwtZW50ZXIgdGggZGl2e21heC1oZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0ZCwu",
                    "aXNzdWUtZWwtZW50ZXIuaXNzdWUtZWwtZW50ZXItYWN0aXZlIHRoe2xpbmUtaGVpZ2h0OjEuNDN9Lmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0ZCBkaXYsLmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0aCBkaXZ7bWF4LWhlaWdodDoyMDBweCFpbXBvcnRhbnR9LmFkZC1idXR0b257cG9zaXRpb246cmVsYXRpdmV9LmFkZC1idXR0b24gYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3dpZHRoOjEwMCU7ZmxleDoxIDE7YmFja2dyb3VuZC1jb2xvcjojYzJjNmRjfS5pc3N1ZXttYXgtd2lkdGg6MTUwcHg7dGV4dC1hbGlnbjpjZW50ZXJ9Lmlzc3VlLXN1bW1hcnl7Zm9udC1zaXplOjE2cHh9LmNvbW1lbnR7bWFyZ2luLWxlZnQ6NXB4IWltcG9ydGFudH0uY29tbWVudCBpbnB1dHtjb2xvcjojZDE4ZDAwfS5ob3Vye21heC13aWR0aDo2MHB4fS5ob3VyLC5ob3VyIGlucHV0e3RleHQtYWxpZ246Y2VudGVyfS5ob3VyIC5NdWlJbnB1dC11bmRlcmxpbmU6YmVmb3Jle2JvcmRlci1ib3R0b206MH0uaG91ci1jZWxse2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MH0uaG91ci1jZWxsIGJ1dHRvbntmbGV4OjEgMTtjb2xvcjojYTFhMWExfS5ob3VyLWNlbGwgZGl2e2p1c3RpZnktY29udGVudDpjZW50ZXI7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0ud29ya0xv",
                    "Z0RhdGV7bWF4LXdpZHRoOjIwMHB4fS53b3JrTG9nRGF0ZSwud29ya0xvZ0RhdGUgaW5wdXR7dGV4dC1hbGlnbjpjZW50ZXJ9"
                ],
                "static/js/2.deadd244.chunk.js.LICENSE.txt": [
                    "LyoKb2JqZWN0LWFzc2lnbgooYykgU2luZHJlIFNvcmh1cwpAbGljZW5zZSBNSVQKKi8KCi8qKgogKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy4KICoKICogQGNvcHlyaWdodCBPbGVnIElzb25lbiAoU2xvYm9kc2tvaSkgLyBJc29uZW4gMjAxNC1wcmVzZW50CiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcwogKiBAbGljZW5zZSBNSVQKICovCgovKiogQGxpY2Vuc2UgUmVhY3QgdjAuMTkuMQogKiBzY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqLwoKLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xCiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcwogKgogKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovCgovKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjEKICogcmVhY3Qt",
                    "aXMucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqLwoKLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xCiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzCiAqCiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi8K"
                ],
                "static/js/main.0b577216.chunk.js": [
                    "KHRoaXNbIndlYnBhY2tKc29ucGppcmEtd29yay1sb2dnZXIiXT10aGlzWyJ3ZWJwYWNrSnNvbnBqaXJhLXdvcmstbG9nZ2VyIl18fFtdKS5wdXNoKFtbMF0sezczOmZ1bmN0aW9uKGUsdCxhKXtlLmV4cG9ydHM9YSg5Myl9LDc4OmZ1bmN0aW9uKGUsdCxhKXt9LDc5OmZ1bmN0aW9uKGUsdCxhKXt9LDg2OmZ1bmN0aW9uKGUsdCxhKXt9LDg3OmZ1bmN0aW9uKGUsdCxhKXt9LDg4OmZ1bmN0aW9uKGUsdCxhKXt9LDg5OmZ1bmN0aW9uKGUsdCxhKXt9LDkwOmZ1bmN0aW9uKGUsdCxhKXt9LDkxOmZ1bmN0aW9uKGUsdCxhKXt9LDkzOmZ1bmN0aW9uKGUsdCxhKXsidXNlIHN0cmljdCI7YS5yKHQpO3ZhciBuPWEoMCkscj1hLm4obiksbz1hKDgpLHU9YS5uKG8pLGM9KGEoNzgpLGEoNzkpLGEoMTcpKSxzPWEoOSksaT1hLm4ocyksbD1hKDE1KSxtPWEoMzEpLGQ9YSgxNTApLGY9YSgxMjkpLHA9YSgxMzEpLHY9YSgxMzIpLGg9YSgxMzMpLHk9KGEoODYpLGEoMTMwKSksZz1hKDEzNCk7ZnVuY3Rpb24gRShlKXtyZXR1cm4gay5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gaygpe3JldHVybihrPU9iamVjdChsLmEpKGkuYS5tYXJrKChmdW5jdGlvbiBlKHQpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24oZSl7Zm9yKDs7KXN3aXRjaChlLnByZXY9ZS5uZXh0KXtjYXNlIDA6cmV0dXJuIGUubmV4dD0yLGZldGNoKCJodHRwOi8vbG9jYWxob3N0OjgwMDAvbXlMYXN0SXNzdWVzIix7bWV0aG9kOiJQT1NUIixib2R5OkpTT04uc3Ry",
                    "aW5naWZ5KHQpfSkudGhlbihmdW5jdGlvbigpe3ZhciBlPU9iamVjdChsLmEpKGkuYS5tYXJrKChmdW5jdGlvbiBlKHQpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24oZSl7Zm9yKDs7KXN3aXRjaChlLnByZXY9ZS5uZXh0KXtjYXNlIDA6cmV0dXJuIGUubmV4dD0yLHQuanNvbigpO2Nhc2UgMjppZihlLnQwPWUuc2VudC5pc3N1ZXMsZS50MCl7ZS5uZXh0PTU7YnJlYWt9ZS50MD1bXTtjYXNlIDU6cmV0dXJuIGUuYWJydXB0KCJyZXR1cm4iLGUudDApO2Nhc2UgNjpjYXNlImVuZCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUpfSkpKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuW119KSk7Y2FzZSAyOnJldHVybiBlLmFicnVwdCgicmV0dXJuIixlLnNlbnQpO2Nhc2UgMzpjYXNlImVuZCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUpfSkpKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGIoZSx0KXt2YXIgYT17fTtyZXR1cm4gZS5mbGF0TWFwKChmdW5jdGlvbihlKXt2YXIgdCxhO3JldHVybihudWxsPT09KHQ9ZS5maWVsZHMpfHx2b2lkIDA9PT10fHxudWxsPT09KGE9dC53b3JrbG9nKXx8dm9pZCAwPT09YT92b2lkIDA6YS53b3JrbG9ncyl8fFtdfSkpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXV0aG9yLmtleT09PXR9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXJ0ZWQsYT1lLnRpbWVTcGVudFNlY29u",
                    "ZHM7cmV0dXJue2RhdGU6dC5zdWJzdHIoMCwxMCksdGltZVNwZW50U2Vjb25kczphfX0pKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLmRhdGUsbj1lLnRpbWVTcGVudFNlY29uZHM7cmV0dXJuIGFbdF09bisoYVt0XXx8MCl9KSksYX12YXIgdz1hKDE0KSxqPWEoNTUpLE89YSgzOSksQz1hKDE2KTt2YXIgUz1mdW5jdGlvbihlKXt2YXIgdD1lLmdldFN0YXRlO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oYSl7dmFyIG4scj1lKGEpO3JldHVybiBuPXQoKSxsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgiamlyYS13b3JrLWxvZ2VyLWRhdGEtc3RhdGUiLEpTT04uc3RyaW5naWZ5KG4pKSxyfX19O2Z1bmN0aW9uIHgoZSl7cmV0dXJuIE1hdGgucm91bmQoMTAwKmUpLzEwMH1mdW5jdGlvbiBJKGUsdCxhLG4pe3JldHVybiBELmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBEKCl7cmV0dXJuKEQ9T2JqZWN0KGwuYSkoaS5hLm1hcmsoKGZ1bmN0aW9uIGUodCxhLG4scil7dmFyIG8sdSxjO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24oZSl7Zm9yKDs7KXN3aXRjaChlLnByZXY9ZS5uZXh0KXtjYXNlIDA6cmV0dXJuIGUubmV4dD0yLGZldGNoKCJodHRwOi8vbG9jYWxob3N0OjgwMDAvaXNzdWUvIi5jb25jYXQobnVsbD09PShvPXQua2V5KXx8dm9pZCAwPT09bz92b2lkIDA6by50cmltKCkpLHttZXRob2Q6IlBPU1QiLGJvZHk6SlNPTi5zdHJpbmdpZnkoYSgpLmNvbmZpZyl9KS50aGVuKGZ1bmN0aW9uKCl7",
                    "dmFyIGU9T2JqZWN0KGwuYSkoaS5hLm1hcmsoKGZ1bmN0aW9uIGUodCl7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpyZXR1cm4gZS5uZXh0PTIsdC5qc29uKCk7Y2FzZSAyOmlmKGUudDA9ZS5zZW50LGUudDApe2UubmV4dD01O2JyZWFrfWUudDA9e2tleToiIn07Y2FzZSA1OnJldHVybiBlLmFicnVwdCgicmV0dXJuIixlLnQwKTtjYXNlIDY6Y2FzZSJlbmQiOnJldHVybiBlLnN0b3AoKX19KSxlKX0pKSk7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KCkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybntrZXk6IiJ9fSkpO2Nhc2UgMjoobnVsbD09PSh1PWUuc2VudCl8fHZvaWQgMD09PXU/dm9pZCAwOnUua2V5KT09PXQua2V5JiZuKEguc2V0SXNzdWVWYWx1ZSh7eTpyLGlzc3VlOntrZXk6dC5rZXl8fCIiLGZpZWxkczp7c3VtbWFyeTpudWxsPT09dXx8dm9pZCAwPT09dXx8bnVsbD09PShjPXUuZmllbGRzKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5zdW1tYXJ5fX19KSk7Y2FzZSA0OmNhc2UiZW5kIjpyZXR1cm4gZS5zdG9wKCl9fSksZSl9KSkpKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gTChlLHQpe3JldHVybiBPYmplY3QoQy5hKShlLChmdW5jdGlvbihhKXt2YXIgbj1lLmRhdGVzLmxlbmd0aD4wP2UuZGF0ZXNbZS5kYXRlcy5sZW5ndGgtMV06bnVsbDthLmRhdGVzLnB1c2godHx8KG4/bmV3",
                    "IERhdGUobi5nZXRUaW1lKCkrODY0ZTUpOm5ldyBEYXRlKSksYS5ob3Vycy5wdXNoKGEuaXNzdWVzLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4gMH0pKSl9KSl9ZnVuY3Rpb24gTihlKXtyZXR1cm4gT2JqZWN0KEMuYSkoZSwoZnVuY3Rpb24oZSl7ZT1MKGUsbmV3IERhdGUoKG5ldyBEYXRlKS5nZXRUaW1lKCktMzQ1NmU1KSk7Zm9yKHZhciB0PTA7dDw0O3QrKyllPUwoZSk7cmV0dXJuIGV9KSl9ZnVuY3Rpb24gVShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e2tleToiIn07cmV0dXJuIE9iamVjdChDLmEpKGUsKGZ1bmN0aW9uKGUpe2UuaXNzdWVzLnB1c2goT2JqZWN0KHcuYSkoe30sdCx7cmVhY3RLZXk6dC5yZWFjdEtleXx8TWF0aC5yYW5kb20oKX0pKSxlLmhvdXJzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucHVzaCgwKX0pKX0pKX12YXIgej1mdW5jdGlvbigpe3ZhciBlLHQ9bG9jYWxTdG9yYWdlLmdldEl0ZW0oImppcmEtd29yay1sb2dlci1kYXRhLXN0YXRlIik7cmV0dXJuIHQ/KGU9SlNPTi5wYXJzZSh0KSkuZGF0YS5kYXRlcz1lLmRhdGEuZGF0ZXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IERhdGUoZSl9KSk6ZT17ZGF0YTpVKE4oe2RhdGVzOltdLGhvdXJzOltdLGlzc3VlczpbXX0pKSxjb25maWc6e2ppcmFVcmw6ImppcmFVcmwiLHVzZXJuYW1lOiJ1c2VybmFtZSIscGFzc3dvcmQ6InBhc3N3b3JkIixoYW1zdGVyRGF5c1RvSW1w",
                    "b3J0OjV9fSxlfSxSPU9iamVjdChqLmIpKHtuYW1lOiJyb290Iixpbml0aWFsU3RhdGU6eigpLHJlZHVjZXJzOntjbGVhckRhdGE6ZnVuY3Rpb24oZSl7ZS5kYXRhPXtkYXRlczpbXSxpc3N1ZXM6W10saG91cnM6W119fSxhZGRMYXN0NURheXM6ZnVuY3Rpb24oZSl7ZS5kYXRhPU4oZS5kYXRhKX0sc2V0Q29uZmlnOmZ1bmN0aW9uKGUsdCl7dmFyIGE9dC5wYXlsb2FkLmNvbmZpZztlLmNvbmZpZz1hfSxpc3N1ZUNsaWNrZWQ6ZnVuY3Rpb24oZSx0KXt2YXIgYSxuPXQucGF5bG9hZC5pc3N1ZTtlLmRhdGE9VShlLmRhdGEse2tleTpuLmtleSxmaWVsZHM6e3N1bW1hcnk6bnVsbD09PShhPW4uZmllbGRzKXx8dm9pZCAwPT09YT92b2lkIDA6YS5zdW1tYXJ5fX0pfSxhZGRSb3c6ZnVuY3Rpb24oZSl7ZS5kYXRhPVUoZS5kYXRhKX0sYWRkQ29sdW1uOmZ1bmN0aW9uKGUpe2UuZGF0YT1MKGUuZGF0YSl9LHNldERhdGE6ZnVuY3Rpb24oZSx0KXt2YXIgYT10LnBheWxvYWQuZGF0YTtlLmRhdGE9YX0sc2V0SXNzdWVWYWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBhPXQucGF5bG9hZCxuPWEueSxyPWEuaXNzdWU7ZS5kYXRhLmlzc3Vlc1tuXT1PYmplY3Qody5hKSh7fSxyLHtyZWFjdEtleTplLmRhdGEuaXNzdWVzW25dLnJlYWN0S2V5fHxNYXRoLnJhbmRvbSgpfSl9LHJlbW92ZUNvbHVtbjpmdW5jdGlvbihlLHQpe3ZhciBhPXQucGF5bG9hZC5udW07ZS5kYXRhLmRhdGVzLnNwbGljZShhLDEpLGUuZGF0YS5ob3Vycy5zcGxpY2UoYSwxKX0s",
                    "cmVtb3ZlUm93OmZ1bmN0aW9uKGUsdCl7dmFyIGE9dC5wYXlsb2FkLm51bTtlLmRhdGEuaXNzdWVzLnNwbGljZShhLDEpLGUuZGF0YS5ob3Vycy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGljZShhLDEpfSkpfSxzZXREYXRlVmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgYT10LnBheWxvYWQsbj1hLm51bSxyPWEuZGF0ZTtlLmRhdGEuZGF0ZXNbbl09cn0sc2V0SG91clZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGE9dC5wYXlsb2FkLG49YS54LHI9YS55LG89YS5ob3VyO2UuZGF0YS5ob3Vyc1tuXVtyXT1vfSxzZXRXb3Jrc0xvZ2dlZDpmdW5jdGlvbihlLHQpe3ZhciBhPXQucGF5bG9hZC53b3Jrc0xvZ2dlZDtlLndvcmtzTG9nZ2VkPWF9LGltcG9ydEhhbXN0ZXJSZXBvcnQ6ZnVuY3Rpb24oZSx0KXshZnVuY3Rpb24oZSx0KXt2YXIgYT1uZXcgU2V0KGUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5kYXRlfSkpKSxuPW5ldyBTZXQoZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbW1lbnR9KSkpLHI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUubWF0Y2goL1tBLVpdKy1bMC05XSsvKT9lLnJlcGxhY2UoL14oLio/KShbQS1aXSstWzAtOV0rKSguKj8pJC9nLCIkMiIpOiIifTt0LmRhdGE9e2RhdGVzOkFycmF5LmZyb20oYSkuc29ydCgpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBEYXRlKGUpfSkpLGlzc3VlczpBcnJheS5mcm9tKG4pLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJue2tleTpyKGUpLHdvcmtMb2dDb21t",
                    "ZW50OmUscmVhY3RLZXk6TWF0aC5yYW5kb20oKX19KSksaG91cnM6W119LGEuZm9yRWFjaCgoZnVuY3Rpb24oKXtyZXR1cm4gdC5kYXRhLmhvdXJzLnB1c2gobmV3IEFycmF5KHQuZGF0YS5pc3N1ZXMubGVuZ3RoKS5maWxsKDApKX0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBhPWUuY29tbWVudCxuPWUuaG91cnMscj1lLmRhdGUsbz10LmRhdGEuaXNzdWVzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUud29ya0xvZ0NvbW1lbnR9KSkuaW5kZXhPZihhKTtpZihvPj0wKXt2YXIgdT10LmRhdGEuZGF0ZXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS50b0lTT1N0cmluZygpLnN1YnN0cigwLDEwKX0pKS5pbmRleE9mKHIpO3U+PTAmJih0LmRhdGEuaG91cnNbdV1bb109eChuKSl9fSkpfSh0LnBheWxvYWQuaGFtc3RlclJlcG9ydCxlKX0sY3JlYXRlV29ya0xvZ3M6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kYXRhLmlzc3Vlcy5tYXAoKGZ1bmN0aW9uKGUsdCl7cmV0dXJue2lzc3VlOmUseTp0fX0pKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlzc3VlLmtleS5tYXRjaCgvXltBLVphLXpdKy1bMC05XSskLyl9KSkuZmxhdE1hcCgoZnVuY3Rpb24odCl7dmFyIGE9dC5pc3N1ZSxuPXQueTtyZXR1cm4gZS5kYXRhLmRhdGVzLm1hcCgoZnVuY3Rpb24odCxyKXtyZXR1cm57aXNzdWU6YSxkYXRlOnQsaG91cnM6ZS5kYXRhLmhvdXJzW3JdW25dfX0pKX0pKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmhvdXJz",
                    "PjB9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lLmlzc3VlLGE9ZS5kYXRlLG49ZS5ob3VycztyZXR1cm57a2V5OnQua2V5LGNvbW1lbnQ6dC53b3JrTG9nQ29tbWVudHx8IiIsZGF0ZTphLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDAsMTApLGhvdXJzOm59fSkpO2ZldGNoKCJodHRwOi8vbG9jYWxob3N0OjgwMDAvY3JlYXRlV29ya0xvZ3MiLHttZXRob2Q6IlBPU1QiLG1vZGU6Im5vLWNvcnMiLGJvZHk6SlNPTi5zdHJpbmdpZnkoe2NvbmZpZzplLmNvbmZpZyx0b0xvZzp0fSl9KX0scmVzZXRIb3VyczpmdW5jdGlvbihlKXtlLmRhdGEuaG91cnMuZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbih0LGEpe3JldHVybiBlW2FdPTB9KSl9KSl9LHJlc2V0Q29uZmlnOmZ1bmN0aW9uKCl7cmV0dXJuIGxvY2FsU3RvcmFnZS5jbGVhcigpLHooKX19fSksSD1SLmFjdGlvbnMsVj1PYmplY3Qoai5hKSh7cmVkdWNlcjpSLnJlZHVjZXIsbWlkZGxld2FyZTpbTy5hLFNdfSksVz1PYmplY3QoYy5iKSgoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSxIKSgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kYXRhLGE9ZS5jb25maWcsbz1lLmlzc3VlQ2xpY2tlZCx1PWUuc2V0V29ya3NMb2dnZWQsYz1PYmplY3Qobi51c2VTdGF0ZSkoW10pLHM9T2JqZWN0KG0uYSkoYywyKSxrPXNbMF0sdz1zWzFdO09iamVjdChuLnVzZUVmZmVjdCkoKGZ1bmN0aW9uKCl7dmFyIGU9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4g",
                    "RShhKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gdyhlKX0pKX0pLDFlMyk7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX19KSxbYV0pLE9iamVjdChuLnVzZUVmZmVjdCkoKGZ1bmN0aW9uKCl7dSh7d29ya3NMb2dnZWQ6YihrLGEudXNlcm5hbWUpfSl9KSxbYSx1LGtdKTt2YXIgaixPPU9iamVjdChuLnVzZVN0YXRlKSgicGFuZWwxIiksQz1PYmplY3QobS5hKShPLDIpLFM9Q1swXSx4PUNbMV07cmV0dXJuIHIuYS5jcmVhdGVFbGVtZW50KGQuYSx7ZXhwYW5kZWQ6InBhbmVsMSI9PT1TLGVsZXZhdGlvbjozLG9uQ2hhbmdlOihqPSJwYW5lbDEiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHgoISF0JiZqKX0pfSxyLmEuY3JlYXRlRWxlbWVudChmLmEseyJhcmlhLWNvbnRyb2xzIjoicGFuZWwxZC1jb250ZW50IixpZDoicGFuZWwxZC1oZWFkZXIiLGV4cGFuZEljb246ci5hLmNyZWF0ZUVsZW1lbnQoeS5hLG51bGwpfSxyLmEuY3JlYXRlRWxlbWVudChwLmEse3ZhcmlhbnQ6Img1IixndXR0ZXJCb3R0b206ITB9LCJBZGQgaXNzdWVzIikpLHIuYS5jcmVhdGVFbGVtZW50KHYuYSxudWxsLHIuYS5jcmVhdGVFbGVtZW50KCJkaXYiLHtzdHlsZTp7ZGlzcGxheToiZmxleCIsZmxleERpcmVjdGlvbjoicm93LXJldmVyc2UifX0sci5hLmNyZWF0ZUVsZW1lbnQoaC5hLHt2YXJpYW50OiJjb250YWluZWQiLG9uQ2xpY2s6T2JqZWN0KGwuYSkoaS5hLm1hcmsoKGZ1bmN0aW9uIGUoKXtyZXR1cm4gaS5hLndyYXAo",
                    "KGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLnQwPXcsZS5uZXh0PTMsRShhKTtjYXNlIDM6cmV0dXJuIGUudDE9ZS5zZW50LGUuYWJydXB0KCJyZXR1cm4iLCgwLGUudDApKGUudDEpKTtjYXNlIDU6Y2FzZSJlbmQiOnJldHVybiBlLnN0b3AoKX19KSxlKX0pKSl9LHIuYS5jcmVhdGVFbGVtZW50KGcuYSxudWxsKSkpLHIuYS5jcmVhdGVFbGVtZW50KCJkaXYiLHtjbGFzc05hbWU6Imxhc3QtaXNzdWVzIn0say5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiF0Lmlzc3Vlcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmtleX0pKS5pbmNsdWRlcyhlLmtleSl9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoImRpdiIse2tleTplLmtleX0sci5hLmNyZWF0ZUVsZW1lbnQoaC5hLHt2YXJpYW50OiJjb250YWluZWQiLGNvbG9yOiJwcmltYXJ5IixjbGFzc05hbWU6Imlzc3VlLWJ0biIsb25DbGljazpmdW5jdGlvbigpe3JldHVybiBvKHtpc3N1ZTplfSl9fSxlLmtleSwiIC0gIixudWxsPT09KHQ9ZS5maWVsZHMpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LnN1bW1hcnkpKX0pKSkpKX0pKSxLPWEoMTQ4KSxUPShhKDg3KSxhKDEzNSkpO3ZhciBBPU9iamVjdChjLmIpKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pLEgpKChmdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZyxhPWUuc2V0Q29uZmlnLG49ZS5yZXNldENvbmZpZztyZXR1cm4gci5h",
                    "LmNyZWF0ZUVsZW1lbnQoZC5hLHtlbGV2YXRpb246M30sci5hLmNyZWF0ZUVsZW1lbnQoZi5hLHtleHBhbmRJY29uOnIuYS5jcmVhdGVFbGVtZW50KHkuYSxudWxsKX0sci5hLmNyZWF0ZUVsZW1lbnQocC5hLHt2YXJpYW50OiJoNSIsZ3V0dGVyQm90dG9tOiEwfSwiQ29uZmlndXJhdGlvbiIpKSxyLmEuY3JlYXRlRWxlbWVudCh2LmEsbnVsbCxyLmEuY3JlYXRlRWxlbWVudCgiZm9ybSIse25vVmFsaWRhdGU6ITAsYXV0b0NvbXBsZXRlOiJvZmYifSxyLmEuY3JlYXRlRWxlbWVudChLLmEse2xhYmVsOiJKaXJhIFVybCIsc3R5bGU6e21pbldpZHRoOjMwMH0sdmFsdWU6dC5qaXJhVXJsLG9uQ2hhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiBhKHtjb25maWc6T2JqZWN0KHcuYSkoe30sdCx7amlyYVVybDplLnRhcmdldC52YWx1ZX0pfSl9fSksci5hLmNyZWF0ZUVsZW1lbnQoSy5hLHtsYWJlbDoiVXNlcm5hbWUiLHZhbHVlOnQudXNlcm5hbWUsb25DaGFuZ2U6ZnVuY3Rpb24oZSl7cmV0dXJuIGEoe2NvbmZpZzpPYmplY3Qody5hKSh7fSx0LHt1c2VybmFtZTplLnRhcmdldC52YWx1ZX0pfSl9fSksci5hLmNyZWF0ZUVsZW1lbnQoSy5hLHtsYWJlbDoicGFzc3dvcmQiLHR5cGU6InBhc3N3b3JkIix2YWx1ZTp0LnBhc3N3b3JkLCJhcmlhLWF1dG9jb21wbGV0ZSI6Im5vbmUiLGF1dG9Db21wbGV0ZToib2ZmIixvbkNoYW5nZTpmdW5jdGlvbihlKXtyZXR1cm4gYSh7Y29uZmlnOk9iamVjdCh3LmEpKHt9LHQse3Bhc3N3b3JkOmUudGFy",
                    "Z2V0LnZhbHVlfSl9KX19KSxyLmEuY3JlYXRlRWxlbWVudChLLmEse2xhYmVsOiJIYW1zdGVyIGNhdGVnb3JpZXMgdG8gaWdub3JlIChyZWdleCkiLHN0eWxlOnttaW5XaWR0aDozMDB9LHZhbHVlOnQuaGFtc3Rlcklnbm9yZWRDYXRlZ29yaWVzLG9uQ2hhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiBhKHtjb25maWc6T2JqZWN0KHcuYSkoe30sdCx7aGFtc3Rlcklnbm9yZWRDYXRlZ29yaWVzOmUudGFyZ2V0LnZhbHVlfSl9KX19KSxyLmEuY3JlYXRlRWxlbWVudChLLmEse2xhYmVsOiJOYiBvZiBkYXlzIHRvIGltcG9ydCBmcm9tIEhhbXN0ZXIiLHN0eWxlOnttaW5XaWR0aDozMDB9LHR5cGU6Im51bWJlciIsdmFsdWU6dC5oYW1zdGVyRGF5c1RvSW1wb3J0LG9uQ2hhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiBhKHtjb25maWc6T2JqZWN0KHcuYSkoe30sdCx7aGFtc3RlckRheXNUb0ltcG9ydDpOdW1iZXIoZS50YXJnZXQudmFsdWUpfSl9KX19KSxyLmEuY3JlYXRlRWxlbWVudChoLmEse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6bn0sci5hLmNyZWF0ZUVsZW1lbnQoVC5hLG51bGwpLCIgUmVzZXQgY29uZmlnIikpKSl9KSksSj1hKDE0MyksTT1hKDE0NCksUD1hKDE0MiksWj1hKDEyOCksJD0oYSg4OCksYSgxMzcpKSxCPWEoMTM2KSxfPWEoMTM4KTtmdW5jdGlvbiBGKGUsdCl7cmV0dXJuIHgoZS5ob3Vyc1t0XS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0pLDApKX1mdW5jdGlvbiBZ",
                    "KGUsdCl7dmFyIGE9ZT9PYmplY3QuZW50cmllcyhlKS5maW5kKChmdW5jdGlvbihlKXt2YXIgYT1PYmplY3QobS5hKShlLDIpLG49YVswXTthWzFdO3JldHVybiBuPT09dC50b0lTT1N0cmluZygpLnN1YnN0cigwLDEwKX0pKTowO3JldHVybiBhP3goYVsxXS8zNjAwKTowfWZ1bmN0aW9uIHEoZSl7dmFyIHQ9ZS5hZGRSb3csYT1lLmRhdGEsbj1lLndvcmtzTG9nZ2VkO3JldHVybiByLmEuY3JlYXRlRWxlbWVudChCLmEse2NsYXNzTmFtZToidG90YWwtcm93In0sci5hLmNyZWF0ZUVsZW1lbnQoJC5hLHthbGlnbjoiY2VudGVyIixjbGFzc05hbWU6ImFkZC1idXR0b24ifSxyLmEuY3JlYXRlRWxlbWVudChoLmEse2NvbG9yOiJwcmltYXJ5IixvbkNsaWNrOnR9LHIuYS5jcmVhdGVFbGVtZW50KF8uYSx7c3R5bGU6e2ZvbnRTaXplOjQwfX0pKSksYS5kYXRlcy5tYXAoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIuYS5jcmVhdGVFbGVtZW50KEcsT2JqZWN0LmFzc2lnbih7eDp0LGRhdGU6ZSx3b3Jrc0xvZ2dlZDpuLGRhdGE6YX0se2tleTp0K2UudG9JU09TdHJpbmcoKX0pKX0pKSxyLmEuY3JlYXRlRWxlbWVudCgkLmEse3N0eWxlOntmb250U2l6ZToyMCx0ZXh0QWxpZ246ImNlbnRlciIsbWluV2lkdGg6MTAwfSxjbGFzc05hbWU6InRvdGFsIn0sZnVuY3Rpb24oZSl7cmV0dXJuIHgoZS5ob3Vycy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0fSksMCl9KSkucmVkdWNlKChm",
                    "dW5jdGlvbihlLHQpe3JldHVybiBlK3R9KSwwKSl9KGEpKSl9ZnVuY3Rpb24gRyhlKXt2YXIgdD1lLngsYT1lLmRhdGUsbj1lLndvcmtzTG9nZ2VkLG89ZS5kYXRhO3JldHVybiByLmEuY3JlYXRlRWxlbWVudCgkLmEse2FsaWduOiJjZW50ZXIiLGNsYXNzTmFtZToidG90YWwifSxyLmEuY3JlYXRlRWxlbWVudCgiZGl2Iix7c3R5bGU6e2NvbG9yOiIjYTkxYjFiIixmb250U2l6ZToxNn19LCJBbHJlYWR5IExvZ2dlZCA+PSAiLFkobixhKSksci5hLmNyZWF0ZUVsZW1lbnQoImRpdiIse3N0eWxlOntkaXNwbGF5OiJmbGV4IixqdXN0aWZ5Q29udGVudDoiY2VudGVyIn19LHIuYS5jcmVhdGVFbGVtZW50KFEse3RvdGFsOngoRihvLHQpK1kobixhKSl9KSkpfWZ1bmN0aW9uIFEoZSl7dmFyIHQ9ZS50b3RhbCxhPSIiO3N3aXRjaCghMCl7Y2FzZSB0PDA6Y2FzZSB0PjcuNDphPSIjZmYwMDAwIjticmVhaztjYXNlIDA9PT10OmE9IiNmZmJlYmUiO2JyZWFrO2Nhc2UgMy43PT09dDphPSIjOTZiZmZmIjticmVhaztjYXNlIDcuND09PXQ6YT0iIzg5ZmY2ZiI7YnJlYWs7ZGVmYXVsdDphPSIjZmZjNTk0In1yZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoImRpdiIse3N0eWxlOntiYWNrZ3JvdW5kQ29sb3I6YSxmb250U2l6ZToyMCxib3JkZXJSYWRpdXM6MjAsd2lkdGg6MTAwfX0sdCl9YSg4OSk7dmFyIFg9YSgxMzkpLGVlPWEoOTQpLHRlPWZ1bmN0aW9uKGUpe3ZhciB0LGEsbj1lLmlzc3VlLG89ZS5vbkRlbGV0ZSx1PWUub25LZXlDaGFu",
                    "Z2UsYz1lLm9uQ29tbWVudENoYW5nZSxzPWUuamlyYVVybDtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoImRpdiIsbnVsbCxyLmEuY3JlYXRlRWxlbWVudCgiZGl2IixudWxsLHIuYS5jcmVhdGVFbGVtZW50KGVlLmEse2NvbG9yOiJzZWNvbmRhcnkiLG9uQ2xpY2s6b30sci5hLmNyZWF0ZUVsZW1lbnQoWC5hLHtmb250U2l6ZToibGFyZ2UifSkpLHIuYS5jcmVhdGVFbGVtZW50KEsuYSx7Y2xhc3NOYW1lOiJpc3N1ZSIsdmFsdWU6bi5rZXksc3R5bGU6e21heFdpZHRoOjEwMCxiYWNrZ3JvdW5kQ29sb3I6bi5rZXkubWF0Y2goL15bQS1aYS16XSstWzAtOV0rJC8pPyIjZWRmNGZmIjoiI2ZmZGJkMCJ9LG9uQ2hhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiB1KGUudGFyZ2V0LnZhbHVlKX19KSxyLmEuY3JlYXRlRWxlbWVudChLLmEse2NsYXNzTmFtZToiY29tbWVudCIsdmFsdWU6bi53b3JrTG9nQ29tbWVudCxwbGFjZWhvbGRlcjoiV29yayBsb2cgY29tbWVudCIsc3R5bGU6e21heFdpZHRoOjE2MH0sb25DaGFuZ2U6ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZS50YXJnZXQudmFsdWUpfX0pKSwobnVsbD09PSh0PW4uZmllbGRzKXx8dm9pZCAwPT09dD92b2lkIDA6dC5zdW1tYXJ5KT9yLmEuY3JlYXRlRWxlbWVudCgiZGl2Iix7Y2xhc3NOYW1lOiJpc3N1ZS1zdW1tYXJ5In0sci5hLmNyZWF0ZUVsZW1lbnQoImEiLHt0YXJnZXQ6Il9ibGFuayIscmVsOiJub29wZW5lciBub3JlZmVycmVyIixocmVmOiIiLmNvbmNhdChzLCIvYnJvd3Nl",
                    "LyIpLmNvbmNhdChuLmtleSl9LG51bGw9PT0oYT1uLmZpZWxkcyl8fHZvaWQgMD09PWE/dm9pZCAwOmEuc3VtbWFyeSkpOiIiKX0sYWU9YSgxNTEpLG5lPWEoMTQ5KSxyZT1hKDUwKSxvZT0oYSg5MCksYSgxNDApKTtmdW5jdGlvbiB1ZShlKXtzd2l0Y2goITApe2Nhc2UgZTw9MDpyZXR1cm4iI2ZmZiI7Y2FzZSBlPjcuNDpyZXR1cm4iaHNsKCIuY29uY2F0KDUwLCIsMTAwJSw3NiUpIik7ZGVmYXVsdDpyZXR1cm4iaHNsKCIuY29uY2F0KDI1MC1lLzcuNCoyMDAsIiwxMDAlLDc2JSkiKX19ZnVuY3Rpb24gY2UoZSl7cmV0dXJuIHgoZS09MS44NSksZTwwPzA6ZX1mdW5jdGlvbiBzZShlKXtyZXR1cm4geChlKz0xLjg1KSxlPjcuND83LjQ6ZX12YXIgaWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ob3VyLGE9ZS5zZXRIb3VyLG49T2JqZWN0KHJlLmEpKGUsWyJob3VyIiwic2V0SG91ciJdKTtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoImRpdiIse2NsYXNzTmFtZToiaG91ci1jZWxsIn0sci5hLmNyZWF0ZUVsZW1lbnQoaC5hLHtzaXplOiJzbWFsbCIsb25DbGljazpmdW5jdGlvbigpe3JldHVybiBhKGNlKHQpKX19LHIuYS5jcmVhdGVFbGVtZW50KG9lLmEsbnVsbCkpLHIuYS5jcmVhdGVFbGVtZW50KCJkaXYiLG51bGwsci5hLmNyZWF0ZUVsZW1lbnQoSy5hLE9iamVjdC5hc3NpZ24oe2NsYXNzTmFtZToiaG91ciIsdHlwZToibnVtYmVyIix2YWx1ZTp4KHQpLHN0eWxlOntiYWNrZ3JvdW5kQ29sb3I6dWUodCksYm9yZGVyUmFkaXVz",
                    "OjIwLHBhZGRpbmdMZWZ0OjEwfSxvbldoZWVsOmZ1bmN0aW9uKGUpe2UuZGVsdGFZPjA/YShjZSh0KSk6YShzZSh0KSksZS5wcmV2ZW50RGVmYXVsdCgpfSxvbkNoYW5nZTpmdW5jdGlvbihlKXtyZXR1cm4gYShOdW1iZXIoZS50YXJnZXQudmFsdWUpKX0sSW5wdXRQcm9wczp7aW5wdXRQcm9wczp7bWluOjAsbWF4OjcuNCxzdGVwOjEuODV9fX0sbikpKSxyLmEuY3JlYXRlRWxlbWVudChoLmEse3NpemU6InNtYWxsIixvbkNsaWNrOmZ1bmN0aW9uKCl7cmV0dXJuIGEoc2UodCkpfX0sci5hLmNyZWF0ZUVsZW1lbnQoXy5hLG51bGwpKSl9O2Z1bmN0aW9uIGxlKGUpe3ZhciB0PWUuaXNzdWUsYT1lLnJlbW92ZVJvdyxvPWUueSx1PWUub25Jc3N1ZUtleVVwZGF0ZWQsYz1lLmppcmFVcmwscz1PYmplY3Qobi51c2VTdGF0ZSkoKSxpPU9iamVjdChtLmEpKHMsMiksbD1pWzBdLGQ9aVsxXTtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoJC5hLHtjb21wb25lbnQ6InRoIixhbGlnbjoiY2VudGVyIixjbGFzc05hbWU6InJvdy1oZWFkZXIifSxyLmEuY3JlYXRlRWxlbWVudCh0ZSx7aXNzdWU6dCxqaXJhVXJsOmMsb25EZWxldGU6ZnVuY3Rpb24oKXtyZXR1cm4gYSh7bnVtOm99KX0sb25LZXlDaGFuZ2U6ZnVuY3Rpb24oZSl7cmV0dXJuIHUobCxkLHQsbyx7a2V5OmV9KX0sb25Db21tZW50Q2hhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiB1KGwsZCx0LG8se2NvbW1lbnQ6ZX0pfX0pKX1mdW5jdGlvbiBtZShlKXt2YXIgdD1lLmlzc3VlLGE9",
                    "ZS55LG49ZS5yZW1vdmVSb3csbz1lLm9uSXNzdWVLZXlVcGRhdGVkLHU9ZS5kYXRhLGM9ZS5zZXRIb3VyVmFsdWUscz1lLmppcmFVcmw7cmV0dXJuIHIuYS5jcmVhdGVFbGVtZW50KEIuYSx7Y2xhc3NOYW1lOmElMj8ib2RkIjoiZXZlbiJ9LHIuYS5jcmVhdGVFbGVtZW50KGxlLHtpc3N1ZTp0LHJlbW92ZVJvdzpuLHk6YSxvbklzc3VlS2V5VXBkYXRlZDpvLGppcmFVcmw6c30pLHUuZGF0ZXMubWFwKChmdW5jdGlvbihlLHQpe3JldHVybiByLmEuY3JlYXRlRWxlbWVudCgkLmEse2tleTp0K2UudG9JU09TdHJpbmcoKSxhbGlnbjoiY2VudGVyIixzdHlsZTp7cG9zaXRpb246InJlbGF0aXZlIn19LHIuYS5jcmVhdGVFbGVtZW50KGllLHtob3VyOnUuaG91cnNbdF1bYV0sc2V0SG91cjpmdW5jdGlvbihlKXtyZXR1cm4gYyh7eDp0LHk6YSxob3VyOmV9KX19KSl9KSksci5hLmNyZWF0ZUVsZW1lbnQoJC5hLHtzdHlsZTp7Zm9udFNpemU6MjAsdGV4dEFsaWduOiJjZW50ZXIiLG1pbldpZHRoOjEwMH0sY2xhc3NOYW1lOiJ0b3RhbCJ9LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHgoZS5ob3Vycy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSkpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0fSksMCkpfSh1LGEpKSl9ZnVuY3Rpb24gZGUoZSl7dmFyIHQ9ZS5kYXRhLGE9ZS5yZW1vdmVSb3csbj1lLm9uSXNzdWVLZXlVcGRhdGVkLG89ZS5zZXRIb3VyVmFsdWUsdT1lLmppcmFVcmw7cmV0dXJuIHIuYS5jcmVhdGVFbGVt",
                    "ZW50KGFlLmEse2NvbXBvbmVudDpudWxsfSx0Lmlzc3Vlcy5tYXAoKGZ1bmN0aW9uKGUsYyl7cmV0dXJuIHIuYS5jcmVhdGVFbGVtZW50KG5lLmEse3RpbWVvdXQ6MWUzLGNsYXNzTmFtZXM6Imlzc3VlLWVsIixrZXk6ZS5yZWFjdEtleX0sci5hLmNyZWF0ZUVsZW1lbnQobWUse2lzc3VlOmUseTpjLHJlbW92ZVJvdzphLG9uSXNzdWVLZXlVcGRhdGVkOm4sZGF0YTp0LHNldEhvdXJWYWx1ZTpvLGppcmFVcmw6dX0pKX0pKSl9YSg5MSk7dmFyIGZlPWEoNDgpLHBlPWEubihmZSk7YSg5Mik7cGUuYS5sb2NhbGUoImZyIik7dmFyIHZlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZGF0ZSxhPU9iamVjdChyZS5hKShlLFsiZGF0ZSJdKTtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoci5hLkZyYWdtZW50LG51bGwsci5hLmNyZWF0ZUVsZW1lbnQoSy5hLE9iamVjdC5hc3NpZ24oe2NsYXNzTmFtZToid29ya0xvZ0RhdGUiLHR5cGU6ImRhdGUiLHZhbHVlOnQudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwxMCksc3R5bGU6e21heFdpZHRoOjE0MH19LGEpKSxyLmEuY3JlYXRlRWxlbWVudCgiZGl2Iix7c3R5bGU6e2ZvbnRTaXplOjIwLG1hcmdpblRvcDo0fX0scGUoKSh0KS5mb3JtYXQoImRkZGQiKSkpfSxoZT1hKDE0MSk7ZnVuY3Rpb24geWUoZSl7dmFyIHQ9ZS54LGE9ZS5kYXRlLG49ZS5yZW1vdmVDb2x1bW4sbz1lLnNldERhdGVWYWx1ZTtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoJC5hLHthbGlnbjoiY2VudGVyIn0sci5hLmNyZWF0ZUVs",
                    "ZW1lbnQoZWUuYSx7Y29sb3I6InNlY29uZGFyeSIsb25DbGljazpmdW5jdGlvbigpe3JldHVybiBuKHtudW06dH0pfX0sci5hLmNyZWF0ZUVsZW1lbnQoWC5hLHtmb250U2l6ZToibGFyZ2UifSkpLHIuYS5jcmVhdGVFbGVtZW50KHZlLHtkYXRlOmEsb25DaGFuZ2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oe251bTp0LGRhdGU6bmV3IERhdGUoZS50YXJnZXQudmFsdWUpfSl9fSkpfWZ1bmN0aW9uIGdlKGUpe3ZhciB0PWUuZGF0YSxhPWUucmVtb3ZlQ29sdW1uLG49ZS5zZXREYXRlVmFsdWUsbz1lLmFkZENvbHVtbjtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoaGUuYSxudWxsLHIuYS5jcmVhdGVFbGVtZW50KEIuYSxudWxsLHIuYS5jcmVhdGVFbGVtZW50KCQuYSxudWxsLHIuYS5jcmVhdGVFbGVtZW50KCJkaXYiLHtzdHlsZTp7bWluV2lkdGg6MTAwLG1pbkhlaWdodDo1MH19LCJceGEwIikpLHQuZGF0ZXMubWFwKChmdW5jdGlvbihlLHQpe3JldHVybiByLmEuY3JlYXRlRWxlbWVudCh5ZSxPYmplY3QuYXNzaWduKHt4OnQsZGF0ZTplLHJlbW92ZUNvbHVtbjphLHNldERhdGVWYWx1ZTpufSx7a2V5OnQrZS50b0lTT1N0cmluZygpfSkpfSkpLHIuYS5jcmVhdGVFbGVtZW50KCQuYSx7c3R5bGU6e2ZvbnRTaXplOjIwLHRleHRBbGlnbjoiY2VudGVyIn0sY2xhc3NOYW1lOiJhZGQtYnV0dG9uIn0sci5hLmNyZWF0ZUVsZW1lbnQoaC5hLHtjb2xvcjoicHJpbWFyeSIsb25DbGljazpvfSxyLmEuY3JlYXRlRWxlbWVudChfLmEse3N0",
                    "eWxlOntmb250U2l6ZTo0MH19KSkpKSl9dmFyIEVlPU9iamVjdChjLmIpKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pLE9iamVjdCh3LmEpKHt9LEgse29uSXNzdWVLZXlVcGRhdGVkOmZ1bmN0aW9uKGUsdCxhLG4scil7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89T2JqZWN0KGwuYSkoaS5hLm1hcmsoKGZ1bmN0aW9uIG8odSxjKXt2YXIgcztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKG8pe2Zvcig7Oylzd2l0Y2goby5wcmV2PW8ubmV4dCl7Y2FzZSAwOmUmJmNsZWFyVGltZW91dChlKSx2b2lkIDAhPT1yLmtleSYmKChudWxsPT09KHM9ci5rZXkpfHx2b2lkIDA9PT1zP3ZvaWQgMDpzLnRyaW0oKS5tYXRjaCgvW0EtWmEtel0rLVswLTldKy8pKT8odShILnNldElzc3VlVmFsdWUoe3k6bixpc3N1ZTpPYmplY3Qody5hKSh7fSxhLHtrZXk6ci5rZXl8fCIiLGZpZWxkczp7c3VtbWFyeToiIn19KX0pKSx0KHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cmV0dXJuIEkocixjLHUsbil9KSwxZTMpKSk6dShILnNldElzc3VlVmFsdWUoe3k6bixpc3N1ZTpPYmplY3Qody5hKSh7fSxhLHtrZXk6ci5rZXl8fCIiLGZpZWxkczp7c3VtbWFyeToiIn19KX0pKSksdm9pZCAwIT09ci5jb21tZW50JiZ1KEguc2V0SXNzdWVWYWx1ZSh7eTpuLGlzc3VlOk9iamVjdCh3LmEpKHt9LGEse3dvcmtMb2dDb21tZW50OnIuY29tbWVudH0pfSkpO2Nhc2UgMzpjYXNlImVuZCI6cmV0dXJuIG8uc3RvcCgpfX0pLG8pfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSx0",
                    "KXtyZXR1cm4gby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpfX0pKSgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kYXRhLGE9ZS5jb25maWcsbj1lLndvcmtzTG9nZ2VkLG89ZS5hZGRSb3csdT1lLmFkZENvbHVtbixjPWUucmVtb3ZlQ29sdW1uLHM9ZS5yZW1vdmVSb3csaT1lLnNldERhdGVWYWx1ZSxsPWUuc2V0SG91clZhbHVlLG09ZS5vbklzc3VlS2V5VXBkYXRlZDtyZXR1cm4gci5hLmNyZWF0ZUVsZW1lbnQoUC5hLHtjb21wb25lbnQ6Wi5hLGVsZXZhdGlvbjozfSxyLmEuY3JlYXRlRWxlbWVudChKLmEse3N0aWNreUhlYWRlcjohMCxzaXplOiJzbWFsbCIsc3R5bGU6e292ZXJmbG93OiJoaWRkZW4ifX0sci5hLmNyZWF0ZUVsZW1lbnQoZ2Use2RhdGE6dCxyZW1vdmVDb2x1bW46YyxzZXREYXRlVmFsdWU6aSxhZGRDb2x1bW46dX0pLHIuYS5jcmVhdGVFbGVtZW50KE0uYSxudWxsLHIuYS5jcmVhdGVFbGVtZW50KGRlLHtkYXRhOnQscmVtb3ZlUm93OnMsb25Jc3N1ZUtleVVwZGF0ZWQ6bSxzZXRIb3VyVmFsdWU6bCxqaXJhVXJsOmEuamlyYVVybH0pLHIuYS5jcmVhdGVFbGVtZW50KHEse2FkZFJvdzpvLGRhdGE6dCx3b3Jrc0xvZ2dlZDpufSkpKSl9KSksa2U9YSgxNDYpLGJlPWEoMTQ3KSx3ZT1hKDE0NSk7ZnVuY3Rpb24gamUoKXtyZXR1cm4gT2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIE9lKCl7cmV0dXJuKE9lPU9iamVjdChsLmEpKGkuYS5tYXJrKChmdW5jdGlvbiBlKCl7cmV0dXJuIGkuYS53cmFwKChm",
                    "dW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpyZXR1cm4gZS5uZXh0PTIsZmV0Y2goImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9zdG9wIix7bWV0aG9kOiJQT1NUIixtb2RlOiJuby1jb3JzIn0pO2Nhc2UgMjp3aW5kb3cub3BlbigiYWJvdXQ6YmxhbmsiLCJfc2VsZiIpLHdpbmRvdy5jbG9zZSgpO2Nhc2UgNDpjYXNlImVuZCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUpfSkpKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBDZT1mdW5jdGlvbigpe3JldHVybiByLmEuY3JlYXRlRWxlbWVudChoLmEse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6amV9LHIuYS5jcmVhdGVFbGVtZW50KHdlLmEsbnVsbCksIiBTdG9wIHRoZSBXZWIgQXBwIil9O3ZhciBTZT1PYmplY3QoYy5iKSgoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSxPYmplY3Qody5hKSh7fSxILHtoYW1zdGVySW1wb3J0OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9T2JqZWN0KGwuYSkoaS5hLm1hcmsoKGZ1bmN0aW9uIGUodCxhKXt2YXIgbixyO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24oZSl7Zm9yKDs7KXN3aXRjaChlLnByZXY9ZS5uZXh0KXtjYXNlIDA6cmV0dXJuIGUubmV4dD0yLGZldGNoKCJodHRwOi8vbG9jYWxob3N0OjgwMDAvaGFtc3RlckV4cG9ydD9oYW1zdGVyRGF5c1RvSW1wb3J0PSIuY29uY2F0KGEoKS5jb25maWcuaGFtc3RlckRheXNUb0ltcG9ydCwiJmlnbm9yZT0iKS5j",
                    "b25jYXQoYSgpLmNvbmZpZy5oYW1zdGVySWdub3JlZENhdGVnb3JpZXMpKTtjYXNlIDI6cmV0dXJuIG49ZS5zZW50LGUubmV4dD01LG4uanNvbigpO2Nhc2UgNTpyZXR1cm4gcj1lLnNlbnQsZS5uZXh0PTgsdChILmltcG9ydEhhbXN0ZXJSZXBvcnQoe2hhbXN0ZXJSZXBvcnQ6cn0pKTtjYXNlIDg6YSgpLmRhdGEuaXNzdWVzLmZvckVhY2goKGZ1bmN0aW9uKGUsbil7ZS5rZXkmJkkoe2tleTplLmtleX0sYSx0LG4pfSkpO2Nhc2UgOTpjYXNlImVuZCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUpfSkpKTtyZXR1cm4gZnVuY3Rpb24odCxhKXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpfX0pKSgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jbGVhckRhdGEsYT1lLmFkZExhc3Q1RGF5cyxuPWUuaGFtc3RlckltcG9ydCxvPWUuY3JlYXRlV29ya0xvZ3MsdT1lLnNldFdvcmtzTG9nZ2VkLGM9ZS5yZXNldEhvdXJzLHM9ZS5jb25maWc7ZnVuY3Rpb24gbSgpe3JldHVybihtPU9iamVjdChsLmEpKGkuYS5tYXJrKChmdW5jdGlvbiBlKCl7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpyZXR1cm4gbygpLGUudDA9dSxlLnQxPWIsZS5uZXh0PTUsRShzKTtjYXNlIDU6ZS50Mj1lLnNlbnQsZS50Mz1zLnVzZXJuYW1lLGUudDQ9KDAsZS50MSkoZS50MixlLnQzKSxlLnQ1PXt3b3Jrc0xvZ2dlZDplLnQ0fSwoMCxlLnQwKShlLnQ1KSxjKCk7Y2FzZSAxMTpjYXNlImVu",
                    "ZCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUpfSkpKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiByLmEuY3JlYXRlRWxlbWVudCgiZGl2Iix7Y2xhc3NOYW1lOiJidG4tcGFydCJ9LHIuYS5jcmVhdGVFbGVtZW50KGguYSx7dmFyaWFudDoiY29udGFpbmVkIixzaXplOiJzbWFsbCIsb25DbGljazp0fSxyLmEuY3JlYXRlRWxlbWVudChYLmEsbnVsbCksIiBDbGVhciB0aGUgZGF0YSIpLHIuYS5jcmVhdGVFbGVtZW50KGguYSx7dmFyaWFudDoiY29udGFpbmVkIixzaXplOiJzbWFsbCIsb25DbGljazphfSxyLmEuY3JlYXRlRWxlbWVudChfLmEsbnVsbCksIiBhZGQgbGFzdCA1IGRheXMiKSxyLmEuY3JlYXRlRWxlbWVudChoLmEse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6bn0sci5hLmNyZWF0ZUVsZW1lbnQoa2UuYSxudWxsKSwiIEltcG9ydCBmcm9tIEhhbXN0ZXIiKSxyLmEuY3JlYXRlRWxlbWVudChDZSxudWxsKSxyLmEuY3JlYXRlRWxlbWVudChoLmEse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsY29sb3I6InNlY29uZGFyeSIsb25DbGljazpmdW5jdGlvbigpe3JldHVybiBtLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19LHIuYS5jcmVhdGVFbGVtZW50KGJlLmEsbnVsbCksIiBMb2cgdGhpcyB3b3JrIGxvZ3MiKSl9KSk7dmFyIHhlPU9iamVjdChjLmIpKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pLEgpKChmdW5jdGlvbigpe3JldHVybiByLmEuY3JlYXRlRWxlbWVudCgiZGl2Iix7Y2xhc3NOYW1l",
                    "OiJtYWluIn0sci5hLmNyZWF0ZUVsZW1lbnQoU2UsbnVsbCksci5hLmNyZWF0ZUVsZW1lbnQoRWUsbnVsbCksci5hLmNyZWF0ZUVsZW1lbnQoVyxudWxsKSxyLmEuY3JlYXRlRWxlbWVudChBLG51bGwpKX0pKTt1LmEucmVuZGVyKHIuYS5jcmVhdGVFbGVtZW50KHIuYS5TdHJpY3RNb2RlLG51bGwsci5hLmNyZWF0ZUVsZW1lbnQoYy5hLHtzdG9yZTpWfSxyLmEuY3JlYXRlRWxlbWVudCh4ZSxudWxsKSkpLGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJyb290IikpfX0sW1s3MywxLDJdXV0pOw=="
                ],
                "static/js/2.deadd244.chunk.js": [
                    "LyohIEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgMi5kZWFkZDI0NC5jaHVuay5qcy5MSUNFTlNFLnR4dCAqLwoodGhpc1sid2VicGFja0pzb25wamlyYS13b3JrLWxvZ2dlciJdPXRoaXNbIndlYnBhY2tKc29ucGppcmEtd29yay1sb2dnZXIiXXx8W10pLnB1c2goW1syXSxbZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9big3NCl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcigpe3JldHVybihyPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPWFyZ3VtZW50c1t0XTtmb3IodmFyIHIgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmKGVbcl09bltyXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKTt2YXIgcj1uKDEzKTtmdW5jdGlvbiBvKGUsdCl7aWYobnVsbD09ZSlyZXR1cm57fTt2YXIgbixvLGk9T2JqZWN0KHIuYSkoZSx0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2ZvcihvPTA7bzxhLmxlbmd0aDtvKyspbj1hW29dLHQuaW5kZXhPZihuKT49MHx8T2JqZWN0LnByb3Rv",
                    "dHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsbikmJihpW25dPWVbbl0pfXJldHVybiBpfX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3ZhciB0LG4sbz0iIjtpZigic3RyaW5nIj09PXR5cGVvZiBlfHwibnVtYmVyIj09PXR5cGVvZiBlKW8rPWU7ZWxzZSBpZigib2JqZWN0Ij09PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYobj1yKGVbdF0pKSYmKG8mJihvKz0iICIpLG8rPW4pO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobyYmKG8rPSIgIiksbys9dCk7cmV0dXJuIG99dC5hPWZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQsbj0wLG89IiI7bjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbbisrXSkmJih0PXIoZSkpJiYobyYmKG8rPSIgIiksbys9dCk7cmV0dXJuIG99fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMSksbz1uKDIpLGk9bigwKSxhPW4ubihpKSxsPShuKDUpLG4oMzYpKSx1PW4ubihsKSxzPSJmdW5jdGlvbiI9PT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmImZ1bmN0aW9uIj09PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSxjPSJvYmplY3QiPT09KCJ1",
                    "bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdz8idW5kZWZpbmVkIjpzKHdpbmRvdykpJiYib2JqZWN0Ij09PSgidW5kZWZpbmVkIj09PXR5cGVvZiBkb2N1bWVudD8idW5kZWZpbmVkIjpzKGRvY3VtZW50KSkmJjk9PT1kb2N1bWVudC5ub2RlVHlwZTt2YXIgZD1uKDM1KSxmPW4oMjEpLHA9bigzOCksaD1uKDEzKSxtPXt9LmNvbnN0cnVjdG9yO2Z1bmN0aW9uIHYoZSl7aWYobnVsbD09ZXx8Im9iamVjdCIhPT10eXBlb2YgZSlyZXR1cm4gZTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlLm1hcCh2KTtpZihlLmNvbnN0cnVjdG9yIT09bSlyZXR1cm4gZTt2YXIgdD17fTtmb3IodmFyIG4gaW4gZSl0W25dPXYoZVtuXSk7cmV0dXJuIHR9ZnVuY3Rpb24gYihlLHQsbil7dm9pZCAwPT09ZSYmKGU9InVubmFtZWQiKTt2YXIgcj1uLmpzcyxvPXYodCksaT1yLnBsdWdpbnMub25DcmVhdGVSdWxlKGUsbyxuKTtyZXR1cm4gaXx8KGVbMF0sbnVsbCl9dmFyIHk9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49IiIscj0wO3I8ZS5sZW5ndGgmJiIhaW1wb3J0YW50IiE9PWVbcl07cisrKW4mJihuKz10KSxuKz1lW3JdO3JldHVybiBufTtmdW5jdGlvbiBnKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLCFBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO3ZhciBuPSIiO2lmKEFycmF5LmlzQXJyYXkoZVswXSkpZm9yKHZhciByPTA7cjxlLmxlbmd0aCYmIiFpbXBvcnRhbnQiIT09ZVtyXTtyKyspbiYmKG4rPSIsICIpLG4rPXkoZVtyXSwiICIp",
                    "O2Vsc2Ugbj15KGUsIiwgIik7cmV0dXJuIHR8fCIhaW1wb3J0YW50IiE9PWVbZS5sZW5ndGgtMV18fChuKz0iICFpbXBvcnRhbnQiKSxufWZ1bmN0aW9uIHcoZSx0KXtmb3IodmFyIG49IiIscj0wO3I8dDtyKyspbis9IiAgIjtyZXR1cm4gbitlfWZ1bmN0aW9uIHgoZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcj0iIjtpZighdClyZXR1cm4gcjt2YXIgbz1uLmluZGVudCxpPXZvaWQgMD09PW8/MDpvLGE9dC5mYWxsYmFja3M7aWYoZSYmaSsrLGEpaWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGw9MDtsPGEubGVuZ3RoO2wrKyl7dmFyIHU9YVtsXTtmb3IodmFyIHMgaW4gdSl7dmFyIGM9dVtzXTtudWxsIT1jJiYociYmKHIrPSJcbiIpLHIrPSIiK3cocysiOiAiK2coYykrIjsiLGkpKX19ZWxzZSBmb3IodmFyIGQgaW4gYSl7dmFyIGY9YVtkXTtudWxsIT1mJiYociYmKHIrPSJcbiIpLHIrPSIiK3coZCsiOiAiK2coZikrIjsiLGkpKX1mb3IodmFyIHAgaW4gdCl7dmFyIGg9dFtwXTtudWxsIT1oJiYiZmFsbGJhY2tzIiE9PXAmJihyJiYocis9IlxuIikscis9IiIrdyhwKyI6ICIrZyhoKSsiOyIsaSkpfXJldHVybihyfHxuLmFsbG93RW1wdHkpJiZlPyhyJiYocj0iXG4iK3IrIlxuIiksdyhlKyIgeyIrciwtLWkpK3coIn0iLGkpKTpyfXZhciBFPS8oW1tcXS4jKiQ+PCt+PXxeOigpLCInYFxzXSkvZyxPPSJ1bmRlZmluZWQiIT09dHlwZW9mIENTUyYmQ1NTLmVzY2FwZSxrPWZ1bmN0aW9uKGUpe3JldHVybiBPP08o",
                    "ZSk6ZS5yZXBsYWNlKEUsIlxcJDEiKX0sUz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMudHlwZT0ic3R5bGUiLHRoaXMua2V5PXZvaWQgMCx0aGlzLmlzUHJvY2Vzc2VkPSExLHRoaXMuc3R5bGU9dm9pZCAwLHRoaXMucmVuZGVyZXI9dm9pZCAwLHRoaXMucmVuZGVyYWJsZT12b2lkIDAsdGhpcy5vcHRpb25zPXZvaWQgMDt2YXIgcj1uLnNoZWV0LG89bi5SZW5kZXJlcjt0aGlzLmtleT1lLHRoaXMub3B0aW9ucz1uLHRoaXMuc3R5bGU9dCxyP3RoaXMucmVuZGVyZXI9ci5yZW5kZXJlcjpvJiYodGhpcy5yZW5kZXJlcj1uZXcgbyl9cmV0dXJuIGUucHJvdG90eXBlLnByb3A9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuc3R5bGVbZV07dmFyIHI9ISFuJiZuLmZvcmNlO2lmKCFyJiZ0aGlzLnN0eWxlW2VdPT09dClyZXR1cm4gdGhpczt2YXIgbz10O24mJiExPT09bi5wcm9jZXNzfHwobz10aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh0LGUsdGhpcykpO3ZhciBpPW51bGw9PW98fCExPT09byxhPWUgaW4gdGhpcy5zdHlsZTtpZihpJiYhYSYmIXIpcmV0dXJuIHRoaXM7dmFyIGw9aSYmYTtpZihsP2RlbGV0ZSB0aGlzLnN0eWxlW2VdOnRoaXMuc3R5bGVbZV09byx0aGlzLnJlbmRlcmFibGUmJnRoaXMucmVuZGVyZXIpcmV0dXJuIGw/dGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsZSk6dGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0",
                    "eSh0aGlzLnJlbmRlcmFibGUsZSxvKSx0aGlzO3ZhciB1PXRoaXMub3B0aW9ucy5zaGVldDtyZXR1cm4gdSYmdS5hdHRhY2hlZCx0aGlzfSxlfSgpLEM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4scil7dmFyIG87KG89ZS5jYWxsKHRoaXMsdCxuLHIpfHx0aGlzKS5zZWxlY3RvclRleHQ9dm9pZCAwLG8uaWQ9dm9pZCAwLG8ucmVuZGVyYWJsZT12b2lkIDA7dmFyIGk9ci5zZWxlY3RvcixhPXIuc2NvcGVkLGw9ci5zaGVldCx1PXIuZ2VuZXJhdGVJZDtyZXR1cm4gaT9vLnNlbGVjdG9yVGV4dD1pOiExIT09YSYmKG8uaWQ9dShPYmplY3QocC5hKShPYmplY3QocC5hKShvKSksbCksby5zZWxlY3RvclRleHQ9Ii4iK2soby5pZCkpLG99T2JqZWN0KGYuYSkodCxlKTt2YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5hcHBseVRvPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucmVuZGVyZXI7aWYodCl7dmFyIG49dGhpcy50b0pTT04oKTtmb3IodmFyIHIgaW4gbil0LnNldFByb3BlcnR5KGUscixuW3JdKX1yZXR1cm4gdGhpc30sbi50b0pTT049ZnVuY3Rpb24oKXt2YXIgZT17fTtmb3IodmFyIHQgaW4gdGhpcy5zdHlsZSl7dmFyIG49dGhpcy5zdHlsZVt0XTsib2JqZWN0IiE9PXR5cGVvZiBuP2VbdF09bjpBcnJheS5pc0FycmF5KG4pJiYoZVt0XT1nKG4pKX1yZXR1cm4gZX0sbi50b1N0cmluZz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLm9wdGlvbnMuc2hlZXQsbj0hIXQmJnQub3B0aW9ucy5saW5rP09iamVjdChyLmEpKHt9LGUs",
                    "e2FsbG93RW1wdHk6ITB9KTplO3JldHVybiB4KHRoaXMuc2VsZWN0b3JUZXh0LHRoaXMuc3R5bGUsbil9LE9iamVjdChkLmEpKHQsW3trZXk6InNlbGVjdG9yIixzZXQ6ZnVuY3Rpb24oZSl7aWYoZSE9PXRoaXMuc2VsZWN0b3JUZXh0KXt0aGlzLnNlbGVjdG9yVGV4dD1lO3ZhciB0PXRoaXMucmVuZGVyZXIsbj10aGlzLnJlbmRlcmFibGU7aWYobiYmdCl0LnNldFNlbGVjdG9yKG4sZSl8fHQucmVwbGFjZVJ1bGUobix0aGlzKX19LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdG9yVGV4dH19XSksdH0oUyksaj17b25DcmVhdGVSdWxlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4iQCI9PT1lWzBdfHxuLnBhcmVudCYmImtleWZyYW1lcyI9PT1uLnBhcmVudC50eXBlP251bGw6bmV3IEMoZSx0LG4pfX0sVD17aW5kZW50OjEsY2hpbGRyZW46ITB9LFA9L0AoW1x3LV0rKS8sUj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMudHlwZT0iY29uZGl0aW9uYWwiLHRoaXMuYXQ9dm9pZCAwLHRoaXMua2V5PXZvaWQgMCx0aGlzLnF1ZXJ5PXZvaWQgMCx0aGlzLnJ1bGVzPXZvaWQgMCx0aGlzLm9wdGlvbnM9dm9pZCAwLHRoaXMuaXNQcm9jZXNzZWQ9ITEsdGhpcy5yZW5kZXJhYmxlPXZvaWQgMCx0aGlzLmtleT1lLHRoaXMucXVlcnk9bi5uYW1lO3ZhciBvPWUubWF0Y2goUCk7Zm9yKHZhciBpIGluIHRoaXMuYXQ9bz9vWzFdOiJ1bmtub3duIix0aGlzLm9wdGlvbnM9bix0aGlzLnJ1bGVzPW5ldyBaKE9iamVjdChy",
                    "LmEpKHt9LG4se3BhcmVudDp0aGlzfSkpLHQpdGhpcy5ydWxlcy5hZGQoaSx0W2ldKTt0aGlzLnJ1bGVzLnByb2Nlc3MoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRSdWxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJ1bGVzLmdldChlKX0sdC5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YoZSl9LHQuYWRkUnVsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5ydWxlcy5hZGQoZSx0LG4pO3JldHVybiByPyh0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShyKSxyKTpudWxsfSx0LnRvU3RyaW5nPWZ1bmN0aW9uKGUpe2lmKHZvaWQgMD09PWUmJihlPVQpLG51bGw9PWUuaW5kZW50JiYoZS5pbmRlbnQ9VC5pbmRlbnQpLG51bGw9PWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPVQuY2hpbGRyZW4pLCExPT09ZS5jaGlsZHJlbilyZXR1cm4gdGhpcy5xdWVyeSsiIHt9Ijt2YXIgdD10aGlzLnJ1bGVzLnRvU3RyaW5nKGUpO3JldHVybiB0P3RoaXMucXVlcnkrIiB7XG4iK3QrIlxufSI6IiJ9LGV9KCksTj0vQG1lZGlhfEBzdXBwb3J0c1xzKy8sTT17b25DcmVhdGVSdWxlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gTi50ZXN0KGUpP25ldyBSKGUsdCxuKTpudWxsfX0sXz17aW5kZW50OjEsY2hpbGRyZW46ITB9LEE9L0BrZXlmcmFtZXNccysoW1x3LV0rKS8sST1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMudHlwZT0ia2V5ZnJhbWVzIix0aGlzLmF0",
                    "PSJAa2V5ZnJhbWVzIix0aGlzLmtleT12b2lkIDAsdGhpcy5uYW1lPXZvaWQgMCx0aGlzLmlkPXZvaWQgMCx0aGlzLnJ1bGVzPXZvaWQgMCx0aGlzLm9wdGlvbnM9dm9pZCAwLHRoaXMuaXNQcm9jZXNzZWQ9ITEsdGhpcy5yZW5kZXJhYmxlPXZvaWQgMDt2YXIgbz1lLm1hdGNoKEEpO28mJm9bMV0/dGhpcy5uYW1lPW9bMV06dGhpcy5uYW1lPSJub25hbWUiLHRoaXMua2V5PXRoaXMudHlwZSsiLSIrdGhpcy5uYW1lLHRoaXMub3B0aW9ucz1uO3ZhciBpPW4uc2NvcGVkLGE9bi5zaGVldCxsPW4uZ2VuZXJhdGVJZDtmb3IodmFyIHUgaW4gdGhpcy5pZD0hMT09PWk/dGhpcy5uYW1lOmsobCh0aGlzLGEpKSx0aGlzLnJ1bGVzPW5ldyBaKE9iamVjdChyLmEpKHt9LG4se3BhcmVudDp0aGlzfSkpLHQpdGhpcy5ydWxlcy5hZGQodSx0W3VdLE9iamVjdChyLmEpKHt9LG4se3BhcmVudDp0aGlzfSkpO3RoaXMucnVsZXMucHJvY2VzcygpfXJldHVybiBlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lJiYoZT1fKSxudWxsPT1lLmluZGVudCYmKGUuaW5kZW50PV8uaW5kZW50KSxudWxsPT1lLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1fLmNoaWxkcmVuKSwhMT09PWUuY2hpbGRyZW4pcmV0dXJuIHRoaXMuYXQrIiAiK3RoaXMuaWQrIiB7fSI7dmFyIHQ9dGhpcy5ydWxlcy50b1N0cmluZyhlKTtyZXR1cm4gdCYmKHQ9IlxuIit0KyJcbiIpLHRoaXMuYXQrIiAiK3RoaXMuaWQrIiB7Iit0KyJ9In0sZX0oKSxE",
                    "PS9Aa2V5ZnJhbWVzXHMrLyx6PS9cJChbXHctXSspL2csTD1mdW5jdGlvbihlLHQpe3JldHVybiJzdHJpbmciPT09dHlwZW9mIGU/ZS5yZXBsYWNlKHosKGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4gaW4gdD90W25dOmV9KSk6ZX0sRj1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZVt0XSxvPUwocixuKTtvIT09ciYmKGVbdF09byl9LCQ9e29uQ3JlYXRlUnVsZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuInN0cmluZyI9PT10eXBlb2YgZSYmRC50ZXN0KGUpP25ldyBJKGUsdCxuKTpudWxsfSxvblByb2Nlc3NTdHlsZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuInN0eWxlIj09PXQudHlwZSYmbj8oImFuaW1hdGlvbi1uYW1lImluIGUmJkYoZSwiYW5pbWF0aW9uLW5hbWUiLG4ua2V5ZnJhbWVzKSwiYW5pbWF0aW9uImluIGUmJkYoZSwiYW5pbWF0aW9uIixuLmtleWZyYW1lcyksZSk6ZX0sb25DaGFuZ2VWYWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI9bi5vcHRpb25zLnNoZWV0O2lmKCFyKXJldHVybiBlO3N3aXRjaCh0KXtjYXNlImFuaW1hdGlvbiI6Y2FzZSJhbmltYXRpb24tbmFtZSI6cmV0dXJuIEwoZSxyLmtleWZyYW1lcyk7ZGVmYXVsdDpyZXR1cm4gZX19fSxXPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtmb3IodmFyIHQsbj1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KG4pLG89MDtvPG47bysrKXJbb109YXJndW1lbnRzW29dO3JldHVybih0PWUuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQocikpfHx0aGlzKS5yZW5k",
                    "ZXJhYmxlPXZvaWQgMCx0fXJldHVybiBPYmplY3QoZi5hKSh0LGUpLHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMub3B0aW9ucy5zaGVldCxuPSEhdCYmdC5vcHRpb25zLmxpbms/T2JqZWN0KHIuYSkoe30sZSx7YWxsb3dFbXB0eTohMH0pOmU7cmV0dXJuIHgodGhpcy5rZXksdGhpcy5zdHlsZSxuKX0sdH0oUyksQj17b25DcmVhdGVSdWxlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbi5wYXJlbnQmJiJrZXlmcmFtZXMiPT09bi5wYXJlbnQudHlwZT9uZXcgVyhlLHQsbik6bnVsbH19LEg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuKXt0aGlzLnR5cGU9ImZvbnQtZmFjZSIsdGhpcy5hdD0iQGZvbnQtZmFjZSIsdGhpcy5rZXk9dm9pZCAwLHRoaXMuc3R5bGU9dm9pZCAwLHRoaXMub3B0aW9ucz12b2lkIDAsdGhpcy5pc1Byb2Nlc3NlZD0hMSx0aGlzLnJlbmRlcmFibGU9dm9pZCAwLHRoaXMua2V5PWUsdGhpcy5zdHlsZT10LHRoaXMub3B0aW9ucz1ufXJldHVybiBlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KHRoaXMuc3R5bGUpKXtmb3IodmFyIHQ9IiIsbj0wO248dGhpcy5zdHlsZS5sZW5ndGg7bisrKXQrPXgodGhpcy5hdCx0aGlzLnN0eWxlW25dKSx0aGlzLnN0eWxlW24rMV0mJih0Kz0iXG4iKTtyZXR1cm4gdH1yZXR1cm4geCh0aGlzLmF0LHRoaXMuc3R5bGUsZSl9LGV9KCksVj0vQGZvbnQtZmFjZS8sVT17b25DcmVhdGVSdWxlOmZ1bmN0",
                    "aW9uKGUsdCxuKXtyZXR1cm4gVi50ZXN0KGUpP25ldyBIKGUsdCxuKTpudWxsfX0scT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMudHlwZT0idmlld3BvcnQiLHRoaXMuYXQ9IkB2aWV3cG9ydCIsdGhpcy5rZXk9dm9pZCAwLHRoaXMuc3R5bGU9dm9pZCAwLHRoaXMub3B0aW9ucz12b2lkIDAsdGhpcy5pc1Byb2Nlc3NlZD0hMSx0aGlzLnJlbmRlcmFibGU9dm9pZCAwLHRoaXMua2V5PWUsdGhpcy5zdHlsZT10LHRoaXMub3B0aW9ucz1ufXJldHVybiBlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlKXtyZXR1cm4geCh0aGlzLmtleSx0aGlzLnN0eWxlLGUpfSxlfSgpLEs9e29uQ3JlYXRlUnVsZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIkB2aWV3cG9ydCI9PT1lfHwiQC1tcy12aWV3cG9ydCI9PT1lP25ldyBxKGUsdCxuKTpudWxsfX0sWT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMudHlwZT0ic2ltcGxlIix0aGlzLmtleT12b2lkIDAsdGhpcy52YWx1ZT12b2lkIDAsdGhpcy5vcHRpb25zPXZvaWQgMCx0aGlzLmlzUHJvY2Vzc2VkPSExLHRoaXMucmVuZGVyYWJsZT12b2lkIDAsdGhpcy5rZXk9ZSx0aGlzLnZhbHVlPXQsdGhpcy5vcHRpb25zPW59cmV0dXJuIGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpe2Zvcih2YXIgdD0iIixuPTA7bjx0aGlzLnZhbHVlLmxlbmd0aDtuKyspdCs9dGhpcy5rZXkrIiAiK3RoaXMudmFs",
                    "dWVbbl0rIjsiLHRoaXMudmFsdWVbbisxXSYmKHQrPSJcbiIpO3JldHVybiB0fXJldHVybiB0aGlzLmtleSsiICIrdGhpcy52YWx1ZSsiOyJ9LGV9KCksUT17IkBjaGFyc2V0IjohMCwiQGltcG9ydCI6ITAsIkBuYW1lc3BhY2UiOiEwfSxYPVtqLE0sJCxCLFUsSyx7b25DcmVhdGVSdWxlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZSBpbiBRP25ldyBZKGUsdCxuKTpudWxsfX1dLEc9e3Byb2Nlc3M6ITB9LEo9e2ZvcmNlOiEwLHByb2Nlc3M6ITB9LFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMubWFwPXt9LHRoaXMucmF3PXt9LHRoaXMuaW5kZXg9W10sdGhpcy5jb3VudGVyPTAsdGhpcy5vcHRpb25zPXZvaWQgMCx0aGlzLmNsYXNzZXM9dm9pZCAwLHRoaXMua2V5ZnJhbWVzPXZvaWQgMCx0aGlzLm9wdGlvbnM9ZSx0aGlzLmNsYXNzZXM9ZS5jbGFzc2VzLHRoaXMua2V5ZnJhbWVzPWUua2V5ZnJhbWVzfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmFkZD1mdW5jdGlvbihlLHQsbil7dmFyIG89dGhpcy5vcHRpb25zLGk9by5wYXJlbnQsYT1vLnNoZWV0LGw9by5qc3MsdT1vLlJlbmRlcmVyLHM9by5nZW5lcmF0ZUlkLGM9by5zY29wZWQsZD1PYmplY3Qoci5hKSh7Y2xhc3Nlczp0aGlzLmNsYXNzZXMscGFyZW50Omksc2hlZXQ6YSxqc3M6bCxSZW5kZXJlcjp1LGdlbmVyYXRlSWQ6cyxzY29wZWQ6YyxuYW1lOmUsa2V5ZnJhbWVzOnRoaXMua2V5ZnJhbWVzLHNlbGVjdG9yOnZvaWQgMH0sbiksZj1lO2UgaW4gdGhp",
                    "cy5yYXcmJihmPWUrIi1kIit0aGlzLmNvdW50ZXIrKyksdGhpcy5yYXdbZl09dCxmIGluIHRoaXMuY2xhc3NlcyYmKGQuc2VsZWN0b3I9Ii4iK2sodGhpcy5jbGFzc2VzW2ZdKSk7dmFyIHA9YihmLHQsZCk7aWYoIXApcmV0dXJuIG51bGw7dGhpcy5yZWdpc3RlcihwKTt2YXIgaD12b2lkIDA9PT1kLmluZGV4P3RoaXMuaW5kZXgubGVuZ3RoOmQuaW5kZXg7cmV0dXJuIHRoaXMuaW5kZXguc3BsaWNlKGgsMCxwKSxwfSx0LmdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5tYXBbZV19LHQucmVtb3ZlPWZ1bmN0aW9uKGUpe3RoaXMudW5yZWdpc3RlcihlKSxkZWxldGUgdGhpcy5yYXdbZS5rZXldLHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihlKSwxKX0sdC5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmluZGV4LmluZGV4T2YoZSl9LHQucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBlPXRoaXMub3B0aW9ucy5qc3MucGx1Z2luczt0aGlzLmluZGV4LnNsaWNlKDApLmZvckVhY2goZS5vblByb2Nlc3NSdWxlLGUpfSx0LnJlZ2lzdGVyPWZ1bmN0aW9uKGUpe3RoaXMubWFwW2Uua2V5XT1lLGUgaW5zdGFuY2VvZiBDPyh0aGlzLm1hcFtlLnNlbGVjdG9yXT1lLGUuaWQmJih0aGlzLmNsYXNzZXNbZS5rZXldPWUuaWQpKTplIGluc3RhbmNlb2YgSSYmdGhpcy5rZXlmcmFtZXMmJih0aGlzLmtleWZyYW1lc1tlLm5hbWVdPWUuaWQpfSx0LnVucmVnaXN0ZXI9ZnVuY3Rpb24oZSl7ZGVsZXRlIHRoaXMubWFw",
                    "W2Uua2V5XSxlIGluc3RhbmNlb2YgQz8oZGVsZXRlIHRoaXMubWFwW2Uuc2VsZWN0b3JdLGRlbGV0ZSB0aGlzLmNsYXNzZXNbZS5rZXldKTplIGluc3RhbmNlb2YgSSYmZGVsZXRlIHRoaXMua2V5ZnJhbWVzW2UubmFtZV19LHQudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGUsdCxuO2lmKCJzdHJpbmciPT09dHlwZW9mKGFyZ3VtZW50cy5sZW5ndGg8PTA/dm9pZCAwOmFyZ3VtZW50c1swXSk/KGU9YXJndW1lbnRzLmxlbmd0aDw9MD92b2lkIDA6YXJndW1lbnRzWzBdLHQ9YXJndW1lbnRzLmxlbmd0aDw9MT92b2lkIDA6YXJndW1lbnRzWzFdLG49YXJndW1lbnRzLmxlbmd0aDw9Mj92b2lkIDA6YXJndW1lbnRzWzJdKToodD1hcmd1bWVudHMubGVuZ3RoPD0wP3ZvaWQgMDphcmd1bWVudHNbMF0sbj1hcmd1bWVudHMubGVuZ3RoPD0xP3ZvaWQgMDphcmd1bWVudHNbMV0sZT1udWxsKSxlKXRoaXMudXBkYXRlT25lKHRoaXMubWFwW2VdLHQsbik7ZWxzZSBmb3IodmFyIHI9MDtyPHRoaXMuaW5kZXgubGVuZ3RoO3IrKyl0aGlzLnVwZGF0ZU9uZSh0aGlzLmluZGV4W3JdLHQsbil9LHQudXBkYXRlT25lPWZ1bmN0aW9uKHQsbixyKXt2b2lkIDA9PT1yJiYocj1HKTt2YXIgbz10aGlzLm9wdGlvbnMsaT1vLmpzcy5wbHVnaW5zLGE9by5zaGVldDtpZih0LnJ1bGVzIGluc3RhbmNlb2YgZSl0LnJ1bGVzLnVwZGF0ZShuLHIpO2Vsc2V7dmFyIGw9dCx1PWwuc3R5bGU7aWYoaS5vblVwZGF0ZShuLHQsYSxyKSxyLnByb2Nlc3MmJnUmJnUhPT1s",
                    "LnN0eWxlKXtmb3IodmFyIHMgaW4gaS5vblByb2Nlc3NTdHlsZShsLnN0eWxlLGwsYSksbC5zdHlsZSl7dmFyIGM9bC5zdHlsZVtzXTtjIT09dVtzXSYmbC5wcm9wKHMsYyxKKX1mb3IodmFyIGQgaW4gdSl7dmFyIGY9bC5zdHlsZVtkXSxwPXVbZF07bnVsbD09ZiYmZiE9PXAmJmwucHJvcChkLG51bGwsSil9fX19LHQudG9TdHJpbmc9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PSIiLG49dGhpcy5vcHRpb25zLnNoZWV0LHI9ISFuJiZuLm9wdGlvbnMubGluayxvPTA7bzx0aGlzLmluZGV4Lmxlbmd0aDtvKyspe3ZhciBpPXRoaXMuaW5kZXhbb10udG9TdHJpbmcoZSk7KGl8fHIpJiYodCYmKHQrPSJcbiIpLHQrPWkpfXJldHVybiB0fSxlfSgpLGVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbiBpbiB0aGlzLm9wdGlvbnM9dm9pZCAwLHRoaXMuZGVwbG95ZWQ9dm9pZCAwLHRoaXMuYXR0YWNoZWQ9dm9pZCAwLHRoaXMucnVsZXM9dm9pZCAwLHRoaXMucmVuZGVyZXI9dm9pZCAwLHRoaXMuY2xhc3Nlcz12b2lkIDAsdGhpcy5rZXlmcmFtZXM9dm9pZCAwLHRoaXMucXVldWU9dm9pZCAwLHRoaXMuYXR0YWNoZWQ9ITEsdGhpcy5kZXBsb3llZD0hMSx0aGlzLmNsYXNzZXM9e30sdGhpcy5rZXlmcmFtZXM9e30sdGhpcy5vcHRpb25zPU9iamVjdChyLmEpKHt9LHQse3NoZWV0OnRoaXMscGFyZW50OnRoaXMsY2xhc3Nlczp0aGlzLmNsYXNzZXMsa2V5ZnJhbWVzOnRoaXMua2V5ZnJhbWVzfSksdC5SZW5kZXJlciYmKHRo",
                    "aXMucmVuZGVyZXI9bmV3IHQuUmVuZGVyZXIodGhpcykpLHRoaXMucnVsZXM9bmV3IFoodGhpcy5vcHRpb25zKSxlKXRoaXMucnVsZXMuYWRkKG4sZVtuXSk7dGhpcy5ydWxlcy5wcm9jZXNzKCl9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuYXR0YWNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXR0YWNoZWR8fCh0aGlzLnJlbmRlcmVyJiZ0aGlzLnJlbmRlcmVyLmF0dGFjaCgpLHRoaXMuYXR0YWNoZWQ9ITAsdGhpcy5kZXBsb3llZHx8dGhpcy5kZXBsb3koKSksdGhpc30sdC5kZXRhY2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdHRhY2hlZD8odGhpcy5yZW5kZXJlciYmdGhpcy5yZW5kZXJlci5kZXRhY2goKSx0aGlzLmF0dGFjaGVkPSExLHRoaXMpOnRoaXN9LHQuYWRkUnVsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5xdWV1ZTt0aGlzLmF0dGFjaGVkJiYhciYmKHRoaXMucXVldWU9W10pO3ZhciBvPXRoaXMucnVsZXMuYWRkKGUsdCxuKTtyZXR1cm4gbz8odGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUobyksdGhpcy5hdHRhY2hlZD90aGlzLmRlcGxveWVkPyhyP3IucHVzaChvKToodGhpcy5pbnNlcnRSdWxlKG8pLHRoaXMucXVldWUmJih0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLHRoaXMpLHRoaXMucXVldWU9dm9pZCAwKSksbyk6bzoodGhpcy5kZXBsb3llZD0hMSxvKSk6bnVsbH0sdC5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUpe3RoaXMucmVuZGVyZXImJnRoaXMu",
                    "cmVuZGVyZXIuaW5zZXJ0UnVsZShlKX0sdC5hZGRSdWxlcz1mdW5jdGlvbihlLHQpe3ZhciBuPVtdO2Zvcih2YXIgciBpbiBlKXt2YXIgbz10aGlzLmFkZFJ1bGUocixlW3JdLHQpO28mJm4ucHVzaChvKX1yZXR1cm4gbn0sdC5nZXRSdWxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJ1bGVzLmdldChlKX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3ZhciB0PSJvYmplY3QiPT09dHlwZW9mIGU/ZTp0aGlzLnJ1bGVzLmdldChlKTtyZXR1cm4hIXQmJih0aGlzLnJ1bGVzLnJlbW92ZSh0KSwhKHRoaXMuYXR0YWNoZWQmJnQucmVuZGVyYWJsZSYmdGhpcy5yZW5kZXJlcil8fHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZSh0LnJlbmRlcmFibGUpKX0sdC5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YoZSl9LHQuZGVwbG95PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVuZGVyZXImJnRoaXMucmVuZGVyZXIuZGVwbG95KCksdGhpcy5kZXBsb3llZD0hMCx0aGlzfSx0LnVwZGF0ZT1mdW5jdGlvbigpe3ZhciBlO3JldHVybihlPXRoaXMucnVsZXMpLnVwZGF0ZS5hcHBseShlLGFyZ3VtZW50cyksdGhpc30sdC51cGRhdGVPbmU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnJ1bGVzLnVwZGF0ZU9uZShlLHQsbiksdGhpc30sdC50b1N0cmluZz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZyhlKX0sZX0oKSx0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLnBsdWdp",
                    "bnM9e2ludGVybmFsOltdLGV4dGVybmFsOltdfSx0aGlzLnJlZ2lzdHJ5PXZvaWQgMH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5vbkNyZWF0ZVJ1bGU9ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj0wO3I8dGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoO3IrKyl7dmFyIG89dGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbcl0oZSx0LG4pO2lmKG8pcmV0dXJuIG99cmV0dXJuIG51bGx9LHQub25Qcm9jZXNzUnVsZT1mdW5jdGlvbihlKXtpZighZS5pc1Byb2Nlc3NlZCl7Zm9yKHZhciB0PWUub3B0aW9ucy5zaGVldCxuPTA7bjx0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGUubGVuZ3RoO24rKyl0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbbl0oZSx0KTtlLnN0eWxlJiZ0aGlzLm9uUHJvY2Vzc1N0eWxlKGUuc3R5bGUsZSx0KSxlLmlzUHJvY2Vzc2VkPSEwfX0sdC5vblByb2Nlc3NTdHlsZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjx0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlLmxlbmd0aDtyKyspdC5zdHlsZT10aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlW3JdKHQuc3R5bGUsdCxuKX0sdC5vblByb2Nlc3NTaGVldD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXQubGVuZ3RoO3QrKyl0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W3RdKGUpfSx0Lm9uVXBkYXRlPWZ1bmN0aW9uKGUsdCxuLHIpe2Zvcih2YXIgbz0wO288dGhp",
                    "cy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7bysrKXRoaXMucmVnaXN0cnkub25VcGRhdGVbb10oZSx0LG4scil9LHQub25DaGFuZ2VWYWx1ZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPWUsbz0wO288dGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDtvKyspcj10aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWVbb10ocix0LG4pO3JldHVybiByfSx0LnVzZT1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXtxdWV1ZToiZXh0ZXJuYWwifSk7dmFyIG49dGhpcy5wbHVnaW5zW3QucXVldWVdOy0xPT09bi5pbmRleE9mKGUpJiYobi5wdXNoKGUpLHRoaXMucmVnaXN0cnk9W10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCx0aGlzLnBsdWdpbnMuaW50ZXJuYWwpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gdCluIGluIGUmJmVbbl0ucHVzaCh0W25dKTtyZXR1cm4gZX0pLHtvbkNyZWF0ZVJ1bGU6W10sb25Qcm9jZXNzUnVsZTpbXSxvblByb2Nlc3NTdHlsZTpbXSxvblByb2Nlc3NTaGVldDpbXSxvbkNoYW5nZVZhbHVlOltdLG9uVXBkYXRlOltdfSkpfSxlfSgpLG5lPW5ldyhmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLnJlZ2lzdHJ5PVtdfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmFkZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnJlZ2lzdHJ5LG49ZS5vcHRpb25zLmluZGV4O2lmKC0xPT09dC5pbmRleE9mKGUpKWlmKDA9PT10Lmxlbmd0aHx8bj49dGhpcy5pbmRleCl0",
                    "LnB1c2goZSk7ZWxzZSBmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdLm9wdGlvbnMuaW5kZXg+bilyZXR1cm4gdm9pZCB0LnNwbGljZShyLDAsZSl9LHQucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnJlZ2lzdHJ5PVtdfSx0LnJlbW92ZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnJlZ2lzdHJ5LmluZGV4T2YoZSk7dGhpcy5yZWdpc3RyeS5zcGxpY2UodCwxKX0sdC50b1N0cmluZz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dm9pZCAwPT09ZT97fTplLG49dC5hdHRhY2hlZCxyPU9iamVjdChoLmEpKHQsWyJhdHRhY2hlZCJdKSxvPSIiLGk9MDtpPHRoaXMucmVnaXN0cnkubGVuZ3RoO2krKyl7dmFyIGE9dGhpcy5yZWdpc3RyeVtpXTtudWxsIT1uJiZhLmF0dGFjaGVkIT09bnx8KG8mJihvKz0iXG4iKSxvKz1hLnRvU3RyaW5nKHIpKX1yZXR1cm4gb30sT2JqZWN0KGQuYSkoZSxbe2tleToiaW5kZXgiLGdldDpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5yZWdpc3RyeS5sZW5ndGg/MDp0aGlzLnJlZ2lzdHJ5W3RoaXMucmVnaXN0cnkubGVuZ3RoLTFdLm9wdGlvbnMuaW5kZXh9fV0pLGV9KCkpLHJlPSJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6InVuZGVmaW5lZCIhPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLG9lPSIyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYiI7bnVsbD09cmVbb2VdJiYo",
                    "cmVbb2VdPTApO3ZhciBpZT1yZVtvZV0rKyxhZT1mdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHQ9MDtyZXR1cm4gZnVuY3Rpb24obixyKXt0Kz0xO3ZhciBvPSIiLGk9IiI7cmV0dXJuIHImJihyLm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4JiYoaT1yLm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSxudWxsIT1yLm9wdGlvbnMuanNzLmlkJiYobz1TdHJpbmcoci5vcHRpb25zLmpzcy5pZCkpKSxlLm1pbmlmeT8iIisoaXx8ImMiKStpZStvK3Q6aStuLmtleSsiLSIraWUrKG8/Ii0iK286IiIpKyItIit0fX0sbGU9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR8fCh0PWUoKSksdH19O2Z1bmN0aW9uIHVlKGUsdCl7dHJ5e3JldHVybiBlLmF0dHJpYnV0ZVN0eWxlTWFwP2UuYXR0cmlidXRlU3R5bGVNYXAuZ2V0KHQpOmUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0KX1jYXRjaChuKXtyZXR1cm4iIn19ZnVuY3Rpb24gc2UoZSx0LG4pe3RyeXt2YXIgcj1uO2lmKEFycmF5LmlzQXJyYXkobikmJihyPWcobiwhMCksIiFpbXBvcnRhbnQiPT09bltuLmxlbmd0aC0xXSkpcmV0dXJuIGUuc3R5bGUuc2V0UHJvcGVydHkodCxyLCJpbXBvcnRhbnQiKSwhMDtlLmF0dHJpYnV0ZVN0eWxlTWFwP2UuYXR0cmlidXRlU3R5bGVNYXAuc2V0KHQscik6ZS5zdHlsZS5zZXRQcm9wZXJ0eSh0LHIpfWNhdGNoKG8pe3JldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIGNlKGUsdCl7dHJ5e2UuYXR0cmlidXRl",
                    "U3R5bGVNYXA/ZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUodCk6ZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KX1jYXRjaChuKXt9fWZ1bmN0aW9uIGRlKGUsdCl7cmV0dXJuIGUuc2VsZWN0b3JUZXh0PXQsZS5zZWxlY3RvclRleHQ9PT10fXZhciBmZT1sZSgoZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiaGVhZCIpfSkpO2Z1bmN0aW9uIHBlKGUpe3ZhciB0PW5lLnJlZ2lzdHJ5O2lmKHQubGVuZ3RoPjApe3ZhciBuPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07aWYoci5hdHRhY2hlZCYmci5vcHRpb25zLmluZGV4PnQuaW5kZXgmJnIub3B0aW9ucy5pbnNlcnRpb25Qb2ludD09PXQuaW5zZXJ0aW9uUG9pbnQpcmV0dXJuIHJ9cmV0dXJuIG51bGx9KHQsZSk7aWYobiYmbi5yZW5kZXJlcilyZXR1cm57cGFyZW50Om4ucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLG5vZGU6bi5yZW5kZXJlci5lbGVtZW50fTtpZigobj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXt2YXIgcj1lW25dO2lmKHIuYXR0YWNoZWQmJnIub3B0aW9ucy5pbnNlcnRpb25Qb2ludD09PXQuaW5zZXJ0aW9uUG9pbnQpcmV0dXJuIHJ9cmV0dXJuIG51bGx9KHQsZSkpJiZuLnJlbmRlcmVyKXJldHVybntwYXJlbnQ6bi5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsbm9kZTpuLnJlbmRlcmVyLmVsZW1lbnQubmV4dFNpYmxpbmd9fXZhciBy",
                    "PWUuaW5zZXJ0aW9uUG9pbnQ7aWYociYmInN0cmluZyI9PT10eXBlb2Ygcil7dmFyIG89ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWZlKCksbj0wO248dC5jaGlsZE5vZGVzLmxlbmd0aDtuKyspe3ZhciByPXQuY2hpbGROb2Rlc1tuXTtpZig4PT09ci5ub2RlVHlwZSYmci5ub2RlVmFsdWUudHJpbSgpPT09ZSlyZXR1cm4gcn1yZXR1cm4gbnVsbH0ocik7aWYobylyZXR1cm57cGFyZW50Om8ucGFyZW50Tm9kZSxub2RlOm8ubmV4dFNpYmxpbmd9fXJldHVybiExfXZhciBoZT1sZSgoZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PSJjc3Atbm9uY2UiXScpO3JldHVybiBlP2UuZ2V0QXR0cmlidXRlKCJjb250ZW50Iik6bnVsbH0pKSxtZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZS5jc3NSdWxlcy5sZW5ndGg7KHZvaWQgMD09PW58fG4+cikmJihuPXIpO3RyeXtpZigiaW5zZXJ0UnVsZSJpbiBlKWUuaW5zZXJ0UnVsZSh0LG4pO2Vsc2UgaWYoImFwcGVuZFJ1bGUiaW4gZSl7ZS5hcHBlbmRSdWxlKHQpfX1jYXRjaChvKXtyZXR1cm4hMX1yZXR1cm4gZS5jc3NSdWxlc1tuXX0sdmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZ2V0UHJvcGVydHlWYWx1ZT11ZSx0aGlzLnNldFByb3BlcnR5PXNlLHRoaXMucmVtb3ZlUHJvcGVydHk9Y2UsdGhpcy5zZXRTZWxlY3Rvcj1kZSx0aGlzLmVsZW1lbnQ9dm9pZCAwLHRoaXMuc2hlZXQ9dm9pZCAwLHRoaXMuaGFzSW5zZXJ0ZWRSdWxl",
                    "cz0hMSxlJiZuZS5hZGQoZSksdGhpcy5zaGVldD1lO3ZhciB0PXRoaXMuc2hlZXQ/dGhpcy5zaGVldC5vcHRpb25zOnt9LG49dC5tZWRpYSxyPXQubWV0YSxvPXQuZWxlbWVudDt0aGlzLmVsZW1lbnQ9b3x8ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO3JldHVybiBlLnRleHRDb250ZW50PSJcbiIsZX0oKSx0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCJkYXRhLWpzcyIsIiIpLG4mJnRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoIm1lZGlhIixuKSxyJiZ0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCJkYXRhLW1ldGEiLHIpO3ZhciBpPWhlKCk7aSYmdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgibm9uY2UiLGkpfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmF0dGFjaD1mdW5jdGlvbigpe2lmKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5zaGVldCl7IWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbnNlcnRpb25Qb2ludCxyPXBlKHQpO2lmKCExIT09ciYmci5wYXJlbnQpci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGUsci5ub2RlKTtlbHNlIGlmKG4mJiJudW1iZXIiPT09dHlwZW9mIG4ubm9kZVR5cGUpe3ZhciBvPW4saT1vLnBhcmVudE5vZGU7aSYmaS5pbnNlcnRCZWZvcmUoZSxvLm5leHRTaWJsaW5nKX1lbHNlIGZlKCkuYXBwZW5kQ2hpbGQoZSl9KHRoaXMuZWxlbWVudCx0aGlzLnNoZWV0Lm9wdGlvbnMpO3ZhciBlPUJvb2xlYW4odGhpcy5zaGVldCYmdGhpcy5zaGVl",
                    "dC5kZXBsb3llZCk7dGhpcy5oYXNJbnNlcnRlZFJ1bGVzJiZlJiYodGhpcy5oYXNJbnNlcnRlZFJ1bGVzPSExLHRoaXMuZGVwbG95KCkpfX0sdC5kZXRhY2g9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtlJiZlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCl9LHQuZGVwbG95PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zaGVldDtlJiYoZS5vcHRpb25zLmxpbms/dGhpcy5pbnNlcnRSdWxlcyhlLnJ1bGVzKTp0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQ9IlxuIitlLnRvU3RyaW5nKCkrIlxuIil9LHQuaW5zZXJ0UnVsZXM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPGUuaW5kZXgubGVuZ3RoO24rKyl0aGlzLmluc2VydFJ1bGUoZS5pbmRleFtuXSxuLHQpfSx0Lmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PW4mJihuPXRoaXMuZWxlbWVudC5zaGVldCksZS5ydWxlcyl7dmFyIHI9ZSxvPW47cmV0dXJuKCJjb25kaXRpb25hbCIhPT1lLnR5cGUmJiJrZXlmcmFtZXMiIT09ZS50eXBlfHwhMSE9PShvPW1lKG4sci50b1N0cmluZyh7Y2hpbGRyZW46ITF9KSx0KSkpJiYodGhpcy5pbnNlcnRSdWxlcyhyLnJ1bGVzLG8pLG8pfWlmKGUucmVuZGVyYWJsZSYmZS5yZW5kZXJhYmxlLnBhcmVudFN0eWxlU2hlZXQ9PT10aGlzLmVsZW1lbnQuc2hlZXQpcmV0dXJuIGUucmVuZGVyYWJsZTt2YXIgaT1lLnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuITE7dmFyIGE9bWUobixpLHQpO3JldHVy",
                    "biExIT09YSYmKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcz0hMCxlLnJlbmRlcmFibGU9YSxhKX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZWxlbWVudC5zaGVldCxuPXRoaXMuaW5kZXhPZihlKTtyZXR1cm4tMSE9PW4mJih0LmRlbGV0ZVJ1bGUobiksITApfSx0LmluZGV4T2Y9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcyxuPTA7bjx0Lmxlbmd0aDtuKyspaWYoZT09PXRbbl0pcmV0dXJuIG47cmV0dXJuLTF9LHQucmVwbGFjZVJ1bGU9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmluZGV4T2YoZSk7cmV0dXJuLTEhPT1uJiYodGhpcy5lbGVtZW50LnNoZWV0LmRlbGV0ZVJ1bGUobiksdGhpcy5pbnNlcnRSdWxlKHQsbikpfSx0LmdldFJ1bGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlc30sZX0oKSxiZT0wLHllPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmlkPWJlKyssdGhpcy52ZXJzaW9uPSIxMC40LjAiLHRoaXMucGx1Z2lucz1uZXcgdGUsdGhpcy5vcHRpb25zPXtpZDp7bWluaWZ5OiExfSxjcmVhdGVHZW5lcmF0ZUlkOmFlLFJlbmRlcmVyOmM/dmU6bnVsbCxwbHVnaW5zOltdfSx0aGlzLmdlbmVyYXRlSWQ9YWUoe21pbmlmeTohMX0pO2Zvcih2YXIgdD0wO3Q8WC5sZW5ndGg7dCsrKXRoaXMucGx1Z2lucy51c2UoWFt0XSx7cXVldWU6ImludGVybmFsIn0pO3RoaXMuc2V0dXAoZSl9dmFyIHQ9ZS5wcm90b3R5",
                    "cGU7cmV0dXJuIHQuc2V0dXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxlLmNyZWF0ZUdlbmVyYXRlSWQmJih0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZD1lLmNyZWF0ZUdlbmVyYXRlSWQpLGUuaWQmJih0aGlzLm9wdGlvbnMuaWQ9T2JqZWN0KHIuYSkoe30sdGhpcy5vcHRpb25zLmlkLGUuaWQpKSwoZS5jcmVhdGVHZW5lcmF0ZUlkfHxlLmlkKSYmKHRoaXMuZ2VuZXJhdGVJZD10aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCh0aGlzLm9wdGlvbnMuaWQpKSxudWxsIT1lLmluc2VydGlvblBvaW50JiYodGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50PWUuaW5zZXJ0aW9uUG9pbnQpLCJSZW5kZXJlciJpbiBlJiYodGhpcy5vcHRpb25zLlJlbmRlcmVyPWUuUmVuZGVyZXIpLGUucGx1Z2lucyYmdGhpcy51c2UuYXBwbHkodGhpcyxlLnBsdWdpbnMpLHRoaXN9LHQuY3JlYXRlU3R5bGVTaGVldD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgbj10LmluZGV4OyJudW1iZXIiIT09dHlwZW9mIG4mJihuPTA9PT1uZS5pbmRleD8wOm5lLmluZGV4KzEpO3ZhciBvPW5ldyBlZShlLE9iamVjdChyLmEpKHt9LHQse2pzczp0aGlzLGdlbmVyYXRlSWQ6dC5nZW5lcmF0ZUlkfHx0aGlzLmdlbmVyYXRlSWQsaW5zZXJ0aW9uUG9pbnQ6dGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50LFJlbmRlcmVyOnRoaXMub3B0aW9ucy5SZW5kZXJlcixpbmRleDpufSkpO3JldHVybiB0aGlzLnBs",
                    "dWdpbnMub25Qcm9jZXNzU2hlZXQobyksb30sdC5yZW1vdmVTdHlsZVNoZWV0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmRldGFjaCgpLG5lLnJlbW92ZShlKSx0aGlzfSx0LmNyZWF0ZVJ1bGU9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PXQmJih0PXt9KSx2b2lkIDA9PT1uJiYobj17fSksIm9iamVjdCI9PT10eXBlb2YgZSlyZXR1cm4gdGhpcy5jcmVhdGVSdWxlKHZvaWQgMCxlLHQpO3ZhciBvPU9iamVjdChyLmEpKHt9LG4se25hbWU6ZSxqc3M6dGhpcyxSZW5kZXJlcjp0aGlzLm9wdGlvbnMuUmVuZGVyZXJ9KTtvLmdlbmVyYXRlSWR8fChvLmdlbmVyYXRlSWQ9dGhpcy5nZW5lcmF0ZUlkKSxvLmNsYXNzZXN8fChvLmNsYXNzZXM9e30pLG8ua2V5ZnJhbWVzfHwoby5rZXlmcmFtZXM9e30pO3ZhciBpPWIoZSx0LG8pO3JldHVybiBpJiZ0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShpKSxpfSx0LnVzZT1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0KSxyPTA7cjx0O3IrKyluW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnBsdWdpbnMudXNlKHQpfSkpLHRoaXN9LGV9KCk7dmFyIGdlPSJ1bmRlZmluZWQiIT09dHlwZW9mIENTUyYmQ1NTJiYibnVtYmVyImluIENTUyx3ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHllKGUpfSx4ZT0od2UoKSxuKDEyNikpLEVlPXtzZXQ6ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89ZS5nZXQo",
                    "dCk7b3x8KG89bmV3IE1hcCxlLnNldCh0LG8pKSxvLnNldChuLHIpfSxnZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUuZ2V0KHQpO3JldHVybiByP3IuZ2V0KG4pOnZvaWQgMH0sZGVsZXRlOmZ1bmN0aW9uKGUsdCxuKXtlLmdldCh0KS5kZWxldGUobil9fSxPZT1uKDk1KSxrZT0iZnVuY3Rpb24iPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcj9TeW1ib2wuZm9yKCJtdWkubmVzdGVkIik6Il9fVEhFTUVfTkVTVEVEX18iLFNlPVsiY2hlY2tlZCIsImRpc2FibGVkIiwiZXJyb3IiLCJmb2N1c2VkIiwiZm9jdXNWaXNpYmxlIiwicmVxdWlyZWQiLCJleHBhbmRlZCIsInNlbGVjdGVkIl07dmFyIENlPURhdGUubm93KCksamU9ImZuVmFsdWVzIitDZSxUZT0iZm5TdHlsZSIrICsrQ2U7dmFyIFBlPWZ1bmN0aW9uKCl7cmV0dXJue29uQ3JlYXRlUnVsZTpmdW5jdGlvbihlLHQsbil7aWYoImZ1bmN0aW9uIiE9PXR5cGVvZiB0KXJldHVybiBudWxsO3ZhciByPWIoZSx7fSxuKTtyZXR1cm4gcltUZV09dCxyfSxvblByb2Nlc3NTdHlsZTpmdW5jdGlvbihlLHQpe2lmKGplIGluIHR8fFRlIGluIHQpcmV0dXJuIGU7dmFyIG49e307Zm9yKHZhciByIGluIGUpe3ZhciBvPWVbcl07ImZ1bmN0aW9uIj09PXR5cGVvZiBvJiYoZGVsZXRlIGVbcl0sbltyXT1vKX1yZXR1cm4gdFtqZV09bixlfSxvblVwZGF0ZTpmdW5jdGlvbihlLHQsbixyKXt2YXIgbz10LGk9b1tUZV07aSYmKG8uc3R5bGU9aShlKXx8e30pO3ZhciBhPW9bamVdO2lmKGEp",
                    "Zm9yKHZhciBsIGluIGEpby5wcm9wKGwsYVtsXShlKSxyKX19fSxSZT0iQGdsb2JhbCIsTmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuKXtmb3IodmFyIG8gaW4gdGhpcy50eXBlPSJnbG9iYWwiLHRoaXMuYXQ9UmUsdGhpcy5ydWxlcz12b2lkIDAsdGhpcy5vcHRpb25zPXZvaWQgMCx0aGlzLmtleT12b2lkIDAsdGhpcy5pc1Byb2Nlc3NlZD0hMSx0aGlzLmtleT1lLHRoaXMub3B0aW9ucz1uLHRoaXMucnVsZXM9bmV3IFooT2JqZWN0KHIuYSkoe30sbix7cGFyZW50OnRoaXN9KSksdCl0aGlzLnJ1bGVzLmFkZChvLHRbb10pO3RoaXMucnVsZXMucHJvY2VzcygpfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucnVsZXMuZ2V0KGUpfSx0LmFkZFJ1bGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucnVsZXMuYWRkKGUsdCxuKTtyZXR1cm4gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocikscn0sdC5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YoZSl9LHQudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZygpfSxlfSgpLE1lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsbil7dGhpcy50eXBlPSJnbG9iYWwiLHRoaXMuYXQ9UmUsdGhpcy5vcHRpb25zPXZvaWQgMCx0aGlzLnJ1bGU9dm9pZCAwLHRoaXMuaXNQcm9jZXNzZWQ9ITEsdGhpcy5rZXk9dm9pZCAwLHRoaXMu",
                    "a2V5PWUsdGhpcy5vcHRpb25zPW47dmFyIG89ZS5zdWJzdHIoIkBnbG9iYWwgIi5sZW5ndGgpO3RoaXMucnVsZT1uLmpzcy5jcmVhdGVSdWxlKG8sdCxPYmplY3Qoci5hKSh7fSxuLHtwYXJlbnQ6dGhpc30pKX1yZXR1cm4gZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucnVsZT90aGlzLnJ1bGUudG9TdHJpbmcoZSk6IiJ9LGV9KCksX2U9L1xzKixccyovZztmdW5jdGlvbiBBZShlLHQpe2Zvcih2YXIgbj1lLnNwbGl0KF9lKSxyPSIiLG89MDtvPG4ubGVuZ3RoO28rKylyKz10KyIgIituW29dLnRyaW0oKSxuW28rMV0mJihyKz0iLCAiKTtyZXR1cm4gcn12YXIgSWU9ZnVuY3Rpb24oKXtyZXR1cm57b25DcmVhdGVSdWxlOmZ1bmN0aW9uKGUsdCxuKXtpZighZSlyZXR1cm4gbnVsbDtpZihlPT09UmUpcmV0dXJuIG5ldyBOZShlLHQsbik7aWYoIkAiPT09ZVswXSYmIkBnbG9iYWwgIj09PWUuc3Vic3RyKDAsIkBnbG9iYWwgIi5sZW5ndGgpKXJldHVybiBuZXcgTWUoZSx0LG4pO3ZhciByPW4ucGFyZW50O3JldHVybiByJiYoImdsb2JhbCI9PT1yLnR5cGV8fHIub3B0aW9ucy5wYXJlbnQmJiJnbG9iYWwiPT09ci5vcHRpb25zLnBhcmVudC50eXBlKSYmKG4uc2NvcGVkPSExKSwhMT09PW4uc2NvcGVkJiYobi5zZWxlY3Rvcj1lKSxudWxsfSxvblByb2Nlc3NSdWxlOmZ1bmN0aW9uKGUpeyJzdHlsZSI9PT1lLnR5cGUmJihmdW5jdGlvbihlKXt2YXIgdD1lLm9wdGlvbnMsbj1lLnN0eWxlLG89bj9u",
                    "W1JlXTpudWxsO2lmKG8pe2Zvcih2YXIgaSBpbiBvKXQuc2hlZXQuYWRkUnVsZShpLG9baV0sT2JqZWN0KHIuYSkoe30sdCx7c2VsZWN0b3I6QWUoaSxlLnNlbGVjdG9yKX0pKTtkZWxldGUgbltSZV19fShlKSxmdW5jdGlvbihlKXt2YXIgdD1lLm9wdGlvbnMsbj1lLnN0eWxlO2Zvcih2YXIgbyBpbiBuKWlmKCJAIj09PW9bMF0mJm8uc3Vic3RyKDAsUmUubGVuZ3RoKT09PVJlKXt2YXIgaT1BZShvLnN1YnN0cihSZS5sZW5ndGgpLGUuc2VsZWN0b3IpO3Quc2hlZXQuYWRkUnVsZShpLG5bb10sT2JqZWN0KHIuYSkoe30sdCx7c2VsZWN0b3I6aX0pKSxkZWxldGUgbltvXX19KGUpKX19fSxEZT0vXHMqLFxzKi9nLHplPS8mL2csTGU9L1wkKFtcdy1dKykvZzt2YXIgRmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4scil7dmFyIG89ZS5nZXRSdWxlKHIpfHx0JiZ0LmdldFJ1bGUocik7cmV0dXJuIG8/KG89bykuc2VsZWN0b3I6cn19ZnVuY3Rpb24gdChlLHQpe2Zvcih2YXIgbj10LnNwbGl0KERlKSxyPWUuc3BsaXQoRGUpLG89IiIsaT0wO2k8bi5sZW5ndGg7aSsrKWZvcih2YXIgYT1uW2ldLGw9MDtsPHIubGVuZ3RoO2wrKyl7dmFyIHU9cltsXTtvJiYobys9IiwgIiksbys9LTEhPT11LmluZGV4T2YoIiYiKT91LnJlcGxhY2UoemUsYSk6YSsiICIrdX1yZXR1cm4gb31mdW5jdGlvbiBuKGUsdCxuKXtpZihuKXJldHVybiBPYmplY3Qoci5hKSh7fSxuLHtpbmRleDpuLmluZGV4KzF9KTt2YXIg",
                    "bz1lLm9wdGlvbnMubmVzdGluZ0xldmVsO289dm9pZCAwPT09bz8xOm8rMTt2YXIgaT1PYmplY3Qoci5hKSh7fSxlLm9wdGlvbnMse25lc3RpbmdMZXZlbDpvLGluZGV4OnQuaW5kZXhPZihlKSsxfSk7cmV0dXJuIGRlbGV0ZSBpLm5hbWUsaX1yZXR1cm57b25Qcm9jZXNzU3R5bGU6ZnVuY3Rpb24obyxpLGEpe2lmKCJzdHlsZSIhPT1pLnR5cGUpcmV0dXJuIG87dmFyIGwsdSxzPWksYz1zLm9wdGlvbnMucGFyZW50O2Zvcih2YXIgZCBpbiBvKXt2YXIgZj0tMSE9PWQuaW5kZXhPZigiJiIpLHA9IkAiPT09ZFswXTtpZihmfHxwKXtpZihsPW4ocyxjLGwpLGYpe3ZhciBoPXQoZCxzLnNlbGVjdG9yKTt1fHwodT1lKGMsYSkpLGg9aC5yZXBsYWNlKExlLHUpLGMuYWRkUnVsZShoLG9bZF0sT2JqZWN0KHIuYSkoe30sbCx7c2VsZWN0b3I6aH0pKX1lbHNlIHAmJmMuYWRkUnVsZShkLHt9LGwpLmFkZFJ1bGUocy5rZXksb1tkXSx7c2VsZWN0b3I6cy5zZWxlY3Rvcn0pO2RlbGV0ZSBvW2RdfX1yZXR1cm4gb319fSwkZT0vW0EtWl0vZyxXZT0vXm1zLS8sQmU9e307ZnVuY3Rpb24gSGUoZSl7cmV0dXJuIi0iK2UudG9Mb3dlckNhc2UoKX12YXIgVmU9ZnVuY3Rpb24oZSl7aWYoQmUuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIEJlW2VdO3ZhciB0PWUucmVwbGFjZSgkZSxIZSk7cmV0dXJuIEJlW2VdPVdlLnRlc3QodCk/Ii0iK3Q6dH07ZnVuY3Rpb24gVWUoZSl7dmFyIHQ9e307Zm9yKHZhciBuIGluIGUpe3RbMD09PW4uaW5kZXhPZigi",
                    "LS0iKT9uOlZlKG4pXT1lW25dfXJldHVybiBlLmZhbGxiYWNrcyYmKEFycmF5LmlzQXJyYXkoZS5mYWxsYmFja3MpP3QuZmFsbGJhY2tzPWUuZmFsbGJhY2tzLm1hcChVZSk6dC5mYWxsYmFja3M9VWUoZS5mYWxsYmFja3MpKSx0fXZhciBxZT1mdW5jdGlvbigpe3JldHVybntvblByb2Nlc3NTdHlsZTpmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdPVVlKGVbdF0pO3JldHVybiBlfXJldHVybiBVZShlKX0sb25DaGFuZ2VWYWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoMD09PXQuaW5kZXhPZigiLS0iKSlyZXR1cm4gZTt2YXIgcj1WZSh0KTtyZXR1cm4gdD09PXI/ZToobi5wcm9wKHIsZSksbnVsbCl9fX0sS2U9Z2UmJkNTUz9DU1MucHg6InB4IixZZT1nZSYmQ1NTP0NTUy5tczoibXMiLFFlPWdlJiZDU1M/Q1NTLnBlcmNlbnQ6IiUiO2Z1bmN0aW9uIFhlKGUpe3ZhciB0PS8oLVthLXpdKS9nLG49ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV0udG9VcHBlckNhc2UoKX0scj17fTtmb3IodmFyIG8gaW4gZSlyW29dPWVbb10scltvLnJlcGxhY2UodCxuKV09ZVtvXTtyZXR1cm4gcn12YXIgR2U9WGUoeyJhbmltYXRpb24tZGVsYXkiOlllLCJhbmltYXRpb24tZHVyYXRpb24iOlllLCJiYWNrZ3JvdW5kLXBvc2l0aW9uIjpLZSwiYmFja2dyb3VuZC1wb3NpdGlvbi14IjpLZSwiYmFja2dyb3VuZC1wb3NpdGlvbi15IjpLZSwiYmFja2dyb3VuZC1zaXplIjpLZSxib3JkZXI6",
                    "S2UsImJvcmRlci1ib3R0b20iOktlLCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIjpLZSwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMiOktlLCJib3JkZXItYm90dG9tLXdpZHRoIjpLZSwiYm9yZGVyLWxlZnQiOktlLCJib3JkZXItbGVmdC13aWR0aCI6S2UsImJvcmRlci1yYWRpdXMiOktlLCJib3JkZXItcmlnaHQiOktlLCJib3JkZXItcmlnaHQtd2lkdGgiOktlLCJib3JkZXItdG9wIjpLZSwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cyI6S2UsImJvcmRlci10b3AtcmlnaHQtcmFkaXVzIjpLZSwiYm9yZGVyLXRvcC13aWR0aCI6S2UsImJvcmRlci13aWR0aCI6S2UsbWFyZ2luOktlLCJtYXJnaW4tYm90dG9tIjpLZSwibWFyZ2luLWxlZnQiOktlLCJtYXJnaW4tcmlnaHQiOktlLCJtYXJnaW4tdG9wIjpLZSxwYWRkaW5nOktlLCJwYWRkaW5nLWJvdHRvbSI6S2UsInBhZGRpbmctbGVmdCI6S2UsInBhZGRpbmctcmlnaHQiOktlLCJwYWRkaW5nLXRvcCI6S2UsIm1hc2stcG9zaXRpb24teCI6S2UsIm1hc2stcG9zaXRpb24teSI6S2UsIm1hc2stc2l6ZSI6S2UsaGVpZ2h0OktlLHdpZHRoOktlLCJtaW4taGVpZ2h0IjpLZSwibWF4LWhlaWdodCI6S2UsIm1pbi13aWR0aCI6S2UsIm1heC13aWR0aCI6S2UsYm90dG9tOktlLGxlZnQ6S2UsdG9wOktlLHJpZ2h0OktlLCJib3gtc2hhZG93IjpLZSwidGV4dC1zaGFkb3ciOktlLCJjb2x1bW4tZ2FwIjpLZSwiY29sdW1uLXJ1bGUiOktlLCJjb2x1bW4tcnVsZS13aWR0aCI6S2Us",
                    "ImNvbHVtbi13aWR0aCI6S2UsImZvbnQtc2l6ZSI6S2UsImZvbnQtc2l6ZS1kZWx0YSI6S2UsImxldHRlci1zcGFjaW5nIjpLZSwidGV4dC1pbmRlbnQiOktlLCJ0ZXh0LXN0cm9rZSI6S2UsInRleHQtc3Ryb2tlLXdpZHRoIjpLZSwid29yZC1zcGFjaW5nIjpLZSxtb3Rpb246S2UsIm1vdGlvbi1vZmZzZXQiOktlLG91dGxpbmU6S2UsIm91dGxpbmUtb2Zmc2V0IjpLZSwib3V0bGluZS13aWR0aCI6S2UscGVyc3BlY3RpdmU6S2UsInBlcnNwZWN0aXZlLW9yaWdpbi14IjpRZSwicGVyc3BlY3RpdmUtb3JpZ2luLXkiOlFlLCJ0cmFuc2Zvcm0tb3JpZ2luIjpRZSwidHJhbnNmb3JtLW9yaWdpbi14IjpRZSwidHJhbnNmb3JtLW9yaWdpbi15IjpRZSwidHJhbnNmb3JtLW9yaWdpbi16IjpRZSwidHJhbnNpdGlvbi1kZWxheSI6WWUsInRyYW5zaXRpb24tZHVyYXRpb24iOlllLCJ2ZXJ0aWNhbC1hbGlnbiI6S2UsImZsZXgtYmFzaXMiOktlLCJzaGFwZS1tYXJnaW4iOktlLHNpemU6S2UsZ3JpZDpLZSwiZ3JpZC1nYXAiOktlLCJncmlkLXJvdy1nYXAiOktlLCJncmlkLWNvbHVtbi1nYXAiOktlLCJncmlkLXRlbXBsYXRlLXJvd3MiOktlLCJncmlkLXRlbXBsYXRlLWNvbHVtbnMiOktlLCJncmlkLWF1dG8tcm93cyI6S2UsImdyaWQtYXV0by1jb2x1bW5zIjpLZSwiYm94LXNoYWRvdy14IjpLZSwiYm94LXNoYWRvdy15IjpLZSwiYm94LXNoYWRvdy1ibHVyIjpLZSwiYm94LXNoYWRvdy1zcHJlYWQiOktlLCJmb250LWxpbmUtaGVpZ2h0",
                    "IjpLZSwidGV4dC1zaGFkb3cteCI6S2UsInRleHQtc2hhZG93LXkiOktlLCJ0ZXh0LXNoYWRvdy1ibHVyIjpLZX0pO2Z1bmN0aW9uIEplKGUsdCxuKXtpZighdClyZXR1cm4gdDtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXRbcl09SmUoZSx0W3JdLG4pO2Vsc2UgaWYoIm9iamVjdCI9PT10eXBlb2YgdClpZigiZmFsbGJhY2tzIj09PWUpZm9yKHZhciBvIGluIHQpdFtvXT1KZShvLHRbb10sbik7ZWxzZSBmb3IodmFyIGkgaW4gdCl0W2ldPUplKGUrIi0iK2ksdFtpXSxuKTtlbHNlIGlmKCJudW1iZXIiPT09dHlwZW9mIHQpe3ZhciBhPW5bZV18fEdlW2VdO3JldHVybiBhPyJmdW5jdGlvbiI9PT10eXBlb2YgYT9hKHQpLnRvU3RyaW5nKCk6IiIrdCthOnQudG9TdHJpbmcoKX1yZXR1cm4gdH12YXIgWmU9ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciB0PVhlKGUpO3JldHVybntvblByb2Nlc3NTdHlsZTpmdW5jdGlvbihlLG4pe2lmKCJzdHlsZSIhPT1uLnR5cGUpcmV0dXJuIGU7Zm9yKHZhciByIGluIGUpZVtyXT1KZShyLGVbcl0sdCk7cmV0dXJuIGV9LG9uQ2hhbmdlVmFsdWU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gSmUobixlLHQpfX19LGV0PW4oMjQpLHR0PSIiLG50PSIiLHJ0PSIiLG90PSIiLGl0PWMmJiJvbnRvdWNoc3RhcnQiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2lmKGMpe3ZhciBhdD17TW96OiItbW96LSIsbXM6Ii1tcy0iLE86Ii1vLSIsV2Via2l0",
                    "OiItd2Via2l0LSJ9LGx0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInAiKS5zdHlsZTtmb3IodmFyIHV0IGluIGF0KWlmKHV0KyJUcmFuc2Zvcm0iaW4gbHQpe3R0PXV0LG50PWF0W3V0XTticmVha30iV2Via2l0Ij09PXR0JiYibXNIeXBoZW5zImluIGx0JiYodHQ9Im1zIixudD1hdC5tcyxvdD0iZWRnZSIpLCJXZWJraXQiPT09dHQmJiItYXBwbGUtdHJhaWxpbmctd29yZCJpbiBsdCYmKHJ0PSJhcHBsZSIpfXZhciBzdD10dCxjdD1udCxkdD1ydCxmdD1vdCxwdD1pdDt2YXIgaHQ9e25vUHJlZmlsbDpbImFwcGVhcmFuY2UiXSxzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlKXtyZXR1cm4iYXBwZWFyYW5jZSI9PT1lJiYoIm1zIj09PXN0PyItd2Via2l0LSIrZTpjdCtlKX19LG10PXtub1ByZWZpbGw6WyJjb2xvci1hZGp1c3QiXSxzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlKXtyZXR1cm4iY29sb3ItYWRqdXN0Ij09PWUmJigiV2Via2l0Ij09PXN0P2N0KyJwcmludC0iK2U6ZSl9fSx2dD0vWy1cc10rKC4pPy9nO2Z1bmN0aW9uIGJ0KGUsdCl7cmV0dXJuIHQ/dC50b1VwcGVyQ2FzZSgpOiIifWZ1bmN0aW9uIHl0KGUpe3JldHVybiBlLnJlcGxhY2UodnQsYnQpfWZ1bmN0aW9uIGd0KGUpe3JldHVybiB5dCgiLSIrZSl9dmFyIHd0LHh0PXtub1ByZWZpbGw6WyJtYXNrIl0sc3VwcG9ydGVkUHJvcGVydHk6ZnVuY3Rpb24oZSx0KXtpZighL15tYXNrLy50ZXN0KGUpKXJldHVybiExO2lmKCJXZWJraXQiPT09c3Qpe2lm",
                    "KHl0KCJtYXNrLWltYWdlIilpbiB0KXJldHVybiBlO2lmKHN0K2d0KCJtYXNrLWltYWdlIilpbiB0KXJldHVybiBjdCtlfXJldHVybiBlfX0sRXQ9e25vUHJlZmlsbDpbInRleHQtb3JpZW50YXRpb24iXSxzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlKXtyZXR1cm4idGV4dC1vcmllbnRhdGlvbiI9PT1lJiYoImFwcGxlIiE9PWR0fHxwdD9lOmN0K2UpfX0sT3Q9e25vUHJlZmlsbDpbInRyYW5zZm9ybSJdLHN1cHBvcnRlZFByb3BlcnR5OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4idHJhbnNmb3JtIj09PWUmJihuLnRyYW5zZm9ybT9lOmN0K2UpfX0sa3Q9e25vUHJlZmlsbDpbInRyYW5zaXRpb24iXSxzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlLHQsbil7cmV0dXJuInRyYW5zaXRpb24iPT09ZSYmKG4udHJhbnNpdGlvbj9lOmN0K2UpfX0sU3Q9e25vUHJlZmlsbDpbIndyaXRpbmctbW9kZSJdLHN1cHBvcnRlZFByb3BlcnR5OmZ1bmN0aW9uKGUpe3JldHVybiJ3cml0aW5nLW1vZGUiPT09ZSYmKCJXZWJraXQiPT09c3R8fCJtcyI9PT1zdCYmImVkZ2UiIT09ZnQ/Y3QrZTplKX19LEN0PXtub1ByZWZpbGw6WyJ1c2VyLXNlbGVjdCJdLHN1cHBvcnRlZFByb3BlcnR5OmZ1bmN0aW9uKGUpe3JldHVybiJ1c2VyLXNlbGVjdCI9PT1lJiYoIk1veiI9PT1zdHx8Im1zIj09PXN0fHwiYXBwbGUiPT09ZHQ/Y3QrZTplKX19LGp0PXtzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlLHQpe3JldHVybiEhL15icmVhay0vLnRlc3Qo",
                    "ZSkmJigiV2Via2l0Ij09PXN0PyJXZWJraXRDb2x1bW4iK2d0KGUpaW4gdCYmY3QrImNvbHVtbi0iK2U6Ik1veiI9PT1zdCYmKCJwYWdlIitndChlKWluIHQmJiJwYWdlLSIrZSkpfX0sVHQ9e3N1cHBvcnRlZFByb3BlcnR5OmZ1bmN0aW9uKGUsdCl7aWYoIS9eKGJvcmRlcnxtYXJnaW58cGFkZGluZyktaW5saW5lLy50ZXN0KGUpKXJldHVybiExO2lmKCJNb3oiPT09c3QpcmV0dXJuIGU7dmFyIG49ZS5yZXBsYWNlKCItaW5saW5lIiwiIik7cmV0dXJuIHN0K2d0KG4paW4gdCYmY3Qrbn19LFB0PXtzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlLHQpe3JldHVybiB5dChlKWluIHQmJmV9fSxSdD17c3VwcG9ydGVkUHJvcGVydHk6ZnVuY3Rpb24oZSx0KXt2YXIgbj1ndChlKTtyZXR1cm4iLSI9PT1lWzBdfHwiLSI9PT1lWzBdJiYiLSI9PT1lWzFdP2U6c3QrbiBpbiB0P2N0K2U6IldlYmtpdCIhPT1zdCYmIldlYmtpdCIrbiBpbiB0JiYiLXdlYmtpdC0iK2V9fSxOdD17c3VwcG9ydGVkUHJvcGVydHk6ZnVuY3Rpb24oZSl7cmV0dXJuInNjcm9sbC1zbmFwIj09PWUuc3Vic3RyaW5nKDAsMTEpJiYoIm1zIj09PXN0PyIiK2N0K2U6ZSl9fSxNdD17c3VwcG9ydGVkUHJvcGVydHk6ZnVuY3Rpb24oZSl7cmV0dXJuIm92ZXJzY3JvbGwtYmVoYXZpb3IiPT09ZSYmKCJtcyI9PT1zdD9jdCsic2Nyb2xsLWNoYWluaW5nIjplKX19LF90PXsiZmxleC1ncm93IjoiZmxleC1wb3NpdGl2ZSIsImZsZXgtc2hyaW5rIjoiZmxleC1uZWdhdGl2",
                    "ZSIsImZsZXgtYmFzaXMiOiJmbGV4LXByZWZlcnJlZC1zaXplIiwianVzdGlmeS1jb250ZW50IjoiZmxleC1wYWNrIixvcmRlcjoiZmxleC1vcmRlciIsImFsaWduLWl0ZW1zIjoiZmxleC1hbGlnbiIsImFsaWduLWNvbnRlbnQiOiJmbGV4LWxpbmUtcGFjayJ9LEF0PXtzdXBwb3J0ZWRQcm9wZXJ0eTpmdW5jdGlvbihlLHQpe3ZhciBuPV90W2VdO3JldHVybiEhbiYmKHN0K2d0KG4paW4gdCYmY3Qrbil9fSxJdD17ZmxleDoiYm94LWZsZXgiLCJmbGV4LWdyb3ciOiJib3gtZmxleCIsImZsZXgtZGlyZWN0aW9uIjpbImJveC1vcmllbnQiLCJib3gtZGlyZWN0aW9uIl0sb3JkZXI6ImJveC1vcmRpbmFsLWdyb3VwIiwiYWxpZ24taXRlbXMiOiJib3gtYWxpZ24iLCJmbGV4LWZsb3ciOlsiYm94LW9yaWVudCIsImJveC1kaXJlY3Rpb24iXSwianVzdGlmeS1jb250ZW50IjoiYm94LXBhY2sifSxEdD1PYmplY3Qua2V5cyhJdCksenQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGN0K2V9LEx0PVtodCxtdCx4dCxFdCxPdCxrdCxTdCxDdCxqdCxUdCxQdCxSdCxOdCxNdCxBdCx7c3VwcG9ydGVkUHJvcGVydHk6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4ubXVsdGlwbGU7aWYoRHQuaW5kZXhPZihlKT4tMSl7dmFyIG89SXRbZV07aWYoIUFycmF5LmlzQXJyYXkobykpcmV0dXJuIHN0K2d0KG8paW4gdCYmY3QrbztpZighcilyZXR1cm4hMTtmb3IodmFyIGk9MDtpPG8ubGVuZ3RoO2krKylpZighKHN0K2d0KG9bMF0paW4gdCkpcmV0dXJuITE7cmV0",
                    "dXJuIG8ubWFwKHp0KX1yZXR1cm4hMX19XSxGdD1MdC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN1cHBvcnRlZFByb3BlcnR5fSkpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3VwcG9ydGVkUHJvcGVydHl9KSksJHQ9THQuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ub1ByZWZpbGx9KSkucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlLnB1c2guYXBwbHkoZSxPYmplY3QoZXQuYSkodC5ub1ByZWZpbGwpKSxlfSksW10pLFd0PXt9O2lmKGMpe3d0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInAiKTt2YXIgQnQ9d2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCIiKTtmb3IodmFyIEh0IGluIEJ0KWlzTmFOKEh0KXx8KFd0W0J0W0h0XV09QnRbSHRdKTskdC5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZGVsZXRlIFd0W2VdfSkpfWZ1bmN0aW9uIFZ0KGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9e30pLCF3dClyZXR1cm4gZTtpZihudWxsIT1XdFtlXSlyZXR1cm4gV3RbZV07InRyYW5zaXRpb24iIT09ZSYmInRyYW5zZm9ybSIhPT1lfHwodFtlXT1lIGluIHd0LnN0eWxlKTtmb3IodmFyIG49MDtuPEZ0Lmxlbmd0aCYmKFd0W2VdPUZ0W25dKGUsd3Quc3R5bGUsdCksIVd0W2VdKTtuKyspO3RyeXt3dC5zdHlsZVtlXT0iIn1jYXRjaChyKXtyZXR1cm4hMX1yZXR1cm4gV3RbZV19dmFyIFV0LHF0PXt9LEt0PXt0cmFuc2l0aW9uOjEsInRyYW5zaXRpb24tcHJv",
                    "cGVydHkiOjEsIi13ZWJraXQtdHJhbnNpdGlvbiI6MSwiLXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5IjoxfSxZdD0vKF5ccypbXHctXSspfCwgKFxzKltcdy1dKykoPyFbXigpXSpcKSkvZztmdW5jdGlvbiBRdChlLHQsbil7aWYoInZhciI9PT10KXJldHVybiJ2YXIiO2lmKCJhbGwiPT09dClyZXR1cm4iYWxsIjtpZigiYWxsIj09PW4pcmV0dXJuIiwgYWxsIjt2YXIgcj10P1Z0KHQpOiIsICIrVnQobik7cmV0dXJuIHJ8fCh0fHxuKX1mdW5jdGlvbiBYdChlLHQpe3ZhciBuPXQ7aWYoIVV0fHwiY29udGVudCI9PT1lKXJldHVybiB0O2lmKCJzdHJpbmciIT09dHlwZW9mIG58fCFpc05hTihwYXJzZUludChuLDEwKSkpcmV0dXJuIG47dmFyIHI9ZStuO2lmKG51bGwhPXF0W3JdKXJldHVybiBxdFtyXTt0cnl7VXQuc3R5bGVbZV09bn1jYXRjaChvKXtyZXR1cm4gcXRbcl09ITEsITF9aWYoS3RbZV0pbj1uLnJlcGxhY2UoWXQsUXQpO2Vsc2UgaWYoIiI9PT1VdC5zdHlsZVtlXSYmKCItbXMtZmxleCI9PT0obj1jdCtuKSYmKFV0LnN0eWxlW2VdPSItbXMtZmxleGJveCIpLFV0LnN0eWxlW2VdPW4sIiI9PT1VdC5zdHlsZVtlXSkpcmV0dXJuIHF0W3JdPSExLCExO3JldHVybiBVdC5zdHlsZVtlXT0iIixxdFtyXT1uLHF0W3JdfWMmJihVdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJwIikpO3ZhciBHdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7Zm9yKHZhciBuIGluIHQpe3ZhciByPXRbbl07aWYoImZhbGxiYWNrcyI9PT1u",
                    "JiZBcnJheS5pc0FycmF5KHIpKXRbbl09ci5tYXAoZSk7ZWxzZXt2YXIgbz0hMSxpPVZ0KG4pO2kmJmkhPT1uJiYobz0hMCk7dmFyIGE9ITEsbD1YdChpLGcocikpO2wmJmwhPT1yJiYoYT0hMCksKG98fGEpJiYobyYmZGVsZXRlIHRbbl0sdFtpfHxuXT1sfHxyKX19cmV0dXJuIHR9cmV0dXJue29uUHJvY2Vzc1J1bGU6ZnVuY3Rpb24oZSl7aWYoImtleWZyYW1lcyI9PT1lLnR5cGUpe3ZhciB0PWU7dC5hdD0iLSI9PT0obj10LmF0KVsxXXx8Im1zIj09PXN0P246IkAiK2N0KyJrZXlmcmFtZXMiK24uc3Vic3RyKDEwKX12YXIgbn0sb25Qcm9jZXNzU3R5bGU6ZnVuY3Rpb24odCxuKXtyZXR1cm4ic3R5bGUiIT09bi50eXBlP3Q6ZSh0KX0sb25DaGFuZ2VWYWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBYdCh0LGcoZSkpfHxlfX19O3ZhciBKdD1mdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubGVuZ3RoPT09dC5sZW5ndGg/ZT50PzE6LTE6ZS5sZW5ndGgtdC5sZW5ndGh9O3JldHVybntvblByb2Nlc3NTdHlsZTpmdW5jdGlvbih0LG4pe2lmKCJzdHlsZSIhPT1uLnR5cGUpcmV0dXJuIHQ7Zm9yKHZhciByPXt9LG89T2JqZWN0LmtleXModCkuc29ydChlKSxpPTA7aTxvLmxlbmd0aDtpKyspcltvW2ldXT10W29baV1dO3JldHVybiByfX19O2Z1bmN0aW9uIFp0KCl7cmV0dXJue3BsdWdpbnM6W1BlKCksSWUoKSxGZSgpLHFlKCksWmUoKSwidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3c/bnVsbDpHdCgpLEp0",
                    "KCldfX12YXIgZW49d2UoWnQoKSksdG49e2Rpc2FibGVHZW5lcmF0aW9uOiExLGdlbmVyYXRlQ2xhc3NOYW1lOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9ZS5kaXNhYmxlR2xvYmFsLG49dm9pZCAwIT09dCYmdCxyPWUucHJvZHVjdGlvblByZWZpeCxvPXZvaWQgMD09PXI/ImpzcyI6cixpPWUuc2VlZCxhPXZvaWQgMD09PWk/IiI6aSxsPSIiPT09YT8iIjoiIi5jb25jYXQoYSwiLSIpLHU9MCxzPWZ1bmN0aW9uKCl7cmV0dXJuIHUrPTF9O3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciByPXQub3B0aW9ucy5uYW1lO2lmKHImJjA9PT1yLmluZGV4T2YoIk11aSIpJiYhdC5vcHRpb25zLmxpbmsmJiFuKXtpZigtMSE9PVNlLmluZGV4T2YoZS5rZXkpKXJldHVybiJNdWktIi5jb25jYXQoZS5rZXkpO3ZhciBpPSIiLmNvbmNhdChsKS5jb25jYXQociwiLSIpLmNvbmNhdChlLmtleSk7cmV0dXJuIHQub3B0aW9ucy50aGVtZVtrZV0mJiIiPT09YT8iIi5jb25jYXQoaSwiLSIpLmNvbmNhdChzKCkpOml9cmV0dXJuIiIuY29uY2F0KGwpLmNvbmNhdChvKS5jb25jYXQocygpKX19KCksanNzOmVuLHNoZWV0c0NhY2hlOm51bGwsc2hlZXRzTWFuYWdlcjpuZXcgTWFwLHNoZWV0c1JlZ2lzdHJ5Om51bGx9LG5uPWEuYS5jcmVhdGVDb250ZXh0KHRuKTt2YXIgcm49LTFlOTtmdW5jdGlvbiBvbigpe3JldHVybiBybis9MX1uKDI5KTt2YXIgYW49bigx",
                    "MjUpO2Z1bmN0aW9uIGxuKGUpe3ZhciB0PSJmdW5jdGlvbiI9PT10eXBlb2YgZTtyZXR1cm57Y3JlYXRlOmZ1bmN0aW9uKG4sbyl7dmFyIGk7dHJ5e2k9dD9lKG4pOmV9Y2F0Y2godSl7dGhyb3cgdX1pZighb3x8IW4ub3ZlcnJpZGVzfHwhbi5vdmVycmlkZXNbb10pcmV0dXJuIGk7dmFyIGE9bi5vdmVycmlkZXNbb10sbD1PYmplY3Qoci5hKSh7fSxpKTtyZXR1cm4gT2JqZWN0LmtleXMoYSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bFtlXT1PYmplY3QoYW4uYSkobFtlXSxhW2VdKX0pKSxsfSxvcHRpb25zOnt9fX12YXIgdW49e307ZnVuY3Rpb24gc24oZSx0LG4pe3ZhciByPWUuc3RhdGU7aWYoZS5zdHlsZXNPcHRpb25zLmRpc2FibGVHZW5lcmF0aW9uKXJldHVybiB0fHx7fTtyLmNhY2hlQ2xhc3Nlc3x8KHIuY2FjaGVDbGFzc2VzPXt2YWx1ZTpudWxsLGxhc3RQcm9wOm51bGwsbGFzdEpTUzp7fX0pO3ZhciBvPSExO3JldHVybiByLmNsYXNzZXMhPT1yLmNhY2hlQ2xhc3Nlcy5sYXN0SlNTJiYoci5jYWNoZUNsYXNzZXMubGFzdEpTUz1yLmNsYXNzZXMsbz0hMCksdCE9PXIuY2FjaGVDbGFzc2VzLmxhc3RQcm9wJiYoci5jYWNoZUNsYXNzZXMubGFzdFByb3A9dCxvPSEwKSxvJiYoci5jYWNoZUNsYXNzZXMudmFsdWU9T2JqZWN0KHhlLmEpKHtiYXNlQ2xhc3NlczpyLmNhY2hlQ2xhc3Nlcy5sYXN0SlNTLG5ld0NsYXNzZXM6dCxDb21wb25lbnQ6bn0pKSxyLmNhY2hlQ2xhc3Nlcy52YWx1ZX1mdW5jdGlvbiBjbihlLHQpe3Zh",
                    "ciBuPWUuc3RhdGUsbz1lLnRoZW1lLGk9ZS5zdHlsZXNPcHRpb25zLGE9ZS5zdHlsZXNDcmVhdG9yLGw9ZS5uYW1lO2lmKCFpLmRpc2FibGVHZW5lcmF0aW9uKXt2YXIgdT1FZS5nZXQoaS5zaGVldHNNYW5hZ2VyLGEsbyk7dXx8KHU9e3JlZnM6MCxzdGF0aWNTaGVldDpudWxsLGR5bmFtaWNTdHlsZXM6bnVsbH0sRWUuc2V0KGkuc2hlZXRzTWFuYWdlcixhLG8sdSkpO3ZhciBzPU9iamVjdChyLmEpKE9iamVjdChyLmEpKE9iamVjdChyLmEpKHt9LGEub3B0aW9ucyksaSkse30se3RoZW1lOm8sZmxpcDoiYm9vbGVhbiI9PT10eXBlb2YgaS5mbGlwP2kuZmxpcDoicnRsIj09PW8uZGlyZWN0aW9ufSk7cy5nZW5lcmF0ZUlkPXMuc2VydmVyR2VuZXJhdGVDbGFzc05hbWV8fHMuZ2VuZXJhdGVDbGFzc05hbWU7dmFyIGM9aS5zaGVldHNSZWdpc3RyeTtpZigwPT09dS5yZWZzKXt2YXIgZDtpLnNoZWV0c0NhY2hlJiYoZD1FZS5nZXQoaS5zaGVldHNDYWNoZSxhLG8pKTt2YXIgZj1hLmNyZWF0ZShvLGwpO2R8fCgoZD1pLmpzcy5jcmVhdGVTdHlsZVNoZWV0KGYsT2JqZWN0KHIuYSkoe2xpbms6ITF9LHMpKSkuYXR0YWNoKCksaS5zaGVldHNDYWNoZSYmRWUuc2V0KGkuc2hlZXRzQ2FjaGUsYSxvLGQpKSxjJiZjLmFkZChkKSx1LnN0YXRpY1NoZWV0PWQsdS5keW5hbWljU3R5bGVzPWZ1bmN0aW9uIGUodCl7dmFyIG49bnVsbDtmb3IodmFyIHIgaW4gdCl7dmFyIG89dFtyXSxpPXR5cGVvZiBvO2lmKCJmdW5jdGlvbiI9PT1pKW58fChu",
                    "PXt9KSxuW3JdPW87ZWxzZSBpZigib2JqZWN0Ij09PWkmJm51bGwhPT1vJiYhQXJyYXkuaXNBcnJheShvKSl7dmFyIGE9ZShvKTthJiYobnx8KG49e30pLG5bcl09YSl9fXJldHVybiBufShmKX1pZih1LmR5bmFtaWNTdHlsZXMpe3ZhciBwPWkuanNzLmNyZWF0ZVN0eWxlU2hlZXQodS5keW5hbWljU3R5bGVzLE9iamVjdChyLmEpKHtsaW5rOiEwfSxzKSk7cC51cGRhdGUodCkscC5hdHRhY2goKSxuLmR5bmFtaWNTaGVldD1wLG4uY2xhc3Nlcz1PYmplY3QoeGUuYSkoe2Jhc2VDbGFzc2VzOnUuc3RhdGljU2hlZXQuY2xhc3NlcyxuZXdDbGFzc2VzOnAuY2xhc3Nlc30pLGMmJmMuYWRkKHApfWVsc2Ugbi5jbGFzc2VzPXUuc3RhdGljU2hlZXQuY2xhc3Nlczt1LnJlZnMrPTF9fWZ1bmN0aW9uIGRuKGUsdCl7dmFyIG49ZS5zdGF0ZTtuLmR5bmFtaWNTaGVldCYmbi5keW5hbWljU2hlZXQudXBkYXRlKHQpfWZ1bmN0aW9uIGZuKGUpe3ZhciB0PWUuc3RhdGUsbj1lLnRoZW1lLHI9ZS5zdHlsZXNPcHRpb25zLG89ZS5zdHlsZXNDcmVhdG9yO2lmKCFyLmRpc2FibGVHZW5lcmF0aW9uKXt2YXIgaT1FZS5nZXQoci5zaGVldHNNYW5hZ2VyLG8sbik7aS5yZWZzLT0xO3ZhciBhPXIuc2hlZXRzUmVnaXN0cnk7MD09PWkucmVmcyYmKEVlLmRlbGV0ZShyLnNoZWV0c01hbmFnZXIsbyxuKSxyLmpzcy5yZW1vdmVTdHlsZVNoZWV0KGkuc3RhdGljU2hlZXQpLGEmJmEucmVtb3ZlKGkuc3RhdGljU2hlZXQpKSx0LmR5bmFtaWNTaGVldCYmKHIu",
                    "anNzLnJlbW92ZVN0eWxlU2hlZXQodC5keW5hbWljU2hlZXQpLGEmJmEucmVtb3ZlKHQuZHluYW1pY1NoZWV0KSl9fWZ1bmN0aW9uIHBuKGUsdCl7dmFyIG4scj1hLmEudXNlUmVmKFtdKSxvPWEuYS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybnt9fSksdCk7ci5jdXJyZW50IT09byYmKHIuY3VycmVudD1vLG49ZSgpKSxhLmEudXNlRWZmZWN0KChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe24mJm4oKX19KSxbb10pfWZ1bmN0aW9uIGhuKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxuPXQubmFtZSxpPXQuY2xhc3NOYW1lUHJlZml4LGw9dC5Db21wb25lbnQsdT10LmRlZmF1bHRUaGVtZSxzPXZvaWQgMD09PXU/dW46dSxjPU9iamVjdChvLmEpKHQsWyJuYW1lIiwiY2xhc3NOYW1lUHJlZml4IiwiQ29tcG9uZW50IiwiZGVmYXVsdFRoZW1lIl0pLGQ9bG4oZSksZj1ufHxpfHwibWFrZVN0eWxlcyI7ZC5vcHRpb25zPXtpbmRleDpvbigpLG5hbWU6bixtZXRhOmYsY2xhc3NOYW1lUHJlZml4OmZ9O3ZhciBwPWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9T2JqZWN0KE9lLmEpKCl8fHMsbz1PYmplY3Qoci5hKShPYmplY3Qoci5hKSh7fSxhLmEudXNlQ29udGV4dChubikpLGMpLGk9YS5hLnVzZVJlZigpLHU9YS5hLnVzZVJlZigpO3BuKChmdW5jdGlvbigp",
                    "e3ZhciByPXtuYW1lOm4sc3RhdGU6e30sc3R5bGVzQ3JlYXRvcjpkLHN0eWxlc09wdGlvbnM6byx0aGVtZTp0fTtyZXR1cm4gY24ocixlKSx1LmN1cnJlbnQ9ITEsaS5jdXJyZW50PXIsZnVuY3Rpb24oKXtmbihyKX19KSxbdCxkXSksYS5hLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXt1LmN1cnJlbnQmJmRuKGkuY3VycmVudCxlKSx1LmN1cnJlbnQ9ITB9KSk7dmFyIGY9c24oaS5jdXJyZW50LGUuY2xhc3NlcyxsKTtyZXR1cm4gZn07cmV0dXJuIHB9dmFyIG1uPW4oMTI3KSx2bj1mdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciBpPXQuZGVmYXVsdFRoZW1lLGw9dC53aXRoVGhlbWUscz12b2lkIDAhPT1sJiZsLGM9dC5uYW1lLGQ9T2JqZWN0KG8uYSkodCxbImRlZmF1bHRUaGVtZSIsIndpdGhUaGVtZSIsIm5hbWUiXSk7dmFyIGY9YyxwPWhuKGUsT2JqZWN0KHIuYSkoe2RlZmF1bHRUaGVtZTppLENvbXBvbmVudDpuLG5hbWU6Y3x8bi5kaXNwbGF5TmFtZSxjbGFzc05hbWVQcmVmaXg6Zn0sZCkpLGg9YS5hLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7ZS5jbGFzc2VzO3ZhciBsLHU9ZS5pbm5lclJlZixkPU9iamVjdChvLmEpKGUsWyJjbGFzc2VzIiwiaW5uZXJSZWYiXSksZj1wKE9iamVjdChyLmEpKE9iamVjdChyLmEpKHt9LG4uZGVmYXVsdFByb3BzKSxlKSksaD1kO3JldHVybigic3RyaW5nIj09",
                    "PXR5cGVvZiBjfHxzKSYmKGw9T2JqZWN0KE9lLmEpKCl8fGksYyYmKGg9T2JqZWN0KG1uLmEpKHt0aGVtZTpsLG5hbWU6Yyxwcm9wczpkfSkpLHMmJiFoLnRoZW1lJiYoaC50aGVtZT1sKSksYS5hLmNyZWF0ZUVsZW1lbnQobixPYmplY3Qoci5hKSh7cmVmOnV8fHQsY2xhc3NlczpmfSxoKSl9KSk7cmV0dXJuIHUoKShoLG4pLGh9fSxibj1uKDQ5KTt0LmE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm4oZSxPYmplY3Qoci5hKSh7ZGVmYXVsdFRoZW1lOmJuLmF9LHQpKX19LGZ1bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9big4MCkoKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIG99KSk7dmFyIHI9big2Nik7ZnVuY3Rpb24gbyhlKXtpZigic3RyaW5nIiE9PXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihPYmplY3Qoci5hKSg3KSk7cmV0dXJuIGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKX19LCxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiOyFmdW5jdGlvbiBlKCl7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fJiYiZnVuY3Rpb24iPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSl7MDt0cnl7X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGUpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IodCl9fX0oKSxlLmV4cG9ydHM9big3NSl9LGZ1",
                    "bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9big4NSl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiBpfSkpO3ZhciByPW4oMCksbz1uKDI1KTtmdW5jdGlvbiBpKGUsdCl7cmV0dXJuIHIudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09ZSYmbnVsbD09dD9udWxsOmZ1bmN0aW9uKG4pe09iamVjdChvLmEpKGUsbiksT2JqZWN0KG8uYSkodCxuKX19KSxbZSx0XSl9fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJjIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKSxuLmQodCwiYiIsKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSksbi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiBjfSkpLG4uZCh0LCJkIiwoZnVuY3Rpb24oKXtyZXR1cm4gZH0pKTt2YXIgcj1uKDY2KTtmdW5jdGlvbiBvKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOjE7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHQsZSksbil9ZnVuY3Rpb24gaShlKXtpZihlLnR5cGUpcmV0dXJuIGU7aWYoIiMiPT09ZS5jaGFyQXQoMCkpcmV0dXJuIGkoZnVuY3Rpb24oZSl7ZT1lLnN1YnN0cigxKTt2YXIgdD1uZXcgUmVnRXhwKCIuezEsIi5jb25jYXQoZS5sZW5ndGg+PTY/MjoxLCJ9IiksImciKSxuPWUubWF0Y2godCk7",
                    "cmV0dXJuIG4mJjE9PT1uWzBdLmxlbmd0aCYmKG49bi5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlK2V9KSkpLG4/InJnYiIuY29uY2F0KDQ9PT1uLmxlbmd0aD8iYSI6IiIsIigiKS5jb25jYXQobi5tYXAoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ8Mz9wYXJzZUludChlLDE2KTpNYXRoLnJvdW5kKHBhcnNlSW50KGUsMTYpLzI1NSoxZTMpLzFlM30pKS5qb2luKCIsICIpLCIpIik6IiJ9KGUpKTt2YXIgdD1lLmluZGV4T2YoIigiKSxuPWUuc3Vic3RyaW5nKDAsdCk7aWYoLTE9PT1bInJnYiIsInJnYmEiLCJoc2wiLCJoc2xhIl0uaW5kZXhPZihuKSl0aHJvdyBuZXcgRXJyb3IoT2JqZWN0KHIuYSkoMyxlKSk7dmFyIG89ZS5zdWJzdHJpbmcodCsxLGUubGVuZ3RoLTEpLnNwbGl0KCIsIik7cmV0dXJue3R5cGU6bix2YWx1ZXM6bz1vLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlRmxvYXQoZSl9KSl9fWZ1bmN0aW9uIGEoZSl7dmFyIHQ9ZS50eXBlLG49ZS52YWx1ZXM7cmV0dXJuLTEhPT10LmluZGV4T2YoInJnYiIpP249bi5tYXAoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ8Mz9wYXJzZUludChlLDEwKTplfSkpOi0xIT09dC5pbmRleE9mKCJoc2wiKSYmKG5bMV09IiIuY29uY2F0KG5bMV0sIiUiKSxuWzJdPSIiLmNvbmNhdChuWzJdLCIlIikpLCIiLmNvbmNhdCh0LCIoIikuY29uY2F0KG4uam9pbigiLCAiKSwiKSIpfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj11KGUpLHI9dSh0KTtyZXR1cm4oTWF0aC5tYXgobixyKSsu",
                    "MDUpLyhNYXRoLm1pbihuLHIpKy4wNSl9ZnVuY3Rpb24gdShlKXt2YXIgdD0iaHNsIj09PShlPWkoZSkpLnR5cGU/aShmdW5jdGlvbihlKXt2YXIgdD0oZT1pKGUpKS52YWx1ZXMsbj10WzBdLHI9dFsxXS8xMDAsbz10WzJdLzEwMCxsPXIqTWF0aC5taW4obywxLW8pLHU9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOihlK24vMzApJTEyO3JldHVybiBvLWwqTWF0aC5tYXgoTWF0aC5taW4odC0zLDktdCwxKSwtMSl9LHM9InJnYiIsYz1bTWF0aC5yb3VuZCgyNTUqdSgwKSksTWF0aC5yb3VuZCgyNTUqdSg4KSksTWF0aC5yb3VuZCgyNTUqdSg0KSldO3JldHVybiJoc2xhIj09PWUudHlwZSYmKHMrPSJhIixjLnB1c2godFszXSkpLGEoe3R5cGU6cyx2YWx1ZXM6Y30pfShlKSkudmFsdWVzOmUudmFsdWVzO3JldHVybiB0PXQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4oZS89MjU1KTw9LjAzOTI4P2UvMTIuOTI6TWF0aC5wb3coKGUrLjA1NSkvMS4wNTUsMi40KX0pKSxOdW1iZXIoKC4yMTI2KnRbMF0rLjcxNTIqdFsxXSsuMDcyMip0WzJdKS50b0ZpeGVkKDMpKX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGU9aShlKSx0PW8odCksInJnYiIhPT1lLnR5cGUmJiJoc2wiIT09ZS50eXBlfHwoZS50eXBlKz0iYSIpLGUudmFsdWVzWzNdPXQsYShlKX1mdW5jdGlvbiBjKGUsdCl7aWYoZT1pKGUpLHQ9byh0KSwtMSE9PWUudHlwZS5pbmRleE9mKCJoc2wi",
                    "KSllLnZhbHVlc1syXSo9MS10O2Vsc2UgaWYoLTEhPT1lLnR5cGUuaW5kZXhPZigicmdiIikpZm9yKHZhciBuPTA7bjwzO24rPTEpZS52YWx1ZXNbbl0qPTEtdDtyZXR1cm4gYShlKX1mdW5jdGlvbiBkKGUsdCl7aWYoZT1pKGUpLHQ9byh0KSwtMSE9PWUudHlwZS5pbmRleE9mKCJoc2wiKSllLnZhbHVlc1syXSs9KDEwMC1lLnZhbHVlc1syXSkqdDtlbHNlIGlmKC0xIT09ZS50eXBlLmluZGV4T2YoInJnYiIpKWZvcih2YXIgbj0wO248MztuKz0xKWUudmFsdWVzW25dKz0oMjU1LWUudmFsdWVzW25dKSp0O3JldHVybiBhKGUpfX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSk7dmFyIHI9bigxKSxvPW4oMCksaT1uLm4obyksYT1uKDY3KTtmdW5jdGlvbiBsKGUsdCl7dmFyIG49aS5hLm1lbW8oaS5hLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIGkuYS5jcmVhdGVFbGVtZW50KGEuYSxPYmplY3Qoci5hKSh7cmVmOm59LHQpLGUpfSkpKTtyZXR1cm4gbi5tdWlOYW1lPWEuYS5tdWlOYW1lLG59fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsbz17fSxpPU9iamVjdC5rZXlzKGUpO2ZvcihyPTA7cjxpLmxlbmd0aDtyKyspbj1pW3JdLHQuaW5kZXhPZihuKT49MHx8KG9bbl09ZVtuXSk7cmV0dXJuIG99bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxm",
                    "dW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihyPXIuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLG4ucHVzaC5hcHBseShuLHIpfXJldHVybiBufWZ1bmN0aW9uIGkoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/byhPYmplY3QobiksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IoZSx0LG5bdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpOm8oT2JqZWN0KG4pKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KSl9KSl9cmV0dXJuIGV9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVy",
                    "biBpfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0LG4scixvLGksYSl7dHJ5e3ZhciBsPWVbaV0oYSksdT1sLnZhbHVlfWNhdGNoKHMpe3JldHVybiB2b2lkIG4ocyl9bC5kb25lP3QodSk6UHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ocixvKX1mdW5jdGlvbiBvKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMsbj1hcmd1bWVudHM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihvLGkpe3ZhciBhPWUuYXBwbHkodCxuKTtmdW5jdGlvbiBsKGUpe3IoYSxvLGksbCx1LCJuZXh0IixlKX1mdW5jdGlvbiB1KGUpe3IoYSxvLGksbCx1LCJ0aHJvdyIsZSl9bCh2b2lkIDApfSkpfX1uLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIG99KSl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTt0aHJvdyBFcnJvcigiW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogIitlKyhuLmxlbmd0aD8iICIrbi5qb2luKCIsIik6IiIpKyIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2YiKX1mdW5jdGlvbiBvKGUpe3JldHVybiEhZSYmISFlW0tdfWZ1bmN0aW9uIGkoZSl7cmV0dXJuISFlJiYoZnVuY3Rpb24oZSl7aWYoIWV8fCJvYmplY3QiIT10eXBlb2YgZSlyZXR1cm4hMTt2YXIgdD1PYmpl",
                    "Y3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuIXR8fHQ9PT1PYmplY3QucHJvdG90eXBlfShlKXx8QXJyYXkuaXNBcnJheShlKXx8ISFlW3FdfHwhIWUuY29uc3RydWN0b3JbcV18fGYoZSl8fHAoZSkpfWZ1bmN0aW9uIGEoZSx0LG4pe3ZvaWQgMD09PW4mJihuPSExKSwwPT09bChlKT8obj9PYmplY3Qua2V5czpZKShlKS5mb3JFYWNoKChmdW5jdGlvbihyKXtuJiYic3ltYm9sIj09dHlwZW9mIHJ8fHQocixlW3JdLGUpfSkpOmUuZm9yRWFjaCgoZnVuY3Rpb24obixyKXtyZXR1cm4gdChyLG4sZSl9KSl9ZnVuY3Rpb24gbChlKXt2YXIgdD1lW0tdO3JldHVybiB0P3QuaT4zP3QuaS00OnQuaTpBcnJheS5pc0FycmF5KGUpPzE6ZihlKT8yOnAoZSk/MzowfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4gMj09PWwoZSk/ZS5oYXModCk6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9ZnVuY3Rpb24gcyhlLHQpe3JldHVybiAyPT09bChlKT9lLmdldCh0KTplW3RdfWZ1bmN0aW9uIGMoZSx0LG4pe3ZhciByPWwoZSk7Mj09PXI/ZS5zZXQodCxuKTozPT09cj8oZS5kZWxldGUodCksZS5hZGQobikpOmVbdF09bn1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIGU9PT10PzAhPT1lfHwxL2U9PTEvdDplIT1lJiZ0IT10fWZ1bmN0aW9uIGYoZSl7cmV0dXJuIEImJmUgaW5zdGFuY2VvZiBNYXB9ZnVuY3Rpb24gcChlKXtyZXR1cm4gSCYmZSBpbnN0YW5jZW9mIFNldH1mdW5jdGlvbiBoKGUpe3JldHVybiBlLm98fGUudH1m",
                    "dW5jdGlvbiBtKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpO3ZhciB0PVEoZSk7ZGVsZXRlIHRbS107Zm9yKHZhciBuPVkodCkscj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdLGk9dFtvXTshMT09PWkud3JpdGFibGUmJihpLndyaXRhYmxlPSEwLGkuY29uZmlndXJhYmxlPSEwKSwoaS5nZXR8fGkuc2V0KSYmKHRbb109e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOmkuZW51bWVyYWJsZSx2YWx1ZTplW29dfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpLHQpfWZ1bmN0aW9uIHYoZSx0KXt5KGUpfHxvKGUpfHwhaShlKXx8KGwoZSk+MSYmKGUuc2V0PWUuYWRkPWUuY2xlYXI9ZS5kZWxldGU9YiksT2JqZWN0LmZyZWV6ZShlKSx0JiZhKGUsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHYodCwhMCl9KSwhMCkpfWZ1bmN0aW9uIGIoKXtyKDIpfWZ1bmN0aW9uIHkoZSl7cmV0dXJuIG51bGw9PWV8fCJvYmplY3QiIT10eXBlb2YgZXx8T2JqZWN0LmlzRnJvemVuKGUpfWZ1bmN0aW9uIGcoZSl7dmFyIHQ9WFtlXTtyZXR1cm4gdHx8cigxOSxlKSx0fWZ1bmN0aW9uIHcoZSx0KXtYW2VdPXR9ZnVuY3Rpb24geCgpe3JldHVybiAkfWZ1bmN0aW9uIEUoZSx0KXt0JiYoZygiUGF0Y2hlcyIpLGUudT1bXSxlLnM9W10sZS52PXQpfWZ1bmN0aW9uIE8oZSl7ayhlKSxlLnAuZm9yRWFjaChDKSxlLnA9bnVsbH1mdW5j",
                    "dGlvbiBrKGUpe2U9PT0kJiYoJD1lLmwpfWZ1bmN0aW9uIFMoZSl7cmV0dXJuICQ9e3A6W10sbDokLGg6ZSxtOiEwLF86MH19ZnVuY3Rpb24gQyhlKXt2YXIgdD1lW0tdOzA9PT10Lml8fDE9PT10Lmk/dC5qKCk6dC5nPSEwfWZ1bmN0aW9uIGooZSx0KXt0Ll89dC5wLmxlbmd0aDt2YXIgbj10LnBbMF0sbz12b2lkIDAhPT1lJiZlIT09bjtyZXR1cm4gdC5oLk98fGcoIkVTNSIpLlModCxlLG8pLG8/KG5bS10uUCYmKE8odCkscig0KSksaShlKSYmKGU9VCh0LGUpLHQubHx8Uih0LGUpKSx0LnUmJmcoIlBhdGNoZXMiKS5NKG5bS10sZSx0LnUsdC5zKSk6ZT1UKHQsbixbXSksTyh0KSx0LnUmJnQudih0LnUsdC5zKSxlIT09VT9lOnZvaWQgMH1mdW5jdGlvbiBUKGUsdCxuKXtpZih5KHQpKXJldHVybiB0O3ZhciByPXRbS107aWYoIXIpcmV0dXJuIGEodCwoZnVuY3Rpb24obyxpKXtyZXR1cm4gUChlLHIsdCxvLGksbil9KSwhMCksdDtpZihyLkEhPT1lKXJldHVybiB0O2lmKCFyLlApcmV0dXJuIFIoZSxyLnQsITApLHIudDtpZighci5JKXtyLkk9ITAsci5BLl8tLTt2YXIgbz00PT09ci5pfHw1PT09ci5pP3Iubz1tKHIuayk6ci5vO2EoMz09PXIuaT9uZXcgU2V0KG8pOm8sKGZ1bmN0aW9uKHQsaSl7cmV0dXJuIFAoZSxyLG8sdCxpLG4pfSkpLFIoZSxvLCExKSxuJiZlLnUmJmcoIlBhdGNoZXMiKS5SKHIsbixlLnUsZS5zKX1yZXR1cm4gci5vfWZ1bmN0aW9uIFAoZSx0LG4scixhLGwpe2lmKG8oYSkpe3ZhciBzPVQoZSxhLGwm",
                    "JnQmJjMhPT10LmkmJiF1KHQuRCxyKT9sLmNvbmNhdChyKTp2b2lkIDApO2lmKGMobixyLHMpLCFvKHMpKXJldHVybjtlLm09ITF9aWYoaShhKSYmIXkoYSkpe2lmKCFlLmguTiYmZS5fPDEpcmV0dXJuO1QoZSxhKSx0JiZ0LkEubHx8UihlLGEpfX1mdW5jdGlvbiBSKGUsdCxuKXt2b2lkIDA9PT1uJiYobj0hMSksZS5oLk4mJmUubSYmdih0LG4pfWZ1bmN0aW9uIE4oZSx0KXt2YXIgbj1lW0tdO3JldHVybihuP2gobik6ZSlbdF19ZnVuY3Rpb24gTShlLHQpe2lmKHQgaW4gZSlmb3IodmFyIG49T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO247KXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYocilyZXR1cm4gcjtuPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKX19ZnVuY3Rpb24gXyhlKXtlLlB8fChlLlA9ITAsZS5sJiZfKGUubCkpfWZ1bmN0aW9uIEEoZSl7ZS5vfHwoZS5vPW0oZS50KSl9ZnVuY3Rpb24gSShlLHQsbil7dmFyIHI9Zih0KT9nKCJNYXBTZXQiKS5UKHQsbik6cCh0KT9nKCJNYXBTZXQiKS5GKHQsbik6ZS5PP2Z1bmN0aW9uKGUsdCl7dmFyIG49QXJyYXkuaXNBcnJheShlKSxyPXtpOm4/MTowLEE6dD90LkE6eCgpLFA6ITEsSTohMSxEOnt9LGw6dCx0OmUsazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0sbz1yLGk9RztuJiYobz1bcl0saT1KKTt2YXIgYT1Qcm94eS5yZXZvY2FibGUobyxpKSxsPWEucmV2b2tlLHU9YS5wcm94eTtyZXR1cm4gci5rPXUsci5qPWwsdX0odCxuKTpn",
                    "KCJFUzUiKS5KKHQsbik7cmV0dXJuKG4/bi5BOngoKSkucC5wdXNoKHIpLHJ9ZnVuY3Rpb24gRChlKXtyZXR1cm4gbyhlKXx8cigyMixlKSxmdW5jdGlvbiBlKHQpe2lmKCFpKHQpKXJldHVybiB0O3ZhciBuLHI9dFtLXSxvPWwodCk7aWYocil7aWYoIXIuUCYmKHIuaTw0fHwhZygiRVM1IikuSyhyKSkpcmV0dXJuIHIudDtyLkk9ITAsbj16KHQsbyksci5JPSExfWVsc2Ugbj16KHQsbyk7cmV0dXJuIGEobiwoZnVuY3Rpb24odCxvKXtyJiZzKHIudCx0KT09PW98fGMobix0LGUobykpfSkpLDM9PT1vP25ldyBTZXQobik6bn0oZSl9ZnVuY3Rpb24geihlLHQpe3N3aXRjaCh0KXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAoZSk7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKGUpfXJldHVybiBtKGUpfWZ1bmN0aW9uIEwoKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49aVtlXTtyZXR1cm4gbj9uLmVudW1lcmFibGU9dDppW2VdPW49e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnQsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpc1tLXTtyZXR1cm4gRy5nZXQodCxlKX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXNbS107Ry5zZXQobixlLHQpfX0sbn1mdW5jdGlvbiB0KGUpe2Zvcih2YXIgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXt2YXIgbz1lW3RdW0tdO2lmKCFvLlApc3dpdGNoKG8uaSl7Y2FzZSA1OnIobykmJl8obyk7YnJlYWs7Y2FzZSA0Om4obykmJl8obyl9fX1mdW5jdGlvbiBuKGUpe2Zvcih2YXIgdD1lLnQsbj1lLmsscj1ZKG4p",
                    "LG89ci5sZW5ndGgtMTtvPj0wO28tLSl7dmFyIGk9cltvXTtpZihpIT09Syl7dmFyIGE9dFtpXTtpZih2b2lkIDA9PT1hJiYhdSh0LGkpKXJldHVybiEwO3ZhciBsPW5baV0scz1sJiZsW0tdO2lmKHM/cy50IT09YTohZChsLGEpKXJldHVybiEwfX12YXIgYz0hIXRbS107cmV0dXJuIHIubGVuZ3RoIT09WSh0KS5sZW5ndGgrKGM/MDoxKX1mdW5jdGlvbiByKGUpe3ZhciB0PWUuaztpZih0Lmxlbmd0aCE9PWUudC5sZW5ndGgpcmV0dXJuITA7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHQubGVuZ3RoLTEpO3JldHVybiEoIW58fG4uZ2V0KX12YXIgaT17fTt3KCJFUzUiLHtKOmZ1bmN0aW9uKHQsbil7dmFyIHI9QXJyYXkuaXNBcnJheSh0KSxvPWZ1bmN0aW9uKHQsbil7aWYodCl7Zm9yKHZhciByPUFycmF5KG4ubGVuZ3RoKSxvPTA7bzxuLmxlbmd0aDtvKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIiIrbyxlKG8sITApKTtyZXR1cm4gcn12YXIgaT1RKG4pO2RlbGV0ZSBpW0tdO2Zvcih2YXIgYT1ZKGkpLGw9MDtsPGEubGVuZ3RoO2wrKyl7dmFyIHU9YVtsXTtpW3VdPWUodSx0fHwhIWlbdV0uZW51bWVyYWJsZSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLGkpfShyLHQpLGk9e2k6cj81OjQsQTpuP24uQTp4KCksUDohMSxJOiExLEQ6e30sbDpuLHQ6dCxrOm8sbzpudWxsLGc6ITEsQzohMX07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLEsse3Zh",
                    "bHVlOmksd3JpdGFibGU6ITB9KSxvfSxTOmZ1bmN0aW9uKGUsbixpKXtpP28obikmJm5bS10uQT09PWUmJnQoZS5wKTooZS51JiZmdW5jdGlvbiBlKHQpe2lmKHQmJiJvYmplY3QiPT10eXBlb2YgdCl7dmFyIG49dFtLXTtpZihuKXt2YXIgbz1uLnQsaT1uLmssbD1uLkQscz1uLmk7aWYoND09PXMpYShpLChmdW5jdGlvbih0KXt0IT09SyYmKHZvaWQgMCE9PW9bdF18fHUobyx0KT9sW3RdfHxlKGlbdF0pOihsW3RdPSEwLF8obikpKX0pKSxhKG8sKGZ1bmN0aW9uKGUpe3ZvaWQgMCE9PWlbZV18fHUoaSxlKXx8KGxbZV09ITEsXyhuKSl9KSk7ZWxzZSBpZig1PT09cyl7aWYocihuKSYmKF8obiksbC5sZW5ndGg9ITApLGkubGVuZ3RoPG8ubGVuZ3RoKWZvcih2YXIgYz1pLmxlbmd0aDtjPG8ubGVuZ3RoO2MrKylsW2NdPSExO2Vsc2UgZm9yKHZhciBkPW8ubGVuZ3RoO2Q8aS5sZW5ndGg7ZCsrKWxbZF09ITA7Zm9yKHZhciBmPU1hdGgubWluKGkubGVuZ3RoLG8ubGVuZ3RoKSxwPTA7cDxmO3ArKyl2b2lkIDA9PT1sW3BdJiZlKGlbcF0pfX19fShlLnBbMF0pLHQoZS5wKSl9LEs6ZnVuY3Rpb24oZSl7cmV0dXJuIDQ9PT1lLmk/bihlKTpyKGUpfX0pfW4uZCh0LCJiIiwoZnVuY3Rpb24oKXtyZXR1cm4gTH0pKSxuLmQodCwiYyIsKGZ1bmN0aW9uKCl7cmV0dXJuIG99KSksbi5kKHQsImQiLChmdW5jdGlvbigpe3JldHVybiBpfSkpO3ZhciBGLCQsVz0idW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmInN5bWJvbCI9PXR5cGVvZiBT",
                    "eW1ib2woIngiKSxCPSJ1bmRlZmluZWQiIT10eXBlb2YgTWFwLEg9InVuZGVmaW5lZCIhPXR5cGVvZiBTZXQsVj0idW5kZWZpbmVkIiE9dHlwZW9mIFByb3h5JiZ2b2lkIDAhPT1Qcm94eS5yZXZvY2FibGUmJiJ1bmRlZmluZWQiIT10eXBlb2YgUmVmbGVjdCxVPVc/U3ltYm9sLmZvcigiaW1tZXItbm90aGluZyIpOigoRj17fSlbImltbWVyLW5vdGhpbmciXT0hMCxGKSxxPVc/U3ltYm9sLmZvcigiaW1tZXItZHJhZnRhYmxlIik6Il9fJGltbWVyX2RyYWZ0YWJsZSIsSz1XP1N5bWJvbC5mb3IoImltbWVyLXN0YXRlIik6Il9fJGltbWVyX3N0YXRlIixZPSgidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yLCJ1bmRlZmluZWQiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSxRPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihlKXt2YXIgdD17fTtyZXR1cm4gWShlKS5mb3JFYWNoKChmdW5jdGlvbihuKXt0W25dPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKX0pKSx0fSxYPXt9LEc9e2dldDpmdW5jdGlvbihlLHQpe2lmKHQ9PT1LKXJl",
                    "dHVybiBlO3ZhciBuPWgoZSk7aWYoIXUobix0KSlyZXR1cm4gZnVuY3Rpb24oZSx0LG4pe3ZhciByLG89TSh0LG4pO3JldHVybiBvPyJ2YWx1ZSJpbiBvP28udmFsdWU6bnVsbD09PShyPW8uZ2V0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5jYWxsKGUuayk6dm9pZCAwfShlLG4sdCk7dmFyIHI9blt0XTtyZXR1cm4gZS5JfHwhaShyKT9yOnI9PT1OKGUudCx0KT8oQShlKSxlLm9bdF09SShlLkEuaCxyLGUpKTpyfSxoYXM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCBpbiBoKGUpfSxvd25LZXlzOmZ1bmN0aW9uKGUpe3JldHVybiBSZWZsZWN0Lm93bktleXMoaChlKSl9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9TShoKGUpLHQpO2lmKG51bGw9PXI/dm9pZCAwOnIuc2V0KXJldHVybiByLnNldC5jYWxsKGUuayxuKSwhMDtpZihlLkRbdF09ITAsIWUuUCl7aWYoZChuLE4oaChlKSx0KSkmJih2b2lkIDAhPT1ufHx1KGUudCx0KSkpcmV0dXJuITA7QShlKSxfKGUpfXJldHVybiBlLm9bdF09biwhMH0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwIT09TihlLnQsdCl8fHQgaW4gZS50PyhlLkRbdF09ITEsQShlKSxfKGUpKTpkZWxldGUgZS5EW3RdLGUubyYmZGVsZXRlIGUub1t0XSwhMH0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKGUsdCl7dmFyIG49aChlKSxyPVJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7cmV0dXJuIHI/e3dyaXRhYmxlOiEwLGNvbmZpZ3Vy",
                    "YWJsZToxIT09ZS5pfHwibGVuZ3RoIiE9PXQsZW51bWVyYWJsZTpyLmVudW1lcmFibGUsdmFsdWU6blt0XX06cn0sZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oKXtyKDExKX0sZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnQpfSxzZXRQcm90b3R5cGVPZjpmdW5jdGlvbigpe3IoMTIpfX0sSj17fTthKEcsKGZ1bmN0aW9uKGUsdCl7SltlXT1mdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHNbMF09YXJndW1lbnRzWzBdWzBdLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pKSxKLmRlbGV0ZVByb3BlcnR5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEcuZGVsZXRlUHJvcGVydHkuY2FsbCh0aGlzLGVbMF0sdCl9LEouc2V0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gRy5zZXQuY2FsbCh0aGlzLGVbMF0sdCxuLGVbMF0pfTt2YXIgWj1uZXcoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuTz1WLHRoaXMuTj0hMSwiYm9vbGVhbiI9PXR5cGVvZihudWxsPT1lP3ZvaWQgMDplLnVzZVByb3hpZXMpJiZ0aGlzLnNldFVzZVByb3hpZXMoZS51c2VQcm94aWVzKSwiYm9vbGVhbiI9PXR5cGVvZihudWxsPT1lP3ZvaWQgMDplLmF1dG9GcmVlemUpJiZ0aGlzLnNldEF1dG9GcmVlemUoZS5hdXRvRnJlZXplKSx0aGlzLnByb2R1Y2U9dGhpcy5wcm9kdWNlLmJpbmQodGhpcyksdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXM9dGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZCh0aGlzKX12YXIg",
                    "dD1lLnByb3RvdHlwZTtyZXR1cm4gdC5wcm9kdWNlPWZ1bmN0aW9uKGUsdCxuKXtpZigiZnVuY3Rpb24iPT10eXBlb2YgZSYmImZ1bmN0aW9uIiE9dHlwZW9mIHQpe3ZhciBvPXQ7dD1lO3ZhciBhPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7dm9pZCAwPT09ZSYmKGU9byk7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsaT1BcnJheShyPjE/ci0xOjApLGw9MTtsPHI7bCsrKWlbbC0xXT1hcmd1bWVudHNbbF07cmV0dXJuIGEucHJvZHVjZShlLChmdW5jdGlvbihlKXt2YXIgcjtyZXR1cm4ocj10KS5jYWxsLmFwcGx5KHIsW24sZV0uY29uY2F0KGkpKX0pKX19dmFyIGw7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIHQmJnIoNiksdm9pZCAwIT09biYmImZ1bmN0aW9uIiE9dHlwZW9mIG4mJnIoNyksaShlKSl7dmFyIHU9Uyh0aGlzKSxzPUkodGhpcyxlLHZvaWQgMCksYz0hMDt0cnl7bD10KHMpLGM9ITF9ZmluYWxseXtjP08odSk6ayh1KX1yZXR1cm4idW5kZWZpbmVkIiE9dHlwZW9mIFByb21pc2UmJmwgaW5zdGFuY2VvZiBQcm9taXNlP2wudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEUodSxuKSxqKGUsdSl9KSwoZnVuY3Rpb24oZSl7dGhyb3cgTyh1KSxlfSkpOihFKHUsbiksaihsLHUpKX1pZighZXx8Im9iamVjdCIhPXR5cGVvZiBlKXtpZigobD10KGUpKT09PVUpcmV0dXJuO3JldHVybiB2b2lkIDA9PT1sJiYobD1lKSx0aGlzLk4mJnYobCwhMCksbH1yKDIxLGUpfSx0LnByb2R1Y2VXaXRoUGF0Y2hlcz1m",
                    "dW5jdGlvbihlLHQpe3ZhciBuLHIsbz10aGlzO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBlP2Z1bmN0aW9uKHQpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9QXJyYXkobj4xP24tMTowKSxpPTE7aTxuO2krKylyW2ktMV09YXJndW1lbnRzW2ldO3JldHVybiBvLnByb2R1Y2VXaXRoUGF0Y2hlcyh0LChmdW5jdGlvbih0KXtyZXR1cm4gZS5hcHBseSh2b2lkIDAsW3RdLmNvbmNhdChyKSl9KSl9Olt0aGlzLnByb2R1Y2UoZSx0LChmdW5jdGlvbihlLHQpe249ZSxyPXR9KSksbixyXX0sdC5jcmVhdGVEcmFmdD1mdW5jdGlvbihlKXtpKGUpfHxyKDgpLG8oZSkmJihlPUQoZSkpO3ZhciB0PVModGhpcyksbj1JKHRoaXMsZSx2b2lkIDApO3JldHVybiBuW0tdLkM9ITAsayh0KSxufSx0LmZpbmlzaERyYWZ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49KGUmJmVbS10pLkE7cmV0dXJuIEUobix0KSxqKHZvaWQgMCxuKX0sdC5zZXRBdXRvRnJlZXplPWZ1bmN0aW9uKGUpe3RoaXMuTj1lfSx0LnNldFVzZVByb3hpZXM9ZnVuY3Rpb24oZSl7ZSYmIVYmJnIoMjApLHRoaXMuTz1lfSx0LmFwcGx5UGF0Y2hlcz1mdW5jdGlvbihlLHQpe3ZhciBuO2ZvcihuPXQubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciByPXRbbl07aWYoMD09PXIucGF0aC5sZW5ndGgmJiJyZXBsYWNlIj09PXIub3Ape2U9ci52YWx1ZTticmVha319dmFyIGk9ZygiUGF0Y2hlcyIpLiQ7cmV0dXJuIG8oZSk/aShlLHQpOnRoaXMucHJvZHVjZShlLChmdW5jdGlvbihlKXty",
                    "ZXR1cm4gaShlLHQuc2xpY2UobisxKSl9KSl9LGV9KCkpLGVlPVoucHJvZHVjZTtaLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFopLFouc2V0QXV0b0ZyZWV6ZS5iaW5kKFopLFouc2V0VXNlUHJveGllcy5iaW5kKFopLFouYXBwbHlQYXRjaGVzLmJpbmQoWiksWi5jcmVhdGVEcmFmdC5iaW5kKFopLFouZmluaXNoRHJhZnQuYmluZChaKTt0LmE9ZWV9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiBjfSkpLG4uZCh0LCJiIiwoZnVuY3Rpb24oKXtyZXR1cm4gV30pKTt2YXIgcj1uKDApLG89bi5uKHIpLGk9KG4oNSksby5hLmNyZWF0ZUNvbnRleHQobnVsbCkpO3ZhciBhPWZ1bmN0aW9uKGUpe2UoKX0sbD17bm90aWZ5OmZ1bmN0aW9uKCl7fX07ZnVuY3Rpb24gdSgpe3ZhciBlPWEsdD1udWxsLG49bnVsbDtyZXR1cm57Y2xlYXI6ZnVuY3Rpb24oKXt0PW51bGwsbj1udWxsfSxub3RpZnk6ZnVuY3Rpb24oKXtlKChmdW5jdGlvbigpe2Zvcih2YXIgZT10O2U7KWUuY2FsbGJhY2soKSxlPWUubmV4dH0pKX0sZ2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLG49dDtuOyllLnB1c2gobiksbj1uLm5leHQ7cmV0dXJuIGV9LHN1YnNjcmliZTpmdW5jdGlvbihlKXt2YXIgcj0hMCxvPW49e2NhbGxiYWNrOmUsbmV4dDpudWxsLHByZXY6bn07cmV0dXJuIG8ucHJldj9vLnByZXYubmV4dD1vOnQ9byxmdW5jdGlvbigpe3ImJm51bGwhPT10JiYocj0hMSxvLm5leHQ/by5uZXh0LnBy",
                    "ZXY9by5wcmV2Om49by5wcmV2LG8ucHJldj9vLnByZXYubmV4dD1vLm5leHQ6dD1vLm5leHQpfX19fXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMuc3RvcmU9ZSx0aGlzLnBhcmVudFN1Yj10LHRoaXMudW5zdWJzY3JpYmU9bnVsbCx0aGlzLmxpc3RlbmVycz1sLHRoaXMuaGFuZGxlQ2hhbmdlV3JhcHBlcj10aGlzLmhhbmRsZUNoYW5nZVdyYXBwZXIuYmluZCh0aGlzKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5hZGROZXN0ZWRTdWI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJ5U3Vic2NyaWJlKCksdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGUpfSx0Lm5vdGlmeU5lc3RlZFN1YnM9ZnVuY3Rpb24oKXt0aGlzLmxpc3RlbmVycy5ub3RpZnkoKX0sdC5oYW5kbGVDaGFuZ2VXcmFwcGVyPWZ1bmN0aW9uKCl7dGhpcy5vblN0YXRlQ2hhbmdlJiZ0aGlzLm9uU3RhdGVDaGFuZ2UoKX0sdC5pc1N1YnNjcmliZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbih0aGlzLnVuc3Vic2NyaWJlKX0sdC50cnlTdWJzY3JpYmU9ZnVuY3Rpb24oKXt0aGlzLnVuc3Vic2NyaWJlfHwodGhpcy51bnN1YnNjcmliZT10aGlzLnBhcmVudFN1Yj90aGlzLnBhcmVudFN1Yi5hZGROZXN0ZWRTdWIodGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyKTp0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNoYW5nZVdyYXBwZXIpLHRoaXMubGlzdGVuZXJzPXUoKSl9LHQudHJ5VW5zdWJzY3JpYmU9ZnVuY3Rpb24oKXt0aGlz",
                    "LnVuc3Vic2NyaWJlJiYodGhpcy51bnN1YnNjcmliZSgpLHRoaXMudW5zdWJzY3JpYmU9bnVsbCx0aGlzLmxpc3RlbmVycy5jbGVhcigpLHRoaXMubGlzdGVuZXJzPWwpfSxlfSgpO3ZhciBjPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RvcmUsbj1lLmNvbnRleHQsYT1lLmNoaWxkcmVuLGw9T2JqZWN0KHIudXNlTWVtbykoKGZ1bmN0aW9uKCl7dmFyIGU9bmV3IHModCk7cmV0dXJuIGUub25TdGF0ZUNoYW5nZT1lLm5vdGlmeU5lc3RlZFN1YnMse3N0b3JlOnQsc3Vic2NyaXB0aW9uOmV9fSksW3RdKSx1PU9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe3JldHVybiB0LmdldFN0YXRlKCl9KSxbdF0pO09iamVjdChyLnVzZUVmZmVjdCkoKGZ1bmN0aW9uKCl7dmFyIGU9bC5zdWJzY3JpcHRpb247cmV0dXJuIGUudHJ5U3Vic2NyaWJlKCksdSE9PXQuZ2V0U3RhdGUoKSYmZS5ub3RpZnlOZXN0ZWRTdWJzKCksZnVuY3Rpb24oKXtlLnRyeVVuc3Vic2NyaWJlKCksZS5vblN0YXRlQ2hhbmdlPW51bGx9fSksW2wsdV0pO3ZhciBjPW58fGk7cmV0dXJuIG8uYS5jcmVhdGVFbGVtZW50KGMuUHJvdmlkZXIse3ZhbHVlOmx9LGEpfSxkPW4oMSksZj1uKDEzKSxwPW4oMzYpLGg9bi5uKHApLG09bigyOCksdj0idW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cmJiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudCYmInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ/ci51c2VMYXlvdXRF",
                    "ZmZlY3Q6ci51c2VFZmZlY3QsYj1bXSx5PVtudWxsLG51bGxdO2Z1bmN0aW9uIGcoZSx0KXt2YXIgbj1lWzFdO3JldHVyblt0LnBheWxvYWQsbisxXX1mdW5jdGlvbiB3KGUsdCxuKXt2KChmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHZvaWQgMCx0KX0pLG4pfWZ1bmN0aW9uIHgoZSx0LG4scixvLGksYSl7ZS5jdXJyZW50PXIsdC5jdXJyZW50PW8sbi5jdXJyZW50PSExLGkuY3VycmVudCYmKGkuY3VycmVudD1udWxsLGEoKSl9ZnVuY3Rpb24gRShlLHQsbixyLG8saSxhLGwsdSxzKXtpZihlKXt2YXIgYz0hMSxkPW51bGwsZj1mdW5jdGlvbigpe2lmKCFjKXt2YXIgZSxuLGY9dC5nZXRTdGF0ZSgpO3RyeXtlPXIoZixvLmN1cnJlbnQpfWNhdGNoKHApe249cCxkPXB9bnx8KGQ9bnVsbCksZT09PWkuY3VycmVudD9hLmN1cnJlbnR8fHUoKTooaS5jdXJyZW50PWUsbC5jdXJyZW50PWUsYS5jdXJyZW50PSEwLHMoe3R5cGU6IlNUT1JFX1VQREFURUQiLHBheWxvYWQ6e2Vycm9yOm59fSkpfX07bi5vblN0YXRlQ2hhbmdlPWYsbi50cnlTdWJzY3JpYmUoKSxmKCk7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoYz0hMCxuLnRyeVVuc3Vic2NyaWJlKCksbi5vblN0YXRlQ2hhbmdlPW51bGwsZCl0aHJvdyBkfX19dmFyIE89ZnVuY3Rpb24oKXtyZXR1cm5bbnVsbCwwXX07ZnVuY3Rpb24gayhlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgbj10LGE9bi5nZXREaXNwbGF5TmFtZSxsPXZvaWQgMD09PWE/ZnVuY3Rpb24oZSl7cmV0dXJuIkNv",
                    "bm5lY3RBZHZhbmNlZCgiK2UrIikifTphLHU9bi5tZXRob2ROYW1lLGM9dm9pZCAwPT09dT8iY29ubmVjdEFkdmFuY2VkIjp1LHA9bi5yZW5kZXJDb3VudFByb3Asdj12b2lkIDA9PT1wP3ZvaWQgMDpwLGs9bi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsUz12b2lkIDA9PT1rfHxrLEM9bi5zdG9yZUtleSxqPXZvaWQgMD09PUM/InN0b3JlIjpDLFQ9KG4ud2l0aFJlZixuLmZvcndhcmRSZWYpLFA9dm9pZCAwIT09VCYmVCxSPW4uY29udGV4dCxOPXZvaWQgMD09PVI/aTpSLE09T2JqZWN0KGYuYSkobixbImdldERpc3BsYXlOYW1lIiwibWV0aG9kTmFtZSIsInJlbmRlckNvdW50UHJvcCIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsInN0b3JlS2V5Iiwid2l0aFJlZiIsImZvcndhcmRSZWYiLCJjb250ZXh0Il0pLF89TjtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49dC5kaXNwbGF5TmFtZXx8dC5uYW1lfHwiQ29tcG9uZW50IixpPWwobiksYT1PYmplY3QoZC5hKSh7fSxNLHtnZXREaXNwbGF5TmFtZTpsLG1ldGhvZE5hbWU6YyxyZW5kZXJDb3VudFByb3A6dixzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6UyxzdG9yZUtleTpqLGRpc3BsYXlOYW1lOmksd3JhcHBlZENvbXBvbmVudE5hbWU6bixXcmFwcGVkQ29tcG9uZW50OnR9KSx1PU0ucHVyZTt2YXIgcD11P3IudXNlTWVtbzpmdW5jdGlvbihlKXtyZXR1cm4gZSgpfTtmdW5jdGlvbiBrKG4pe3ZhciBpPU9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe3ZhciBlPW4u",
                    "cmVhY3RSZWR1eEZvcndhcmRlZFJlZix0PU9iamVjdChmLmEpKG4sWyJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIl0pO3JldHVybltuLmNvbnRleHQsZSx0XX0pLFtuXSksbD1pWzBdLHU9aVsxXSxjPWlbMl0saD1PYmplY3Qoci51c2VNZW1vKSgoZnVuY3Rpb24oKXtyZXR1cm4gbCYmbC5Db25zdW1lciYmT2JqZWN0KG0uaXNDb250ZXh0Q29uc3VtZXIpKG8uYS5jcmVhdGVFbGVtZW50KGwuQ29uc3VtZXIsbnVsbCkpP2w6X30pLFtsLF9dKSx2PU9iamVjdChyLnVzZUNvbnRleHQpKGgpLGs9Qm9vbGVhbihuLnN0b3JlKSYmQm9vbGVhbihuLnN0b3JlLmdldFN0YXRlKSYmQm9vbGVhbihuLnN0b3JlLmRpc3BhdGNoKTtCb29sZWFuKHYpJiZCb29sZWFuKHYuc3RvcmUpO3ZhciBDPWs/bi5zdG9yZTp2LnN0b3JlLGo9T2JqZWN0KHIudXNlTWVtbykoKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlKHQuZGlzcGF0Y2gsYSl9KEMpfSksW0NdKSxUPU9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe2lmKCFTKXJldHVybiB5O3ZhciBlPW5ldyBzKEMsaz9udWxsOnYuc3Vic2NyaXB0aW9uKSx0PWUubm90aWZ5TmVzdGVkU3Vicy5iaW5kKGUpO3JldHVybltlLHRdfSksW0Msayx2XSksUD1UWzBdLFI9VFsxXSxOPU9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe3JldHVybiBrP3Y6T2JqZWN0KGQuYSkoe30sdix7c3Vic2NyaXB0aW9uOlB9KX0pLFtrLHYsUF0pLE09T2JqZWN0KHIudXNlUmVkdWNlcikoZyxi",
                    "LE8pLEE9TVswXVswXSxJPU1bMV07aWYoQSYmQS5lcnJvcil0aHJvdyBBLmVycm9yO3ZhciBEPU9iamVjdChyLnVzZVJlZikoKSx6PU9iamVjdChyLnVzZVJlZikoYyksTD1PYmplY3Qoci51c2VSZWYpKCksRj1PYmplY3Qoci51c2VSZWYpKCExKSwkPXAoKGZ1bmN0aW9uKCl7cmV0dXJuIEwuY3VycmVudCYmYz09PXouY3VycmVudD9MLmN1cnJlbnQ6aihDLmdldFN0YXRlKCksYyl9KSxbQyxBLGNdKTt3KHgsW3osRCxGLGMsJCxMLFJdKSx3KEUsW1MsQyxQLGoseixELEYsTCxSLEldLFtDLFAsal0pO3ZhciBXPU9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe3JldHVybiBvLmEuY3JlYXRlRWxlbWVudCh0LE9iamVjdChkLmEpKHt9LCQse3JlZjp1fSkpfSksW3UsdCwkXSk7cmV0dXJuIE9iamVjdChyLnVzZU1lbW8pKChmdW5jdGlvbigpe3JldHVybiBTP28uYS5jcmVhdGVFbGVtZW50KGguUHJvdmlkZXIse3ZhbHVlOk59LFcpOld9KSxbaCxXLE5dKX12YXIgQz11P28uYS5tZW1vKGspOms7aWYoQy5XcmFwcGVkQ29tcG9uZW50PXQsQy5kaXNwbGF5TmFtZT1pLFApe3ZhciBUPW8uYS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3JldHVybiBvLmEuY3JlYXRlRWxlbWVudChDLE9iamVjdChkLmEpKHt9LGUse3JlYWN0UmVkdXhGb3J3YXJkZWRSZWY6dH0pKX0pKTtyZXR1cm4gVC5kaXNwbGF5TmFtZT1pLFQuV3JhcHBlZENvbXBvbmVudD10LGgoKShULHQpfXJldHVybiBoKCkoQyx0KX19ZnVuY3Rpb24gUyhlLHQpe3Jl",
                    "dHVybiBlPT09dD8wIT09ZXx8MCE9PXR8fDEvZT09PTEvdDplIT09ZSYmdCE9PXR9ZnVuY3Rpb24gQyhlLHQpe2lmKFMoZSx0KSlyZXR1cm4hMDtpZigib2JqZWN0IiE9PXR5cGVvZiBlfHxudWxsPT09ZXx8Im9iamVjdCIhPT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuITE7dmFyIG49T2JqZWN0LmtleXMoZSkscj1PYmplY3Qua2V5cyh0KTtpZihuLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbz0wO288bi5sZW5ndGg7bysrKWlmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuW29dKXx8IVMoZVtuW29dXSx0W25bb11dKSlyZXR1cm4hMTtyZXR1cm4hMH12YXIgaj1uKDE4KTtmdW5jdGlvbiBUKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe3ZhciByPWUodCxuKTtmdW5jdGlvbiBvKCl7cmV0dXJuIHJ9cmV0dXJuIG8uZGVwZW5kc09uT3duUHJvcHM9ITEsb319ZnVuY3Rpb24gUChlKXtyZXR1cm4gbnVsbCE9PWUuZGVwZW5kc09uT3duUHJvcHMmJnZvaWQgMCE9PWUuZGVwZW5kc09uT3duUHJvcHM/Qm9vbGVhbihlLmRlcGVuZHNPbk93blByb3BzKToxIT09ZS5sZW5ndGh9ZnVuY3Rpb24gUihlLHQpe3JldHVybiBmdW5jdGlvbih0LG4pe24uZGlzcGxheU5hbWU7dmFyIHI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci5kZXBlbmRzT25Pd25Qcm9wcz9yLm1hcFRvUHJvcHMoZSx0KTpyLm1hcFRvUHJvcHMoZSl9O3JldHVybiByLmRlcGVuZHNPbk93blByb3BzPSEwLHIubWFwVG9Qcm9w",
                    "cz1mdW5jdGlvbih0LG4pe3IubWFwVG9Qcm9wcz1lLHIuZGVwZW5kc09uT3duUHJvcHM9UChlKTt2YXIgbz1yKHQsbik7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBvJiYoci5tYXBUb1Byb3BzPW8sci5kZXBlbmRzT25Pd25Qcm9wcz1QKG8pLG89cih0LG4pKSxvfSxyfX12YXIgTj1bZnVuY3Rpb24oZSl7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBlP1IoZSk6dm9pZCAwfSxmdW5jdGlvbihlKXtyZXR1cm4gZT92b2lkIDA6VCgoZnVuY3Rpb24oZSl7cmV0dXJue2Rpc3BhdGNoOmV9fSkpfSxmdW5jdGlvbihlKXtyZXR1cm4gZSYmIm9iamVjdCI9PT10eXBlb2YgZT9UKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KGouYikoZSx0KX0pKTp2b2lkIDB9XTt2YXIgTT1bZnVuY3Rpb24oZSl7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBlP1IoZSk6dm9pZCAwfSxmdW5jdGlvbihlKXtyZXR1cm4gZT92b2lkIDA6VCgoZnVuY3Rpb24oKXtyZXR1cm57fX0pKX1dO2Z1bmN0aW9uIF8oZSx0LG4pe3JldHVybiBPYmplY3QoZC5hKSh7fSxuLHt9LGUse30sdCl9dmFyIEE9W2Z1bmN0aW9uKGUpe3JldHVybiJmdW5jdGlvbiI9PT10eXBlb2YgZT9mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxuKXtuLmRpc3BsYXlOYW1lO3ZhciByLG89bi5wdXJlLGk9bi5hcmVNZXJnZWRQcm9wc0VxdWFsLGE9ITE7cmV0dXJuIGZ1bmN0aW9uKHQsbixsKXt2YXIgdT1lKHQsbixsKTtyZXR1cm4gYT9vJiZpKHUscil8fChyPXUpOihhPSEw",
                    "LHI9dSkscn19fShlKTp2b2lkIDB9LGZ1bmN0aW9uKGUpe3JldHVybiBlP3ZvaWQgMDpmdW5jdGlvbigpe3JldHVybiBffX1dO2Z1bmN0aW9uIEkoZSx0LG4scil7cmV0dXJuIGZ1bmN0aW9uKG8saSl7cmV0dXJuIG4oZShvLGkpLHQocixpKSxpKX19ZnVuY3Rpb24gRChlLHQsbixyLG8pe3ZhciBpLGEsbCx1LHMsYz1vLmFyZVN0YXRlc0VxdWFsLGQ9by5hcmVPd25Qcm9wc0VxdWFsLGY9by5hcmVTdGF0ZVByb3BzRXF1YWwscD0hMTtmdW5jdGlvbiBoKG8scCl7dmFyIGg9IWQocCxhKSxtPSFjKG8saSk7cmV0dXJuIGk9byxhPXAsaCYmbT8obD1lKGksYSksdC5kZXBlbmRzT25Pd25Qcm9wcyYmKHU9dChyLGEpKSxzPW4obCx1LGEpKTpoPyhlLmRlcGVuZHNPbk93blByb3BzJiYobD1lKGksYSkpLHQuZGVwZW5kc09uT3duUHJvcHMmJih1PXQocixhKSkscz1uKGwsdSxhKSk6bT9mdW5jdGlvbigpe3ZhciB0PWUoaSxhKSxyPSFmKHQsbCk7cmV0dXJuIGw9dCxyJiYocz1uKGwsdSxhKSksc30oKTpzfXJldHVybiBmdW5jdGlvbihvLGMpe3JldHVybiBwP2gobyxjKToobD1lKGk9byxhPWMpLHU9dChyLGEpLHM9bihsLHUsYSkscD0hMCxzKX19ZnVuY3Rpb24geihlLHQpe3ZhciBuPXQuaW5pdE1hcFN0YXRlVG9Qcm9wcyxyPXQuaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxvPXQuaW5pdE1lcmdlUHJvcHMsaT1PYmplY3QoZi5hKSh0LFsiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVy",
                    "Z2VQcm9wcyJdKSxhPW4oZSxpKSxsPXIoZSxpKSx1PW8oZSxpKTtyZXR1cm4oaS5wdXJlP0Q6SSkoYSxsLHUsZSxpKX1mdW5jdGlvbiBMKGUsdCxuKXtmb3IodmFyIHI9dC5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89dFtyXShlKTtpZihvKXJldHVybiBvfXJldHVybiBmdW5jdGlvbih0LHIpe3Rocm93IG5ldyBFcnJvcigiSW52YWxpZCB2YWx1ZSBvZiB0eXBlICIrdHlwZW9mIGUrIiBmb3IgIituKyIgYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAiK3Iud3JhcHBlZENvbXBvbmVudE5hbWUrIi4iKX19ZnVuY3Rpb24gRihlLHQpe3JldHVybiBlPT09dH1mdW5jdGlvbiAkKGUpe3ZhciB0PXZvaWQgMD09PWU/e306ZSxuPXQuY29ubmVjdEhPQyxyPXZvaWQgMD09PW4/azpuLG89dC5tYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsaT12b2lkIDA9PT1vP006byxhPXQubWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLGw9dm9pZCAwPT09YT9OOmEsdT10Lm1lcmdlUHJvcHNGYWN0b3JpZXMscz12b2lkIDA9PT11P0E6dSxjPXQuc2VsZWN0b3JGYWN0b3J5LHA9dm9pZCAwPT09Yz96OmM7cmV0dXJuIGZ1bmN0aW9uKGUsdCxuLG8pe3ZvaWQgMD09PW8mJihvPXt9KTt2YXIgYT1vLHU9YS5wdXJlLGM9dm9pZCAwPT09dXx8dSxoPWEuYXJlU3RhdGVzRXF1YWwsbT12b2lkIDA9PT1oP0Y6aCx2PWEuYXJlT3duUHJvcHNFcXVhbCxiPXZvaWQgMD09PXY/Qzp2LHk9YS5hcmVTdGF0ZVByb3BzRXF1YWwsZz12b2lkIDA9PT15",
                    "P0M6eSx3PWEuYXJlTWVyZ2VkUHJvcHNFcXVhbCx4PXZvaWQgMD09PXc/Qzp3LEU9T2JqZWN0KGYuYSkoYSxbInB1cmUiLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIl0pLE89TChlLGksIm1hcFN0YXRlVG9Qcm9wcyIpLGs9TCh0LGwsIm1hcERpc3BhdGNoVG9Qcm9wcyIpLFM9TChuLHMsIm1lcmdlUHJvcHMiKTtyZXR1cm4gcihwLE9iamVjdChkLmEpKHttZXRob2ROYW1lOiJjb25uZWN0IixnZXREaXNwbGF5TmFtZTpmdW5jdGlvbihlKXtyZXR1cm4iQ29ubmVjdCgiK2UrIikifSxzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6Qm9vbGVhbihlKSxpbml0TWFwU3RhdGVUb1Byb3BzOk8saW5pdE1hcERpc3BhdGNoVG9Qcm9wczprLGluaXRNZXJnZVByb3BzOlMscHVyZTpjLGFyZVN0YXRlc0VxdWFsOm0sYXJlT3duUHJvcHNFcXVhbDpiLGFyZVN0YXRlUHJvcHNFcXVhbDpnLGFyZU1lcmdlZFByb3BzRXF1YWw6eH0sRSkpfX12YXIgVz0kKCk7dmFyIEIsSD1uKDgpO0I9SC51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxhPUJ9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiB2fSkpLG4uZCh0LCJiIiwoZnVuY3Rpb24oKXtyZXR1cm4gZH0pKSxuLmQodCwiYyIsKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSksbi5kKHQsImQiLChmdW5jdGlvbigpe3JldHVybiBtfSkpLG4uZCh0LCJlIiwo",
                    "ZnVuY3Rpb24oKXtyZXR1cm4gbH0pKTt2YXIgcj1uKDU0KSxvPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgiIikuam9pbigiLiIpfSxpPXtJTklUOiJAQHJlZHV4L0lOSVQiK28oKSxSRVBMQUNFOiJAQHJlZHV4L1JFUExBQ0UiK28oKSxQUk9CRV9VTktOT1dOX0FDVElPTjpmdW5jdGlvbigpe3JldHVybiJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OIitvKCl9fTtmdW5jdGlvbiBhKGUpe2lmKCJvYmplY3QiIT09dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiExO2Zvcih2YXIgdD1lO251bGwhPT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7KXQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT10fWZ1bmN0aW9uIGwoZSx0LG4pe3ZhciBvO2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgdCYmImZ1bmN0aW9uIj09PXR5cGVvZiBufHwiZnVuY3Rpb24iPT09dHlwZW9mIG4mJiJmdW5jdGlvbiI9PT10eXBlb2YgYXJndW1lbnRzWzNdKXRocm93IG5ldyBFcnJvcigiSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIik7aWYoImZ1bmN0aW9uIj09PXR5cGVvZiB0JiYidW5kZWZpbmVkIj09PXR5",
                    "cGVvZiBuJiYobj10LHQ9dm9pZCAwKSwidW5kZWZpbmVkIiE9PXR5cGVvZiBuKXtpZigiZnVuY3Rpb24iIT09dHlwZW9mIG4pdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4iKTtyZXR1cm4gbihsKShlLHQpfWlmKCJmdW5jdGlvbiIhPT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoIkV4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIik7dmFyIHU9ZSxzPXQsYz1bXSxkPWMsZj0hMTtmdW5jdGlvbiBwKCl7ZD09PWMmJihkPWMuc2xpY2UoKSl9ZnVuY3Rpb24gaCgpe2lmKGYpdGhyb3cgbmV3IEVycm9yKCJZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBUaGUgcmVkdWNlciBoYXMgYWxyZWFkeSByZWNlaXZlZCB0aGUgc3RhdGUgYXMgYW4gYXJndW1lbnQuIFBhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuIik7cmV0dXJuIHN9ZnVuY3Rpb24gbShlKXtpZigiZnVuY3Rpb24iIT09dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4iKTtpZihmKXRocm93IG5ldyBFcnJvcigiWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlm",
                    "aWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhIGNvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpLXJlZmVyZW5jZS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLiIpO3ZhciB0PSEwO3JldHVybiBwKCksZC5wdXNoKGUpLGZ1bmN0aW9uKCl7aWYodCl7aWYoZil0aHJvdyBuZXcgRXJyb3IoIllvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGktcmVmZXJlbmNlL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuIik7dD0hMSxwKCk7dmFyIG49ZC5pbmRleE9mKGUpO2Quc3BsaWNlKG4sMSksYz1udWxsfX19ZnVuY3Rpb24gdihlKXtpZighYShlKSl0aHJvdyBuZXcgRXJyb3IoIkFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuIik7aWYoInVuZGVmaW5lZCI9PT10eXBlb2YgZS50eXBlKXRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkICJ0eXBlIiBwcm9wZXJ0eS4gSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO2lm",
                    "KGYpdGhyb3cgbmV3IEVycm9yKCJSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuIik7dHJ5e2Y9ITAscz11KHMsZSl9ZmluYWxseXtmPSExfWZvcih2YXIgdD1jPWQsbj0wO248dC5sZW5ndGg7bisrKXsoMCx0W25dKSgpfXJldHVybiBlfWZ1bmN0aW9uIGIoZSl7aWYoImZ1bmN0aW9uIiE9PXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIik7dT1lLHYoe3R5cGU6aS5SRVBMQUNFfSl9ZnVuY3Rpb24geSgpe3ZhciBlLHQ9bTtyZXR1cm4oZT17c3Vic2NyaWJlOmZ1bmN0aW9uKGUpe2lmKCJvYmplY3QiIT09dHlwZW9mIGV8fG51bGw9PT1lKXRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIik7ZnVuY3Rpb24gbigpe2UubmV4dCYmZS5uZXh0KGgoKSl9cmV0dXJuIG4oKSx7dW5zdWJzY3JpYmU6dChuKX19fSlbci5hXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlfXJldHVybiB2KHt0eXBlOmkuSU5JVH0pLChvPXtkaXNwYXRjaDp2LHN1YnNjcmliZTptLGdldFN0YXRlOmgscmVwbGFjZVJlZHVjZXI6Yn0pW3IuYV09eSxvfWZ1bmN0aW9uIHUoZSx0KXt2YXIgbj10JiZ0LnR5cGU7cmV0dXJuIkdpdmVuICIrKG4mJidhY3Rpb24gIicrU3RyaW5nKG4pKyciJ3x8ImFuIGFjdGlvbiIpKycsIHJlZHVjZXIgIicrZSsnIiByZXR1cm5lZCB1bmRlZmluZWQuIFRvIGlnbm9yZSBhbiBhY3Rp",
                    "b24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJ31mdW5jdGlvbiBzKGUpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPXt9LHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTswLCJmdW5jdGlvbiI9PT10eXBlb2YgZVtvXSYmKG5bb109ZVtvXSl9dmFyIGEsbD1PYmplY3Qua2V5cyhuKTt0cnl7IWZ1bmN0aW9uKGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPWVbdF07aWYoInVuZGVmaW5lZCI9PT10eXBlb2Ygbih2b2lkIDAse3R5cGU6aS5JTklUfSkpdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyICInK3QrIlwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuIik7aWYoInVuZGVmaW5lZCI9PT10eXBlb2Ygbih2b2lkIDAse3R5cGU6aS5QUk9CRV9VTktOT1dOX0FDVElP",
                    "TigpfSkpdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyICInK3QrIlwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuIERvbid0IHRyeSB0byBoYW5kbGUgIitpLklOSVQrJyBvciBvdGhlciBhY3Rpb25zIGluICJyZWR1eC8qIiBuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyl9KSl9KG4pfWNhdGNoKHMpe2E9c31yZXR1cm4gZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT1lJiYoZT17fSksYSl0aHJvdyBhO2Zvcih2YXIgcj0hMSxvPXt9LGk9MDtpPGwubGVuZ3RoO2krKyl7dmFyIHM9bFtpXSxjPW5bc10sZD1lW3NdLGY9YyhkLHQpO2lmKCJ1bmRlZmluZWQiPT09dHlwZW9mIGYpe3ZhciBwPXUocyx0KTt0aHJvdyBuZXcgRXJyb3IocCl9b1tzXT1mLHI9cnx8ZiE9PWR9cmV0dXJuKHI9cnx8bC5sZW5ndGghPT1PYmplY3Qua2V5cyhlKS5sZW5ndGgpP286ZX19ZnVuY3Rpb24gYyhlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KGUuYXBwbHkodGhp",
                    "cyxhcmd1bWVudHMpKX19ZnVuY3Rpb24gZChlLHQpe2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgZSlyZXR1cm4gYyhlLHQpO2lmKCJvYmplY3QiIT09dHlwZW9mIGV8fG51bGw9PT1lKXRocm93IG5ldyBFcnJvcigiYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICIrKG51bGw9PT1lPyJudWxsIjp0eXBlb2YgZSkrJy4gRGlkIHlvdSB3cml0ZSAiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb20iIGluc3RlYWQgb2YgImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb20iPycpO3ZhciBuPXt9O2Zvcih2YXIgciBpbiBlKXt2YXIgbz1lW3JdOyJmdW5jdGlvbiI9PT10eXBlb2YgbyYmKG5bcl09YyhvLHQpKX1yZXR1cm4gbn1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBwKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJm4ucHVzaC5hcHBseShuLE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSkpLHQmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLG59ZnVuY3Rpb24gaChlKXtmb3IodmFyIHQ9",
                    "MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9wKG4sITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe2YoZSx0LG5bdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpOnAobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkpfSkpfXJldHVybiBlfWZ1bmN0aW9uIG0oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxuPTA7bjxlO24rKyl0W25dPWFyZ3VtZW50c1tuXTtyZXR1cm4gMD09PXQubGVuZ3RoP2Z1bmN0aW9uKGUpe3JldHVybiBlfToxPT09dC5sZW5ndGg/dFswXTp0LnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZSh0LmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpKX19KSl9ZnVuY3Rpb24gdigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLG49MDtuPGU7bisrKXRbbl09YXJndW1lbnRzW25dO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj1lLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpLHI9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoIkRpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVj",
                    "dGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuIE90aGVyIG1pZGRsZXdhcmUgd291bGQgbm90IGJlIGFwcGxpZWQgdG8gdGhpcyBkaXNwYXRjaC4iKX0sbz17Z2V0U3RhdGU6bi5nZXRTdGF0ZSxkaXNwYXRjaDpmdW5jdGlvbigpe3JldHVybiByLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpfX0saT10Lm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUobyl9KSk7cmV0dXJuIGgoe30sbix7ZGlzcGF0Y2g6cj1tLmFwcGx5KHZvaWQgMCxpKShuLmRpc3BhdGNoKX0pfX19fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTt2YXIgcj1uKDQwKTt2YXIgbz1uKDMzKSxpPW4oNDIpO2Z1bmN0aW9uIGEoZSx0KXtyZXR1cm4gT2JqZWN0KHIuYSkoZSl8fGZ1bmN0aW9uKGUsdCl7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSxsPWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT1sLm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7cj0hMCk7fWNhdGNoKHUpe289ITAsaT11fWZpbmFsbHl7dHJ5e3J8fG51bGw9PWwucmV0dXJufHxsLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn19KGUsdCl8fE9iamVjdChvLmEpKGUsdCl8fE9iamVjdChpLmEpKCl9fSxmdW5j",
                    "dGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgcj1uKDApLG89InVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93P3IudXNlTGF5b3V0RWZmZWN0OnIudXNlRWZmZWN0O2Z1bmN0aW9uIGkoZSl7dmFyIHQ9ci51c2VSZWYoZSk7cmV0dXJuIG8oKGZ1bmN0aW9uKCl7dC5jdXJyZW50PWV9KSksci51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXtyZXR1cm4gdC5jdXJyZW50LmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpfSksW10pfX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxlLl9fcHJvdG9fXz10fW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSk7dmFyIHI9big5NSksbz0obigwKSxuKDQ5KSk7ZnVuY3Rpb24gaSgpe3JldHVybiBPYmplY3Qoci5hKSgpfHxvLmF9fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMCksbz1yLmNyZWF0ZUNvbnRleHQoKTt0LmE9b30sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk7dmFyIHI9bigzNyk7dmFyIG89big0MSksaT1uKDMzKTtmdW5jdGlvbiBhKGUpe3JldHVybiBmdW5j",
                    "dGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBPYmplY3Qoci5hKShlKX0oZSl8fE9iamVjdChvLmEpKGUpfHxPYmplY3QoaS5hKShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKX0oKX19LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpeyJmdW5jdGlvbiI9PT10eXBlb2YgZT9lKHQpOmUmJihlLmN1cnJlbnQ9dCl9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSwsLGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPW4oODIpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuKHI9ImZ1bmN0aW9uIj09PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/InN5bWJvbCI6dHlwZW9mIGV9KShlKX1uLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0",
                    "cmljdCI7ZnVuY3Rpb24gcihlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsbD1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9bC5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaCh1KXtvPSEwLGk9dX1maW5hbGx5e3RyeXtyfHxudWxsPT1sLnJldHVybnx8bC5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59fShlLHQpfHxmdW5jdGlvbihlLHQpe2lmKGUpe2lmKCJzdHJpbmciPT09dHlwZW9mIGUpcmV0dXJuIHIoZSx0KTt2YXIgbj1PYmplY3QucHJvdG90eXBl",
                    "LnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7cmV0dXJuIk9iamVjdCI9PT1uJiZlLmNvbnN0cnVjdG9yJiYobj1lLmNvbnN0cnVjdG9yLm5hbWUpLCJNYXAiPT09bnx8IlNldCI9PT1uP0FycmF5LmZyb20obik6IkFyZ3VtZW50cyI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9yKGUsdCk6dm9pZCAwfX0oZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfSgpfW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYiIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSksbi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiBvfSkpO3ZhciByPWZ1bmN0aW9uKGUpe3JldHVybiBlLnNjcm9sbFRvcH07ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPWUudGltZW91dCxyPWUuc3R5bGUsbz12b2lkIDA9PT1yP3t9OnI7cmV0dXJue2R1cmF0aW9uOm8udHJhbnNpdGlvbkR1cmF0aW9ufHwibnVtYmVyIj09PXR5cGVvZiBuP246blt0Lm1vZGVdfHwwLGRlbGF5Om8udHJhbnNpdGlvbkRlbGF5fX19LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7bi5k",
                    "KHQsImEiLChmdW5jdGlvbigpe3JldHVybiBvfSkpO3ZhciByPW4oMzcpO2Z1bmN0aW9uIG8oZSx0KXtpZihlKXtpZigic3RyaW5nIj09PXR5cGVvZiBlKXJldHVybiBPYmplY3Qoci5hKShlLHQpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm4iT2JqZWN0Ij09PW4mJmUuY29uc3RydWN0b3ImJihuPWUuY29uc3RydWN0b3IubmFtZSksIk1hcCI9PT1ufHwiU2V0Ij09PW4/QXJyYXkuZnJvbShlKToiQXJndW1lbnRzIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP09iamVjdChyLmEpKGUsdCk6dm9pZCAwfX19LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigwKSxvPW4ubihyKTt0LmE9by5hLmNyZWF0ZUNvbnRleHQobnVsbCl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLCJ2YWx1ZSJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIG8oZSx0LG4pe3JldHVybiB0JiZyKGUucHJvdG90eXBlLHQpLG4mJnIoZSxuKSxlfW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIg",
                    "cj1uKDI4KSxvPXtjaGlsZENvbnRleHRUeXBlczohMCxjb250ZXh0VHlwZTohMCxjb250ZXh0VHlwZXM6ITAsZGVmYXVsdFByb3BzOiEwLGRpc3BsYXlOYW1lOiEwLGdldERlZmF1bHRQcm9wczohMCxnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6ITAsZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiEwLG1peGluczohMCxwcm9wVHlwZXM6ITAsdHlwZTohMH0saT17bmFtZTohMCxsZW5ndGg6ITAscHJvdG90eXBlOiEwLGNhbGxlcjohMCxjYWxsZWU6ITAsYXJndW1lbnRzOiEwLGFyaXR5OiEwfSxhPXskJHR5cGVvZjohMCxjb21wYXJlOiEwLGRlZmF1bHRQcm9wczohMCxkaXNwbGF5TmFtZTohMCxwcm9wVHlwZXM6ITAsdHlwZTohMH0sbD17fTtmdW5jdGlvbiB1KGUpe3JldHVybiByLmlzTWVtbyhlKT9hOmxbZS4kJHR5cGVvZl18fG99bFtyLkZvcndhcmRSZWZdPXskJHR5cGVvZjohMCxyZW5kZXI6ITAsZGVmYXVsdFByb3BzOiEwLGRpc3BsYXlOYW1lOiEwLHByb3BUeXBlczohMH0sbFtyLk1lbW9dPWE7dmFyIHM9T2JqZWN0LmRlZmluZVByb3BlcnR5LGM9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsZD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixwPU9iamVjdC5nZXRQcm90b3R5cGVPZixoPU9iamVjdC5wcm90b3R5cGU7ZS5leHBvcnRzPWZ1bmN0aW9uIGUodCxuLHIpe2lmKCJzdHJpbmciIT09dHlwZW9mIG4pe2lmKGgpe3ZhciBvPXAobik7byYmbyE9",
                    "PWgmJmUodCxvLHIpfXZhciBhPWMobik7ZCYmKGE9YS5jb25jYXQoZChuKSkpO2Zvcih2YXIgbD11KHQpLG09dShuKSx2PTA7djxhLmxlbmd0aDsrK3Ype3ZhciBiPWFbdl07aWYoIWlbYl0mJighcnx8IXJbYl0pJiYoIW18fCFtW2JdKSYmKCFsfHwhbFtiXSkpe3ZhciB5PWYobixiKTt0cnl7cyh0LGIseSl9Y2F0Y2goZyl7fX19fXJldHVybiB0fX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBuPTAscj1uZXcgQXJyYXkodCk7bjx0O24rKylyW25dPWVbbl07cmV0dXJuIHJ9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIpO3JldHVybiBlfW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10LmRpc3BhdGNoLHI9dC5nZXRTdGF0ZTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiJmdW5jdGlvbiI9PT10eXBlb2Ygbz9vKG4scixlKTp0KG8pfX19fXZhciBvPXIoKTtvLndpdGhFeHRy",
                    "YUFyZ3VtZW50PXIsdC5hPW99LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gQXJyYXkuZnJvbShlKX1uLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIil9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJiIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgcj1uKDIpLG89e2Vhc2VJbk91dDoiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKSIsZWFzZU91dDoiY3ViaWMtYmV6aWVyKDAuMCwgMCwgMC4yLCAxKSIsZWFzZUluOiJjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKSIsc2hhcnA6ImN1YmljLWJlemllcigwLjQsIDAsIDAuNiwg",
                    "MSkifSxpPXtzaG9ydGVzdDoxNTAsc2hvcnRlcjoyMDAsc2hvcnQ6MjUwLHN0YW5kYXJkOjMwMCxjb21wbGV4OjM3NSxlbnRlcmluZ1NjcmVlbjoyMjUsbGVhdmluZ1NjcmVlbjoxOTV9O2Z1bmN0aW9uIGEoZSl7cmV0dXJuIiIuY29uY2F0KE1hdGgucm91bmQoZSksIm1zIil9dC5hPXtlYXNpbmc6byxkdXJhdGlvbjppLGNyZWF0ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbImFsbCJdLHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49dC5kdXJhdGlvbixsPXZvaWQgMD09PW4/aS5zdGFuZGFyZDpuLHU9dC5lYXNpbmcscz12b2lkIDA9PT11P28uZWFzZUluT3V0OnUsYz10LmRlbGF5LGQ9dm9pZCAwPT09Yz8wOmM7T2JqZWN0KHIuYSkodCxbImR1cmF0aW9uIiwiZWFzaW5nIiwiZGVsYXkiXSk7cmV0dXJuKEFycmF5LmlzQXJyYXkoZSk/ZTpbZV0pLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIiIuY29uY2F0KGUsIiAiKS5jb25jYXQoInN0cmluZyI9PT10eXBlb2YgbD9sOmEobCksIiAiKS5jb25jYXQocywiICIpLmNvbmNhdCgic3RyaW5nIj09PXR5cGVvZiBkP2Q6YShkKSl9KSkuam9pbigiLCIpfSxnZXRBdXRvSGVpZ2h0RHVyYXRpb246ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIDA7dmFyIHQ9ZS8zNjtyZXR1cm4gTWF0aC5yb3VuZCgxMCooNCsxNSpNYXRoLnBvdyh0LC4y",
                    "NSkrdC81KSl9fX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt0LmE9e21vYmlsZVN0ZXBwZXI6MWUzLHNwZWVkRGlhbDoxMDUwLGFwcEJhcjoxMTAwLGRyYXdlcjoxMjAwLG1vZGFsOjEzMDAsc25hY2tiYXI6MTQwMCx0b29sdGlwOjE1MDB9fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKTt2YXIgcj1uKDApO2Z1bmN0aW9uIG8oZSl7dmFyIHQ9ZS5jb250cm9sbGVkLG49ZS5kZWZhdWx0LG89KGUubmFtZSxlLnN0YXRlLHIudXNlUmVmKHZvaWQgMCE9PXQpLmN1cnJlbnQpLGk9ci51c2VTdGF0ZShuKSxhPWlbMF0sbD1pWzFdO3JldHVybltvP3Q6YSxyLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtvfHxsKGUpfSksW10pXX19LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigwKSxvPXIuY3JlYXRlQ29udGV4dCh7fSk7dC5hPW99LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigwKSxvPXIuY3JlYXRlQ29udGV4dCgpO3QuYT1vfSxmdW5jdGlvbihlLHQsbil7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBlPSJtaWxsaXNlY29uZCIsdD0ic2Vjb25kIixuPSJtaW51dGUiLHI9ImhvdXIiLG89ImRheSIsaT0id2VlayIsYT0ibW9udGgiLGw9InF1YXJ0ZXIiLHU9InllYXIiLHM9ImRhdGUiLGM9L14oXGR7NH0pWy0vXT8oXGR7MSwyfSk/Wy0vXT8oXGR7MCwyfSlbXjAtOV0qKFxkezEsMn0pPzo/",
                    "KFxkezEsMn0pPzo/KFxkezEsMn0pPy4/KFxkKyk/JC8sZD0vXFsoW15cXV0rKV18WXsyLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLGY9e25hbWU6ImVuIix3ZWVrZGF5czoiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXkiLnNwbGl0KCJfIiksbW9udGhzOiJKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyIi5zcGxpdCgiXyIpfSxwPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1TdHJpbmcoZSk7cmV0dXJuIXJ8fHIubGVuZ3RoPj10P2U6IiIrQXJyYXkodCsxLXIubGVuZ3RoKS5qb2luKG4pK2V9LGg9e3M6cCx6OmZ1bmN0aW9uKGUpe3ZhciB0PS1lLnV0Y09mZnNldCgpLG49TWF0aC5hYnModCkscj1NYXRoLmZsb29yKG4vNjApLG89biU2MDtyZXR1cm4odDw9MD8iKyI6Ii0iKStwKHIsMiwiMCIpKyI6IitwKG8sMiwiMCIpfSxtOmZ1bmN0aW9uIGUodCxuKXtpZih0LmRhdGUoKTxuLmRhdGUoKSlyZXR1cm4tZShuLHQpO3ZhciByPTEyKihuLnllYXIoKS10LnllYXIoKSkrKG4ubW9udGgoKS10Lm1vbnRoKCkpLG89dC5jbG9uZSgpLmFkZChyLGEpLGk9bi1vPDAsbD10LmNsb25lKCkuYWRkKHIrKGk/LTE6MSksYSk7cmV0dXJuKygtKHIrKG4tbykvKGk/by1sOmwtbykpfHwwKX0sYTpmdW5jdGlv",
                    "bihlKXtyZXR1cm4gZTwwP01hdGguY2VpbChlKXx8MDpNYXRoLmZsb29yKGUpfSxwOmZ1bmN0aW9uKGMpe3JldHVybntNOmEseTp1LHc6aSxkOm8sRDpzLGg6cixtOm4sczp0LG1zOmUsUTpsfVtjXXx8U3RyaW5nKGN8fCIiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLywiIil9LHU6ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWV9fSxtPSJlbiIsdj17fTt2W21dPWY7dmFyIGI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB4fSx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZighZSlyZXR1cm4gbTtpZigic3RyaW5nIj09dHlwZW9mIGUpdltlXSYmKHI9ZSksdCYmKHZbZV09dCxyPWUpO2Vsc2V7dmFyIG89ZS5uYW1lO3Zbb109ZSxyPW99cmV0dXJuIW4mJnImJihtPXIpLHJ8fCFuJiZtfSxnPWZ1bmN0aW9uKGUsdCl7aWYoYihlKSlyZXR1cm4gZS5jbG9uZSgpO3ZhciBuPSJvYmplY3QiPT10eXBlb2YgdD90Ont9O3JldHVybiBuLmRhdGU9ZSxuLmFyZ3M9YXJndW1lbnRzLG5ldyB4KG4pfSx3PWg7dy5sPXksdy5pPWIsdy53PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGcoZSx7bG9jYWxlOnQuJEwsdXRjOnQuJHUseDp0LiR4LCRvZmZzZXQ6dC4kb2Zmc2V0fSl9O3ZhciB4PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZihlKXt0aGlzLiRMPXRoaXMuJEx8fHkoZS5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZShlKX12YXIgcD1mLnByb3RvdHlwZTtyZXR1cm4gcC5wYXJzZT1mdW5jdGlvbihlKXt0aGlzLiRkPWZ1bmN0",
                    "aW9uKGUpe3ZhciB0PWUuZGF0ZSxuPWUudXRjO2lmKG51bGw9PT10KXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKHcudSh0KSlyZXR1cm4gbmV3IERhdGU7aWYodCBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKHQpO2lmKCJzdHJpbmciPT10eXBlb2YgdCYmIS9aJC9pLnRlc3QodCkpe3ZhciByPXQubWF0Y2goYyk7aWYocil7dmFyIG89clsyXS0xfHwwLGk9KHJbN118fCIwIikuc3Vic3RyaW5nKDAsMyk7cmV0dXJuIG4/bmV3IERhdGUoRGF0ZS5VVEMoclsxXSxvLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAsaSkpOm5ldyBEYXRlKHJbMV0sbyxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLGkpfX1yZXR1cm4gbmV3IERhdGUodCl9KGUpLHRoaXMuJHg9ZS54fHx7fSx0aGlzLmluaXQoKX0scC5pbml0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy4kZDt0aGlzLiR5PWUuZ2V0RnVsbFllYXIoKSx0aGlzLiRNPWUuZ2V0TW9udGgoKSx0aGlzLiREPWUuZ2V0RGF0ZSgpLHRoaXMuJFc9ZS5nZXREYXkoKSx0aGlzLiRIPWUuZ2V0SG91cnMoKSx0aGlzLiRtPWUuZ2V0TWludXRlcygpLHRoaXMuJHM9ZS5nZXRTZWNvbmRzKCksdGhpcy4kbXM9ZS5nZXRNaWxsaXNlY29uZHMoKX0scC4kdXRpbHM9ZnVuY3Rpb24oKXtyZXR1cm4gd30scC5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuISgiSW52YWxpZCBEYXRlIj09PXRoaXMuJGQudG9TdHJpbmcoKSl9LHAuaXNTYW1lPWZ1bmN0aW9uKGUsdCl7dmFyIG49Zyhl",
                    "KTtyZXR1cm4gdGhpcy5zdGFydE9mKHQpPD1uJiZuPD10aGlzLmVuZE9mKHQpfSxwLmlzQWZ0ZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZyhlKTx0aGlzLnN0YXJ0T2YodCl9LHAuaXNCZWZvcmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmRPZih0KTxnKGUpfSxwLiRnPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdy51KGUpP3RoaXNbdF06dGhpcy5zZXQobixlKX0scC51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0scC52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxwLnN0YXJ0T2Y9ZnVuY3Rpb24oZSxsKXt2YXIgYz10aGlzLGQ9ISF3LnUobCl8fGwsZj13LnAoZSkscD1mdW5jdGlvbihlLHQpe3ZhciBuPXcudyhjLiR1P0RhdGUuVVRDKGMuJHksdCxlKTpuZXcgRGF0ZShjLiR5LHQsZSksYyk7cmV0dXJuIGQ/bjpuLmVuZE9mKG8pfSxoPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHcudyhjLnRvRGF0ZSgpW2VdLmFwcGx5KGMudG9EYXRlKCJzIiksKGQ/WzAsMCwwLDBdOlsyMyw1OSw1OSw5OTldKS5zbGljZSh0KSksYyl9LG09dGhpcy4kVyx2PXRoaXMuJE0sYj10aGlzLiRELHk9InNldCIrKHRoaXMuJHU/IlVUQyI6IiIpO3N3aXRjaChmKXtjYXNlIHU6cmV0dXJuIGQ/cCgxLDApOnAoMzEsMTEpO2Nhc2UgYTpyZXR1cm4gZD9wKDEsdik6cCgwLHYrMSk7Y2FzZSBpOnZhciBnPXRoaXMuJGxvY2FsZSgpLndlZWtTdGFydHx8MCx4PShtPGc/",
                    "bSs3Om0pLWc7cmV0dXJuIHAoZD9iLXg6YisoNi14KSx2KTtjYXNlIG86Y2FzZSBzOnJldHVybiBoKHkrIkhvdXJzIiwwKTtjYXNlIHI6cmV0dXJuIGgoeSsiTWludXRlcyIsMSk7Y2FzZSBuOnJldHVybiBoKHkrIlNlY29uZHMiLDIpO2Nhc2UgdDpyZXR1cm4gaCh5KyJNaWxsaXNlY29uZHMiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LHAuZW5kT2Y9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc3RhcnRPZihlLCExKX0scC4kc2V0PWZ1bmN0aW9uKGksbCl7dmFyIGMsZD13LnAoaSksZj0ic2V0IisodGhpcy4kdT8iVVRDIjoiIikscD0oYz17fSxjW29dPWYrIkRhdGUiLGNbc109ZisiRGF0ZSIsY1thXT1mKyJNb250aCIsY1t1XT1mKyJGdWxsWWVhciIsY1tyXT1mKyJIb3VycyIsY1tuXT1mKyJNaW51dGVzIixjW3RdPWYrIlNlY29uZHMiLGNbZV09ZisiTWlsbGlzZWNvbmRzIixjKVtkXSxoPWQ9PT1vP3RoaXMuJEQrKGwtdGhpcy4kVyk6bDtpZihkPT09YXx8ZD09PXUpe3ZhciBtPXRoaXMuY2xvbmUoKS5zZXQocywxKTttLiRkW3BdKGgpLG0uaW5pdCgpLHRoaXMuJGQ9bS5zZXQocyxNYXRoLm1pbih0aGlzLiRELG0uZGF5c0luTW9udGgoKSkpLiRkfWVsc2UgcCYmdGhpcy4kZFtwXShoKTtyZXR1cm4gdGhpcy5pbml0KCksdGhpc30scC5zZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5jbG9uZSgpLiRzZXQoZSx0KX0scC5nZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbdy5wKGUpXSgpfSxwLmFkZD1m",
                    "dW5jdGlvbihlLGwpe3ZhciBzLGM9dGhpcztlPU51bWJlcihlKTt2YXIgZD13LnAobCksZj1mdW5jdGlvbih0KXt2YXIgbj1nKGMpO3JldHVybiB3Lncobi5kYXRlKG4uZGF0ZSgpK01hdGgucm91bmQodCplKSksYyl9O2lmKGQ9PT1hKXJldHVybiB0aGlzLnNldChhLHRoaXMuJE0rZSk7aWYoZD09PXUpcmV0dXJuIHRoaXMuc2V0KHUsdGhpcy4keStlKTtpZihkPT09bylyZXR1cm4gZigxKTtpZihkPT09aSlyZXR1cm4gZig3KTt2YXIgcD0ocz17fSxzW25dPTZlNCxzW3JdPTM2ZTUsc1t0XT0xZTMscylbZF18fDEsaD10aGlzLiRkLmdldFRpbWUoKStlKnA7cmV0dXJuIHcudyhoLHRoaXMpfSxwLnN1YnRyYWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYWRkKC0xKmUsdCl9LHAuZm9ybWF0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiJJbnZhbGlkIERhdGUiO3ZhciBuPWV8fCJZWVlZLU1NLUREVEhIOm1tOnNzWiIscj13LnoodGhpcyksbz10aGlzLiRsb2NhbGUoKSxpPXRoaXMuJEgsYT10aGlzLiRtLGw9dGhpcy4kTSx1PW8ud2Vla2RheXMscz1vLm1vbnRocyxjPWZ1bmN0aW9uKGUscixvLGkpe3JldHVybiBlJiYoZVtyXXx8ZSh0LG4pKXx8b1tyXS5zdWJzdHIoMCxpKX0sZj1mdW5jdGlvbihlKXtyZXR1cm4gdy5zKGklMTJ8fDEyLGUsIjAiKX0scD1vLm1lcmlkaWVtfHxmdW5jdGlvbihlLHQsbil7dmFyIHI9ZTwxMj8iQU0iOiJQTSI7cmV0dXJuIG4/ci50b0xvd2VyQ2Fz",
                    "ZSgpOnJ9LGg9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06bCsxLE1NOncucyhsKzEsMiwiMCIpLE1NTTpjKG8ubW9udGhzU2hvcnQsbCxzLDMpLE1NTU06YyhzLGwpLEQ6dGhpcy4kRCxERDp3LnModGhpcy4kRCwyLCIwIiksZDpTdHJpbmcodGhpcy4kVyksZGQ6YyhvLndlZWtkYXlzTWluLHRoaXMuJFcsdSwyKSxkZGQ6YyhvLndlZWtkYXlzU2hvcnQsdGhpcy4kVyx1LDMpLGRkZGQ6dVt0aGlzLiRXXSxIOlN0cmluZyhpKSxISDp3LnMoaSwyLCIwIiksaDpmKDEpLGhoOmYoMiksYTpwKGksYSwhMCksQTpwKGksYSwhMSksbTpTdHJpbmcoYSksbW06dy5zKGEsMiwiMCIpLHM6U3RyaW5nKHRoaXMuJHMpLHNzOncucyh0aGlzLiRzLDIsIjAiKSxTU1M6dy5zKHRoaXMuJG1zLDMsIjAiKSxaOnJ9O3JldHVybiBuLnJlcGxhY2UoZCwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8aFtlXXx8ci5yZXBsYWNlKCI6IiwiIil9KSl9LHAudXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LHAuZGlmZj1mdW5jdGlvbihlLHMsYyl7dmFyIGQsZj13LnAocykscD1nKGUpLGg9NmU0KihwLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpLG09dGhpcy1wLHY9dy5tKHRoaXMscCk7cmV0dXJuIHY9KGQ9e30sZFt1XT12LzEyLGRbYV09dixkW2xdPXYvMyxkW2ldPShtLWgpLzYwNDhlNSxkW29dPShtLWgpLzg2NGU1LGRbcl09",
                    "bS8zNmU1LGRbbl09bS82ZTQsZFt0XT1tLzFlMyxkKVtmXXx8bSxjP3Y6dy5hKHYpfSxwLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoYSkuJER9LHAuJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiB2W3RoaXMuJExdfSxwLmxvY2FsZT1mdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybiB0aGlzLiRMO3ZhciBuPXRoaXMuY2xvbmUoKSxyPXkoZSx0LCEwKTtyZXR1cm4gciYmKG4uJEw9ciksbn0scC5jbG9uZT1mdW5jdGlvbigpe3JldHVybiB3LncodGhpcy4kZCx0aGlzKX0scC50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxwLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0scC50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LHAudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxmfSgpLEU9eC5wcm90b3R5cGU7cmV0dXJuIGcucHJvdG90eXBlPUUsW1siJG1zIixlXSxbIiRzIix0XSxbIiRtIixuXSxbIiRIIixyXSxbIiRXIixvXSxbIiRNIixhXSxbIiR5Iix1XSxbIiREIixzXV0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7RVtlWzFdXT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy4kZyh0LGVbMF0sZVsxXSl9fSkpLGcuZXh0ZW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUodCx4LGcpLGd9LGcubG9jYWxlPXks",
                    "Zy5pc0RheWpzPWIsZy51bml4PWZ1bmN0aW9uKGUpe3JldHVybiBnKDFlMyplKX0sZy5lbj12W21dLGcuTHM9dixnfSgpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMzApLG89bigyKSxpPW4oMTI1KSxhPW4oMSksbD1bInhzIiwic20iLCJtZCIsImxnIiwieGwiXTtmdW5jdGlvbiB1KGUpe3ZhciB0PWUudmFsdWVzLG49dm9pZCAwPT09dD97eHM6MCxzbTo2MDAsbWQ6OTYwLGxnOjEyODAseGw6MTkyMH06dCxyPWUudW5pdCxpPXZvaWQgMD09PXI/InB4IjpyLHU9ZS5zdGVwLHM9dm9pZCAwPT09dT81OnUsYz1PYmplY3Qoby5hKShlLFsidmFsdWVzIiwidW5pdCIsInN0ZXAiXSk7ZnVuY3Rpb24gZChlKXt2YXIgdD0ibnVtYmVyIj09PXR5cGVvZiBuW2VdP25bZV06ZTtyZXR1cm4iQG1lZGlhIChtaW4td2lkdGg6Ii5jb25jYXQodCkuY29uY2F0KGksIikiKX1mdW5jdGlvbiBmKGUsdCl7dmFyIHI9bC5pbmRleE9mKHQpO3JldHVybiByPT09bC5sZW5ndGgtMT9kKGUpOiJAbWVkaWEgKG1pbi13aWR0aDoiLmNvbmNhdCgibnVtYmVyIj09PXR5cGVvZiBuW2VdP25bZV06ZSkuY29uY2F0KGksIikgYW5kICIpKyIobWF4LXdpZHRoOiIuY29uY2F0KCgtMSE9PXImJiJudW1iZXIiPT09dHlwZW9mIG5bbFtyKzFdXT9uW2xbcisxXV06dCktcy8xMDApLmNvbmNhdChpLCIpIil9cmV0dXJuIE9iamVjdChhLmEpKHtrZXlzOmwsdmFsdWVzOm4sdXA6ZCxkb3duOmZ1bmN0aW9uKGUpe3ZhciB0PWwuaW5kZXhPZihl",
                    "KSsxLHI9bltsW3RdXTtyZXR1cm4gdD09PWwubGVuZ3RoP2QoInhzIik6IkBtZWRpYSAobWF4LXdpZHRoOiIuY29uY2F0KCgibnVtYmVyIj09PXR5cGVvZiByJiZ0PjA/cjplKS1zLzEwMCkuY29uY2F0KGksIikiKX0sYmV0d2VlbjpmLG9ubHk6ZnVuY3Rpb24oZSl7cmV0dXJuIGYoZSxlKX0sd2lkdGg6ZnVuY3Rpb24oZSl7cmV0dXJuIG5bZV19fSxjKX1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgbztyZXR1cm4gT2JqZWN0KGEuYSkoe2d1dHRlcnM6ZnVuY3Rpb24oKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307cmV0dXJuIE9iamVjdChhLmEpKHtwYWRkaW5nTGVmdDp0KDIpLHBhZGRpbmdSaWdodDp0KDIpfSxuLE9iamVjdChyLmEpKHt9LGUudXAoInNtIiksT2JqZWN0KGEuYSkoe3BhZGRpbmdMZWZ0OnQoMykscGFkZGluZ1JpZ2h0OnQoMyl9LG5bZS51cCgic20iKV0pKSl9LHRvb2xiYXI6KG89e21pbkhlaWdodDo1Nn0sT2JqZWN0KHIuYSkobywiIi5jb25jYXQoZS51cCgieHMiKSwiIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkiKSx7bWluSGVpZ2h0OjQ4fSksT2JqZWN0KHIuYSkobyxlLnVwKCJzbSIpLHttaW5IZWlnaHQ6NjR9KSxvKX0sbil9dmFyIGM9big2NiksZD17YmxhY2s6IiMwMDAiLHdoaXRlOiIjZmZmIn0sZj17NTA6IiNmYWZhZmEiLDEwMDoiI2Y1ZjVmNSIsMjAwOiIjZWVlZWVlIiwzMDA6IiNlMGUwZTAiLDQwMDoiI2JkYmRiZCIs",
                    "NTAwOiIjOWU5ZTllIiw2MDA6IiM3NTc1NzUiLDcwMDoiIzYxNjE2MSIsODAwOiIjNDI0MjQyIiw5MDA6IiMyMTIxMjEiLEExMDA6IiNkNWQ1ZDUiLEEyMDA6IiNhYWFhYWEiLEE0MDA6IiMzMDMwMzAiLEE3MDA6IiM2MTYxNjEifSxwPXs1MDoiI2U4ZWFmNiIsMTAwOiIjYzVjYWU5IiwyMDA6IiM5ZmE4ZGEiLDMwMDoiIzc5ODZjYiIsNDAwOiIjNWM2YmMwIiw1MDA6IiMzZjUxYjUiLDYwMDoiIzM5NDlhYiIsNzAwOiIjMzAzZjlmIiw4MDA6IiMyODM1OTMiLDkwMDoiIzFhMjM3ZSIsQTEwMDoiIzhjOWVmZiIsQTIwMDoiIzUzNmRmZSIsQTQwMDoiIzNkNWFmZSIsQTcwMDoiIzMwNGZmZSJ9LGg9ezUwOiIjZmNlNGVjIiwxMDA6IiNmOGJiZDAiLDIwMDoiI2Y0OGZiMSIsMzAwOiIjZjA2MjkyIiw0MDA6IiNlYzQwN2EiLDUwMDoiI2U5MWU2MyIsNjAwOiIjZDgxYjYwIiw3MDA6IiNjMjE4NWIiLDgwMDoiI2FkMTQ1NyIsOTAwOiIjODgwZTRmIixBMTAwOiIjZmY4MGFiIixBMjAwOiIjZmY0MDgxIixBNDAwOiIjZjUwMDU3IixBNzAwOiIjYzUxMTYyIn0sbT17NTA6IiNmZmViZWUiLDEwMDoiI2ZmY2RkMiIsMjAwOiIjZWY5YTlhIiwzMDA6IiNlNTczNzMiLDQwMDoiI2VmNTM1MCIsNTAwOiIjZjQ0MzM2Iiw2MDA6IiNlNTM5MzUiLDcwMDoiI2QzMmYyZiIsODAwOiIjYzYyODI4Iiw5MDA6IiNiNzFjMWMiLEExMDA6IiNmZjhhODAiLEEyMDA6IiNmZjUyNTIiLEE0MDA6IiNmZjE3NDQiLEE3MDA6IiNkNTAwMDAifSx2PXs1MDoiI2Zm",
                    "ZjNlMCIsMTAwOiIjZmZlMGIyIiwyMDA6IiNmZmNjODAiLDMwMDoiI2ZmYjc0ZCIsNDAwOiIjZmZhNzI2Iiw1MDA6IiNmZjk4MDAiLDYwMDoiI2ZiOGMwMCIsNzAwOiIjZjU3YzAwIiw4MDA6IiNlZjZjMDAiLDkwMDoiI2U2NTEwMCIsQTEwMDoiI2ZmZDE4MCIsQTIwMDoiI2ZmYWI0MCIsQTQwMDoiI2ZmOTEwMCIsQTcwMDoiI2ZmNmQwMCJ9LGI9ezUwOiIjZTNmMmZkIiwxMDA6IiNiYmRlZmIiLDIwMDoiIzkwY2FmOSIsMzAwOiIjNjRiNWY2Iiw0MDA6IiM0MmE1ZjUiLDUwMDoiIzIxOTZmMyIsNjAwOiIjMWU4OGU1Iiw3MDA6IiMxOTc2ZDIiLDgwMDoiIzE1NjVjMCIsOTAwOiIjMGQ0N2ExIixBMTAwOiIjODJiMWZmIixBMjAwOiIjNDQ4YWZmIixBNDAwOiIjMjk3OWZmIixBNzAwOiIjMjk2MmZmIn0seT17NTA6IiNlOGY1ZTkiLDEwMDoiI2M4ZTZjOSIsMjAwOiIjYTVkNmE3IiwzMDA6IiM4MWM3ODQiLDQwMDoiIzY2YmI2YSIsNTAwOiIjNGNhZjUwIiw2MDA6IiM0M2EwNDciLDcwMDoiIzM4OGUzYyIsODAwOiIjMmU3ZDMyIiw5MDA6IiMxYjVlMjAiLEExMDA6IiNiOWY2Y2EiLEEyMDA6IiM2OWYwYWUiLEE0MDA6IiMwMGU2NzYiLEE3MDA6IiMwMGM4NTMifSxnPW4oMTEpLHc9e3RleHQ6e3ByaW1hcnk6InJnYmEoMCwgMCwgMCwgMC44NykiLHNlY29uZGFyeToicmdiYSgwLCAwLCAwLCAwLjU0KSIsZGlzYWJsZWQ6InJnYmEoMCwgMCwgMCwgMC4zOCkiLGhpbnQ6InJnYmEoMCwgMCwgMCwgMC4zOCkifSxkaXZpZGVyOiJyZ2Jh",
                    "KDAsIDAsIDAsIDAuMTIpIixiYWNrZ3JvdW5kOntwYXBlcjpkLndoaXRlLGRlZmF1bHQ6Zls1MF19LGFjdGlvbjp7YWN0aXZlOiJyZ2JhKDAsIDAsIDAsIDAuNTQpIixob3ZlcjoicmdiYSgwLCAwLCAwLCAwLjA0KSIsaG92ZXJPcGFjaXR5Oi4wNCxzZWxlY3RlZDoicmdiYSgwLCAwLCAwLCAwLjA4KSIsc2VsZWN0ZWRPcGFjaXR5Oi4wOCxkaXNhYmxlZDoicmdiYSgwLCAwLCAwLCAwLjI2KSIsZGlzYWJsZWRCYWNrZ3JvdW5kOiJyZ2JhKDAsIDAsIDAsIDAuMTIpIixkaXNhYmxlZE9wYWNpdHk6LjM4LGZvY3VzOiJyZ2JhKDAsIDAsIDAsIDAuMTIpIixmb2N1c09wYWNpdHk6LjEyLGFjdGl2YXRlZE9wYWNpdHk6LjEyfX0seD17dGV4dDp7cHJpbWFyeTpkLndoaXRlLHNlY29uZGFyeToicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpIixkaXNhYmxlZDoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpIixoaW50OiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkiLGljb246InJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSJ9LGRpdmlkZXI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMikiLGJhY2tncm91bmQ6e3BhcGVyOmZbODAwXSxkZWZhdWx0OiIjMzAzMDMwIn0sYWN0aW9uOnthY3RpdmU6ZC53aGl0ZSxob3ZlcjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KSIsaG92ZXJPcGFjaXR5Oi4wOCxzZWxlY3RlZDoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KSIsc2VsZWN0ZWRPcGFjaXR5Oi4xNixkaXNhYmxlZDoicmdiYSgyNTUsIDI1NSwg",
                    "MjU1LCAwLjMpIixkaXNhYmxlZEJhY2tncm91bmQ6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMikiLGRpc2FibGVkT3BhY2l0eTouMzgsZm9jdXM6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMikiLGZvY3VzT3BhY2l0eTouMTIsYWN0aXZhdGVkT3BhY2l0eTouMjR9fTtmdW5jdGlvbiBFKGUsdCxuLHIpe3ZhciBvPXIubGlnaHR8fHIsaT1yLmRhcmt8fDEuNSpyO2VbdF18fChlLmhhc093blByb3BlcnR5KG4pP2VbdF09ZVtuXToibGlnaHQiPT09dD9lLmxpZ2h0PU9iamVjdChnLmQpKGUubWFpbixvKToiZGFyayI9PT10JiYoZS5kYXJrPU9iamVjdChnLmEpKGUubWFpbixpKSkpfWZ1bmN0aW9uIE8oZSl7dmFyIHQ9ZS5wcmltYXJ5LG49dm9pZCAwPT09dD97bGlnaHQ6cFszMDBdLG1haW46cFs1MDBdLGRhcms6cFs3MDBdfTp0LHI9ZS5zZWNvbmRhcnksbD12b2lkIDA9PT1yP3tsaWdodDpoLkEyMDAsbWFpbjpoLkE0MDAsZGFyazpoLkE3MDB9OnIsdT1lLmVycm9yLHM9dm9pZCAwPT09dT97bGlnaHQ6bVszMDBdLG1haW46bVs1MDBdLGRhcms6bVs3MDBdfTp1LE89ZS53YXJuaW5nLGs9dm9pZCAwPT09Tz97bGlnaHQ6dlszMDBdLG1haW46dls1MDBdLGRhcms6dls3MDBdfTpPLFM9ZS5pbmZvLEM9dm9pZCAwPT09Uz97bGlnaHQ6YlszMDBdLG1haW46Yls1MDBdLGRhcms6Yls3MDBdfTpTLGo9ZS5zdWNjZXNzLFQ9dm9pZCAwPT09aj97bGlnaHQ6eVszMDBdLG1haW46eVs1MDBdLGRhcms6eVs3MDBdfTpqLFA9ZS50eXBlLFI9",
                    "dm9pZCAwPT09UD8ibGlnaHQiOlAsTj1lLmNvbnRyYXN0VGhyZXNob2xkLE09dm9pZCAwPT09Tj8zOk4sXz1lLnRvbmFsT2Zmc2V0LEE9dm9pZCAwPT09Xz8uMjpfLEk9T2JqZWN0KG8uYSkoZSxbInByaW1hcnkiLCJzZWNvbmRhcnkiLCJlcnJvciIsIndhcm5pbmciLCJpbmZvIiwic3VjY2VzcyIsInR5cGUiLCJjb250cmFzdFRocmVzaG9sZCIsInRvbmFsT2Zmc2V0Il0pO2Z1bmN0aW9uIEQoZSl7cmV0dXJuIE9iamVjdChnLmMpKGUseC50ZXh0LnByaW1hcnkpPj1NP3gudGV4dC5wcmltYXJ5OncudGV4dC5wcmltYXJ5fXZhciB6PWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTo1MDAsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06MzAwLHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOjcwMDtpZighKGU9T2JqZWN0KGEuYSkoe30sZSkpLm1haW4mJmVbdF0mJihlLm1haW49ZVt0XSksIWUubWFpbil0aHJvdyBuZXcgRXJyb3IoT2JqZWN0KGMuYSkoNCx0KSk7aWYoInN0cmluZyIhPT10eXBlb2YgZS5tYWluKXRocm93IG5ldyBFcnJvcihPYmplY3QoYy5hKSg1LEpTT04uc3RyaW5naWZ5KGUubWFpbikpKTtyZXR1cm4gRShlLCJsaWdodCIsbixBKSxFKGUsImRhcmsiLHIsQSksZS5jb250cmFzdFRleHR8fChlLmNvbnRyYXN0VGV4dD1E",
                    "KGUubWFpbikpLGV9LEw9e2Rhcms6eCxsaWdodDp3fTtyZXR1cm4gT2JqZWN0KGkuYSkoT2JqZWN0KGEuYSkoe2NvbW1vbjpkLHR5cGU6UixwcmltYXJ5Onoobiksc2Vjb25kYXJ5OnoobCwiQTQwMCIsIkEyMDAiLCJBNzAwIiksZXJyb3I6eihzKSx3YXJuaW5nOnooayksaW5mbzp6KEMpLHN1Y2Nlc3M6eihUKSxncmV5OmYsY29udHJhc3RUaHJlc2hvbGQ6TSxnZXRDb250cmFzdFRleHQ6RCxhdWdtZW50Q29sb3I6eix0b25hbE9mZnNldDpBfSxMW1JdKSxJKX1mdW5jdGlvbiBrKGUpe3JldHVybiBNYXRoLnJvdW5kKDFlNSplKS8xZTV9dmFyIFM9e3RleHRUcmFuc2Zvcm06InVwcGVyY2FzZSJ9O2Z1bmN0aW9uIEMoZSx0KXt2YXIgbj0iZnVuY3Rpb24iPT09dHlwZW9mIHQ/dChlKTp0LHI9bi5mb250RmFtaWx5LGw9dm9pZCAwPT09cj8nIlJvYm90byIsICJIZWx2ZXRpY2EiLCAiQXJpYWwiLCBzYW5zLXNlcmlmJzpyLHU9bi5mb250U2l6ZSxzPXZvaWQgMD09PXU/MTQ6dSxjPW4uZm9udFdlaWdodExpZ2h0LGQ9dm9pZCAwPT09Yz8zMDA6YyxmPW4uZm9udFdlaWdodFJlZ3VsYXIscD12b2lkIDA9PT1mPzQwMDpmLGg9bi5mb250V2VpZ2h0TWVkaXVtLG09dm9pZCAwPT09aD81MDA6aCx2PW4uZm9udFdlaWdodEJvbGQsYj12b2lkIDA9PT12PzcwMDp2LHk9bi5odG1sRm9udFNpemUsZz12b2lkIDA9PT15PzE2Onksdz1uLmFsbFZhcmlhbnRzLHg9bi5weFRvUmVtLEU9T2JqZWN0KG8uYSkobixbImZvbnRGYW1pbHkiLCJmb250",
                    "U2l6ZSIsImZvbnRXZWlnaHRMaWdodCIsImZvbnRXZWlnaHRSZWd1bGFyIiwiZm9udFdlaWdodE1lZGl1bSIsImZvbnRXZWlnaHRCb2xkIiwiaHRtbEZvbnRTaXplIiwiYWxsVmFyaWFudHMiLCJweFRvUmVtIl0pO3ZhciBPPXMvMTQsQz14fHxmdW5jdGlvbihlKXtyZXR1cm4iIi5jb25jYXQoZS9nKk8sInJlbSIpfSxqPWZ1bmN0aW9uKGUsdCxuLHIsbyl7cmV0dXJuIE9iamVjdChhLmEpKHtmb250RmFtaWx5OmwsZm9udFdlaWdodDplLGZvbnRTaXplOkModCksbGluZUhlaWdodDpufSwnIlJvYm90byIsICJIZWx2ZXRpY2EiLCAiQXJpYWwiLCBzYW5zLXNlcmlmJz09PWw/e2xldHRlclNwYWNpbmc6IiIuY29uY2F0KGsoci90KSwiZW0iKX06e30sbyx3KX0sVD17aDE6aihkLDk2LDEuMTY3LC0xLjUpLGgyOmooZCw2MCwxLjIsLS41KSxoMzpqKHAsNDgsMS4xNjcsMCksaDQ6aihwLDM0LDEuMjM1LC4yNSksaDU6aihwLDI0LDEuMzM0LDApLGg2OmoobSwyMCwxLjYsLjE1KSxzdWJ0aXRsZTE6aihwLDE2LDEuNzUsLjE1KSxzdWJ0aXRsZTI6aihtLDE0LDEuNTcsLjEpLGJvZHkxOmoocCwxNiwxLjUsLjE1KSxib2R5MjpqKHAsMTQsMS40MywuMTUpLGJ1dHRvbjpqKG0sMTQsMS43NSwuNCxTKSxjYXB0aW9uOmoocCwxMiwxLjY2LC40KSxvdmVybGluZTpqKHAsMTIsMi42NiwxLFMpfTtyZXR1cm4gT2JqZWN0KGkuYSkoT2JqZWN0KGEuYSkoe2h0bWxGb250U2l6ZTpnLHB4VG9SZW06Qyxyb3VuZDprLGZvbnRGYW1pbHk6bCxmb250",
                    "U2l6ZTpzLGZvbnRXZWlnaHRMaWdodDpkLGZvbnRXZWlnaHRSZWd1bGFyOnAsZm9udFdlaWdodE1lZGl1bTptLGZvbnRXZWlnaHRCb2xkOmJ9LFQpLEUse2Nsb25lOiExfSl9ZnVuY3Rpb24gaigpe3JldHVyblsiIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aDw9MD92b2lkIDA6YXJndW1lbnRzWzBdLCJweCAiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aDw9MT92b2lkIDA6YXJndW1lbnRzWzFdLCJweCAiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aDw9Mj92b2lkIDA6YXJndW1lbnRzWzJdLCJweCAiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aDw9Mz92b2lkIDA6YXJndW1lbnRzWzNdLCJweCByZ2JhKDAsMCwwLCIpLmNvbmNhdCguMiwiKSIpLCIiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD00P3ZvaWQgMDphcmd1bWVudHNbNF0sInB4ICIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD01P3ZvaWQgMDphcmd1bWVudHNbNV0sInB4ICIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD02P3ZvaWQgMDphcmd1bWVudHNbNl0sInB4ICIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD03P3ZvaWQgMDphcmd1bWVudHNbN10sInB4IHJnYmEoMCwwLDAsIikuY29uY2F0KC4xNCwiKSIpLCIiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD04P3ZvaWQgMDphcmd1bWVudHNbOF0sInB4ICIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD05P3ZvaWQgMDphcmd1bWVudHNbOV0sInB4ICIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoPD0xMD92",
                    "b2lkIDA6YXJndW1lbnRzWzEwXSwicHggIikuY29uY2F0KGFyZ3VtZW50cy5sZW5ndGg8PTExP3ZvaWQgMDphcmd1bWVudHNbMTFdLCJweCByZ2JhKDAsMCwwLCIpLmNvbmNhdCguMTIsIikiKV0uam9pbigiLCIpfXZhciBUPVsibm9uZSIsaigwLDIsMSwtMSwwLDEsMSwwLDAsMSwzLDApLGooMCwzLDEsLTIsMCwyLDIsMCwwLDEsNSwwKSxqKDAsMywzLC0yLDAsMyw0LDAsMCwxLDgsMCksaigwLDIsNCwtMSwwLDQsNSwwLDAsMSwxMCwwKSxqKDAsMyw1LC0xLDAsNSw4LDAsMCwxLDE0LDApLGooMCwzLDUsLTEsMCw2LDEwLDAsMCwxLDE4LDApLGooMCw0LDUsLTIsMCw3LDEwLDEsMCwyLDE2LDEpLGooMCw1LDUsLTMsMCw4LDEwLDEsMCwzLDE0LDIpLGooMCw1LDYsLTMsMCw5LDEyLDEsMCwzLDE2LDIpLGooMCw2LDYsLTMsMCwxMCwxNCwxLDAsNCwxOCwzKSxqKDAsNiw3LC00LDAsMTEsMTUsMSwwLDQsMjAsMyksaigwLDcsOCwtNCwwLDEyLDE3LDIsMCw1LDIyLDQpLGooMCw3LDgsLTQsMCwxMywxOSwyLDAsNSwyNCw0KSxqKDAsNyw5LC00LDAsMTQsMjEsMiwwLDUsMjYsNCksaigwLDgsOSwtNSwwLDE1LDIyLDIsMCw2LDI4LDUpLGooMCw4LDEwLC01LDAsMTYsMjQsMiwwLDYsMzAsNSksaigwLDgsMTEsLTUsMCwxNywyNiwyLDAsNiwzMiw1KSxqKDAsOSwxMSwtNSwwLDE4LDI4LDIsMCw3LDM0LDYpLGooMCw5LDEyLC02LDAsMTksMjksMiwwLDcsMzYsNiksaigwLDEwLDEzLC02LDAsMjAsMzEsMywwLDgsMzgsNyksaigwLDEw",
                    "LDEzLC02LDAsMjEsMzMsMywwLDgsNDAsNyksaigwLDEwLDE0LC02LDAsMjIsMzUsMywwLDgsNDIsNyksaigwLDExLDE0LC03LDAsMjMsMzYsMywwLDksNDQsOCksaigwLDExLDE1LC03LDAsMjQsMzgsMywwLDksNDYsOCldLFA9e2JvcmRlclJhZGl1czo0fSxSPW4oMTkpLE49KG4oMjQpLG4oMjkpKTtuKDUpO3ZhciBNPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/T2JqZWN0KGkuYSkoZSx0LHtjbG9uZTohMX0pOmV9LF89e3hzOjAsc206NjAwLG1kOjk2MCxsZzoxMjgwLHhsOjE5MjB9LEE9e2tleXM6WyJ4cyIsInNtIiwibWQiLCJsZyIsInhsIl0sdXA6ZnVuY3Rpb24oZSl7cmV0dXJuIkBtZWRpYSAobWluLXdpZHRoOiIuY29uY2F0KF9bZV0sInB4KSIpfX07dmFyIEk9e206Im1hcmdpbiIscDoicGFkZGluZyJ9LEQ9e3Q6IlRvcCIscjoiUmlnaHQiLGI6IkJvdHRvbSIsbDoiTGVmdCIseDpbIkxlZnQiLCJSaWdodCJdLHk6WyJUb3AiLCJCb3R0b20iXX0sej17bWFyZ2luWDoibXgiLG1hcmdpblk6Im15IixwYWRkaW5nWDoicHgiLHBhZGRpbmdZOiJweSJ9LEw9ZnVuY3Rpb24oZSl7dmFyIHQ9e307cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB2b2lkIDA9PT10W25dJiYodFtuXT1lKG4pKSx0W25dfX0oKGZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoPjIpe2lmKCF6W2VdKXJldHVybltlXTtlPXpbZV19dmFyIHQ9ZS5zcGxpdCgiIiksbj1PYmplY3QoUi5hKSh0LDIpLHI9blswXSxvPW5bMV0saT1JW3JdLGE9RFtvXXx8IiI7cmV0",
                    "dXJuIEFycmF5LmlzQXJyYXkoYSk/YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBpK2V9KSk6W2krYV19KSksRj1bIm0iLCJtdCIsIm1yIiwibWIiLCJtbCIsIm14IiwibXkiLCJwIiwicHQiLCJwciIsInBiIiwicGwiLCJweCIsInB5IiwibWFyZ2luIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luWCIsIm1hcmdpblkiLCJwYWRkaW5nIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdYIiwicGFkZGluZ1kiXTtmdW5jdGlvbiAkKGUpe3ZhciB0PWUuc3BhY2luZ3x8ODtyZXR1cm4ibnVtYmVyIj09PXR5cGVvZiB0P2Z1bmN0aW9uKGUpe3JldHVybiB0KmV9OkFycmF5LmlzQXJyYXkodCk/ZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19OiJmdW5jdGlvbiI9PT10eXBlb2YgdD90OmZ1bmN0aW9uKCl7fX1mdW5jdGlvbiBXKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZVtyXT1mdW5jdGlvbihlLHQpe2lmKCJzdHJpbmciPT09dHlwZW9mIHQpcmV0dXJuIHQ7dmFyIG49ZShNYXRoLmFicyh0KSk7cmV0dXJuIHQ+PTA/bjoibnVtYmVyIj09PXR5cGVvZiBuPy1uOiItIi5jb25jYXQobil9KHQsbiksZX0pLHt9KX19ZnVuY3Rpb24gQihlKXt2YXIgdD0kKGUudGhlbWUpO3JldHVybiBPYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKG4p",
                    "e2lmKC0xPT09Ri5pbmRleE9mKG4pKXJldHVybiBudWxsO3ZhciByPVcoTChuKSx0KSxvPWVbbl07cmV0dXJuIGZ1bmN0aW9uKGUsdCxuKXtpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgcj1lLnRoZW1lLmJyZWFrcG9pbnRzfHxBO3JldHVybiB0LnJlZHVjZSgoZnVuY3Rpb24oZSxvLGkpe3JldHVybiBlW3IudXAoci5rZXlzW2ldKV09bih0W2ldKSxlfSkse30pfWlmKCJvYmplY3QiPT09T2JqZWN0KE4uYSkodCkpe3ZhciBvPWUudGhlbWUuYnJlYWtwb2ludHN8fEE7cmV0dXJuIE9iamVjdC5rZXlzKHQpLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZVtvLnVwKHIpXT1uKHRbcl0pLGV9KSx7fSl9cmV0dXJuIG4odCl9KGUsbyxyKX0pKS5yZWR1Y2UoTSx7fSl9Qi5wcm9wVHlwZXM9e30sQi5maWx0ZXJQcm9wcz1GO2Z1bmN0aW9uIEgoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06ODtpZihlLm11aSlyZXR1cm4gZTt2YXIgdD0kKHtzcGFjaW5nOmV9KSxuPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspbltyXT1hcmd1bWVudHNbcl07cmV0dXJuIDA9PT1uLmxlbmd0aD90KDEpOjE9PT1uLmxlbmd0aD90KG5bMF0pOm4ubWFwKChmdW5jdGlvbihlKXtpZigic3RyaW5nIj09PXR5cGVvZiBlKXJldHVybiBlO3ZhciBuPXQoZSk7cmV0dXJuIm51bWJlciI9PT10eXBlb2Ygbj8iIi5jb25j",
                    "YXQobiwicHgiKTpufSkpLmpvaW4oIiAiKX07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCJ1bml0Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9fSksbi5tdWk9ITAsbn12YXIgVj1uKDQzKSxVPW4oNDQpO3ZhciBxPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PWUuYnJlYWtwb2ludHMsbj12b2lkIDA9PT10P3t9OnQscj1lLm1peGlucyxhPXZvaWQgMD09PXI/e306cixsPWUucGFsZXR0ZSxjPXZvaWQgMD09PWw/e306bCxkPWUuc3BhY2luZyxmPWUudHlwb2dyYXBoeSxwPXZvaWQgMD09PWY/e306ZixoPU9iamVjdChvLmEpKGUsWyJicmVha3BvaW50cyIsIm1peGlucyIsInBhbGV0dGUiLCJzcGFjaW5nIiwidHlwb2dyYXBoeSJdKSxtPU8oYyksdj11KG4pLGI9SChkKSx5PU9iamVjdChpLmEpKHticmVha3BvaW50czp2LGRpcmVjdGlvbjoibHRyIixtaXhpbnM6cyh2LGIsYSksb3ZlcnJpZGVzOnt9LHBhbGV0dGU6bSxwcm9wczp7fSxzaGFkb3dzOlQsdHlwb2dyYXBoeTpDKG0scCksc3BhY2luZzpiLHNoYXBlOlAsdHJhbnNpdGlvbnM6Vi5hLHpJbmRleDpVLmF9LGgpLGc9YXJndW1lbnRzLmxlbmd0aCx3PW5ldyBBcnJheShnPjE/Zy0xOjApLHg9MTt4PGc7eCsrKXdbeC0xXT1hcmd1bWVudHNbeF07cmV0dXJuIHk9dy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdChpLmEpKGUsdCl9KSx5KX0o",
                    "KTt0LmE9cX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7aWYobnVsbD09ZSlyZXR1cm57fTt2YXIgbixyLG89ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsbz17fSxpPU9iamVjdC5rZXlzKGUpO2ZvcihyPTA7cjxpLmxlbmd0aDtyKyspbj1pW3JdLHQuaW5kZXhPZihuKT49MHx8KG9bbl09ZVtuXSk7cmV0dXJuIG99KGUsdCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtmb3Iocj0wO3I8aS5sZW5ndGg7cisrKW49aVtyXSx0LmluZGV4T2Yobik+PTB8fE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLG4pJiYob1tuXT1lW25dKX1yZXR1cm4gb31uLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9LCwsLGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7KGZ1bmN0aW9uKGUscil7dmFyIG8saT1uKDY0KTtvPSJ1bmRlZmluZWQiIT09dHlwZW9mIHNlbGY/c2VsZjoidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3c/d2luZG93OiJ1bmRlZmluZWQiIT09dHlwZW9mIGU/ZTpyO3ZhciBhPU9iamVjdChpLmEpKG8pO3QuYT1hfSkuY2FsbCh0aGlzLG4oODMpLG4oODQpKGUpKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSksbi5kKHQsImIiLChmdW5jdGlvbigpe3JldHVybiBF",
                    "fSkpO3ZhciByPW4oMTYpLG89bigxOCk7ZnVuY3Rpb24gaShlLHQpe3JldHVybiBlPT09dH1mdW5jdGlvbiBhKGUsdCxuKXtpZihudWxsPT09dHx8bnVsbD09PW58fHQubGVuZ3RoIT09bi5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciByPXQubGVuZ3RoLG89MDtvPHI7bysrKWlmKCFlKHRbb10sbltvXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gbChlKXt2YXIgdD1BcnJheS5pc0FycmF5KGVbMF0pP2VbMF06ZTtpZighdC5ldmVyeSgoZnVuY3Rpb24oZSl7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBlfSkpKXt2YXIgbj10Lm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfSkpLmpvaW4oIiwgIik7dGhyb3cgbmV3IEVycm9yKCJTZWxlY3RvciBjcmVhdG9ycyBleHBlY3QgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGluc3RlYWQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogWyIrbisiXSIpfXJldHVybiB0fSFmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXX0oKGZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTppLG49bnVsbCxyPW51bGw7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEodCxuLGFyZ3VtZW50cyl8fChyPWUuYXBwbHkobnVsbCxhcmd1bWVudHMpKSxuPWFyZ3VtZW50cyxy",
                    "fX0pKTt2YXIgdT1uKDM5KTtmdW5jdGlvbiBzKCl7cmV0dXJuKHM9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49YXJndW1lbnRzW3RdO2Zvcih2YXIgciBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpJiYoZVtyXT1uW3JdKX1yZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBjKGUpe3JldHVybihjPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuKGQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGYoKXtpZigidW5kZWZpbmVkIj09PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZigiZnVuY3Rpb24iPT09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIHAoZSx0LG4pe3JldHVybihwPWYoKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5j",
                    "dGlvbihlLHQsbil7dmFyIHI9W251bGxdO3IucHVzaC5hcHBseShyLHQpO3ZhciBvPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUscikpO3JldHVybiBuJiZkKG8sbi5wcm90b3R5cGUpLG99KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gaChlKXt2YXIgdD0iZnVuY3Rpb24iPT09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4oaD1mdW5jdGlvbihlKXtpZihudWxsPT09ZXx8KG49ZSwtMT09PUZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwobikuaW5kZXhPZigiW25hdGl2ZSBjb2RlXSIpKSlyZXR1cm4gZTt2YXIgbjtpZigiZnVuY3Rpb24iIT09dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtpZigidW5kZWZpbmVkIiE9PXR5cGVvZiB0KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxyKX1mdW5jdGlvbiByKCl7cmV0dXJuIHAoZSxhcmd1bWVudHMsYyh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIHIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpyLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGQocixlKX0pKGUpfXZhciBtPSJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXz93aW5kb3cuX19SRURVWF9ERVZUT09MU19F",
                    "WFRFTlNJT05fQ09NUE9TRV9fOmZ1bmN0aW9uKCl7aWYoMCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIm9iamVjdCI9PT10eXBlb2YgYXJndW1lbnRzWzBdP28uZDpvLmQuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiB2KGUpe2lmKCJvYmplY3QiIT09dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiExO2Zvcih2YXIgdD1lO251bGwhPT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7KXQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT10fXZhciBiPWZ1bmN0aW9uKGUpe3ZhciB0LG47ZnVuY3Rpb24gcigpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31uPWUsKHQ9cikucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5fX3Byb3RvX189bjt2YXIgbz1yLnByb3RvdHlwZTtyZXR1cm4gby5jb25jYXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQsbj1hcmd1bWVudHMubGVuZ3RoLG89bmV3IEFycmF5KG4pLGk9MDtpPG47aSsrKW9baV09YXJndW1lbnRzW2ldO3JldHVybiBwKHIsKHQ9ZS5wcm90b3R5cGUuY29uY2F0KS5jYWxsLmFwcGx5KHQsW3RoaXNdLmNvbmNhdChvKSkpfSxvLnByZXBlbmQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxuPTA7bjxlO24rKyl0W25dPWFyZ3VtZW50c1tuXTtyZXR1cm4gMT09PXQubGVuZ3RoJiZB",
                    "cnJheS5pc0FycmF5KHRbMF0pP3Aocix0WzBdLmNvbmNhdCh0aGlzKSk6cChyLHQuY29uY2F0KHRoaXMpKX0scn0oaChBcnJheSkpO2Z1bmN0aW9uIHkoKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgdD1lLG49dC50aHVuayxyPXZvaWQgMD09PW58fG4sbz0odC5pbW11dGFibGVDaGVjayx0LnNlcmlhbGl6YWJsZUNoZWNrLG5ldyBiKTtyJiYoImJvb2xlYW4iPT09dHlwZW9mIHI/by5wdXNoKHUuYSk6by5wdXNoKHUuYS53aXRoRXh0cmFBcmd1bWVudChyLmV4dHJhQXJndW1lbnQpKSk7MDtyZXR1cm4gb30oZSl9fWZ1bmN0aW9uIGcoZSl7dmFyIHQsbj15KCkscj1lfHx7fSxpPXIucmVkdWNlcixhPXZvaWQgMD09PWk/dm9pZCAwOmksbD1yLm1pZGRsZXdhcmUsdT12b2lkIDA9PT1sP24oKTpsLGM9ci5kZXZUb29scyxkPXZvaWQgMD09PWN8fGMsZj1yLnByZWxvYWRlZFN0YXRlLHA9dm9pZCAwPT09Zj92b2lkIDA6ZixoPXIuZW5oYW5jZXJzLGI9dm9pZCAwPT09aD92b2lkIDA6aDtpZigiZnVuY3Rpb24iPT09dHlwZW9mIGEpdD1hO2Vsc2V7aWYoIXYoYSkpdGhyb3cgbmV3IEVycm9yKCcicmVkdWNlciIgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMnKTt0PU9iamVjdChvLmMpKGEpfXZhciBnPW8uYS5hcHBs",
                    "eSh2b2lkIDAsImZ1bmN0aW9uIj09PXR5cGVvZiB1P3Uobik6dSksdz1vLmQ7ZCYmKHc9bShzKHt0cmFjZTohMX0sIm9iamVjdCI9PT10eXBlb2YgZCYmZCkpKTt2YXIgeD1bZ107QXJyYXkuaXNBcnJheShiKT94PVtnXS5jb25jYXQoYik6ImZ1bmN0aW9uIj09PXR5cGVvZiBiJiYoeD1iKHgpKTt2YXIgRT13LmFwcGx5KHZvaWQgMCx4KTtyZXR1cm4gT2JqZWN0KG8uZSkodCxwLEUpfWZ1bmN0aW9uIHcoZSx0KXtmdW5jdGlvbiBuKCl7aWYodCl7dmFyIG49dC5hcHBseSh2b2lkIDAsYXJndW1lbnRzKTtpZighbil0aHJvdyBuZXcgRXJyb3IoInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0Iik7cmV0dXJuIHMoe3R5cGU6ZSxwYXlsb2FkOm4ucGF5bG9hZH0sIm1ldGEiaW4gbiYme21ldGE6bi5tZXRhfSx7fSwiZXJyb3IiaW4gbiYme2Vycm9yOm4uZXJyb3J9KX1yZXR1cm57dHlwZTplLHBheWxvYWQ6YXJndW1lbnRzLmxlbmd0aDw9MD92b2lkIDA6YXJndW1lbnRzWzBdfX1yZXR1cm4gbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiIiK2V9LG4udHlwZT1lLG4ubWF0Y2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PWV9LG59ZnVuY3Rpb24geChlKXt2YXIgdCxuPXt9LHI9W10sbz17YWRkQ2FzZTpmdW5jdGlvbihlLHQpe3ZhciByPSJzdHJpbmciPT09dHlwZW9mIGU/ZTplLnR5cGU7aWYociBpbiBuKXRocm93IG5ldyBFcnJvcigiYWRkQ2FzZSBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJl",
                    "ZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSIpO3JldHVybiBuW3JdPXQsb30sYWRkTWF0Y2hlcjpmdW5jdGlvbihlLHQpe3JldHVybiByLnB1c2goe21hdGNoZXI6ZSxyZWR1Y2VyOnR9KSxvfSxhZGREZWZhdWx0Q2FzZTpmdW5jdGlvbihlKXtyZXR1cm4gdD1lLG99fTtyZXR1cm4gZShvKSxbbixyLHRdfWZ1bmN0aW9uIEUoZSl7dmFyIHQ9ZS5uYW1lLG49ZS5pbml0aWFsU3RhdGU7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlIik7dmFyIG89ZS5yZWR1Y2Vyc3x8e30saT0idW5kZWZpbmVkIj09PXR5cGVvZiBlLmV4dHJhUmVkdWNlcnM/W106ImZ1bmN0aW9uIj09PXR5cGVvZiBlLmV4dHJhUmVkdWNlcnM/eChlLmV4dHJhUmVkdWNlcnMpOltlLmV4dHJhUmVkdWNlcnNdLGE9aVswXSxsPXZvaWQgMD09PWE/e306YSx1PWlbMV0sYz12b2lkIDA9PT11P1tdOnUsZD1pWzJdLGY9dm9pZCAwPT09ZD92b2lkIDA6ZCxwPU9iamVjdC5rZXlzKG8pLGg9e30sbT17fSx2PXt9O3AuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4scixpPW9bZV0sYT10KyIvIitlOyJyZWR1Y2VyImluIGk/KG49aS5yZWR1Y2VyLHI9aS5wcmVwYXJlKTpuPWksaFtlXT1uLG1bYV09bix2W2VdPXI/dyhhLHIpOncoYSl9KSk7dmFyIGI9ZnVuY3Rpb24oZSx0LG4sbyl7dm9pZCAwPT09biYmKG49W10pO3ZhciBpPSJmdW5jdGlvbiI9PT10eXBlb2YgdD94KHQpOlt0LG4sb10s",
                    "YT1pWzBdLGw9aVsxXSx1PWlbMl07cmV0dXJuIGZ1bmN0aW9uKHQsbil7dm9pZCAwPT09dCYmKHQ9ZSk7dmFyIG89W2Fbbi50eXBlXV0uY29uY2F0KGwuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4oMCxlLm1hdGNoZXIpKG4pfSkpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVkdWNlcn0pKSk7cmV0dXJuIDA9PT1vLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLmxlbmd0aCYmKG89W3VdKSxvLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtpZih0KXtpZihPYmplY3Qoci5jKShlKSl7dmFyIG89dChlLG4pO3JldHVybiJ1bmRlZmluZWQiPT09dHlwZW9mIG8/ZTpvfWlmKE9iamVjdChyLmQpKGUpKXJldHVybiBPYmplY3Qoci5hKShlLChmdW5jdGlvbihlKXtyZXR1cm4gdChlLG4pfSkpO3ZhciBpPXQoZSxuKTtpZigidW5kZWZpbmVkIj09PXR5cGVvZiBpKXRocm93IEVycm9yKCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZCIpO3JldHVybiBpfXJldHVybiBlfSksdCl9fShuLHMoe30sbCx7fSxtKSxjLGYpO3JldHVybntuYW1lOnQscmVkdWNlcjpiLGFjdGlvbnM6dixjYXNlUmVkdWNlcnM6aH19InVuZGVmaW5lZCIhPT10eXBlb2YgU3ltYm9sJiYoU3ltYm9sLml0ZXJhdG9yfHwoU3ltYm9sLml0ZXJhdG9yPVN5bWJvbCgiU3ltYm9sLml0ZXJhdG9yIikpKSwidW5kZWZpbmVkIiE9PXR5cGVvZiBTeW1ib2wmJihTeW1ib2wuYXN5bmNJdGVy",
                    "YXRvcnx8KFN5bWJvbC5hc3luY0l0ZXJhdG9yPVN5bWJvbCgiU3ltYm9sLmFzeW5jSXRlcmF0b3IiKSkpO09iamVjdChyLmIpKCl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oMiksaT1uKDApLGE9KG4oNSksbig4KSksbD1uKDMpLHU9bigxMCkscz1uKDIwKSxjPW4oNCksZD0hMCxmPSExLHA9bnVsbCxoPXt0ZXh0OiEwLHNlYXJjaDohMCx1cmw6ITAsdGVsOiEwLGVtYWlsOiEwLHBhc3N3b3JkOiEwLG51bWJlcjohMCxkYXRlOiEwLG1vbnRoOiEwLHdlZWs6ITAsdGltZTohMCxkYXRldGltZTohMCwiZGF0ZXRpbWUtbG9jYWwiOiEwfTtmdW5jdGlvbiBtKGUpe2UubWV0YUtleXx8ZS5hbHRLZXl8fGUuY3RybEtleXx8KGQ9ITApfWZ1bmN0aW9uIHYoKXtkPSExfWZ1bmN0aW9uIGIoKXsiaGlkZGVuIj09PXRoaXMudmlzaWJpbGl0eVN0YXRlJiZmJiYoZD0hMCl9ZnVuY3Rpb24geShlKXt2YXIgdD1lLnRhcmdldDt0cnl7cmV0dXJuIHQubWF0Y2hlcygiOmZvY3VzLXZpc2libGUiKX1jYXRjaChuKXt9cmV0dXJuIGR8fGZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZSxuPWUudGFnTmFtZTtyZXR1cm4hKCJJTlBVVCIhPT1ufHwhaFt0XXx8ZS5yZWFkT25seSl8fCgiVEVYVEFSRUEiPT09biYmIWUucmVhZE9ubHl8fCEhZS5pc0NvbnRlbnRFZGl0YWJsZSl9KHQpfWZ1bmN0aW9uIGcoKXtmPSEwLHdpbmRvdy5jbGVhclRpbWVvdXQocCkscD13aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtmPSEx",
                    "fSksMTAwKX1mdW5jdGlvbiB3KCl7cmV0dXJue2lzRm9jdXNWaXNpYmxlOnksb25CbHVyVmlzaWJsZTpnLHJlZjppLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXt2YXIgdCxuPWEuZmluZERPTU5vZGUoZSk7bnVsbCE9biYmKCh0PW4ub3duZXJEb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcigia2V5ZG93biIsbSwhMCksdC5hZGRFdmVudExpc3RlbmVyKCJtb3VzZWRvd24iLHYsITApLHQuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmRvd24iLHYsITApLHQuYWRkRXZlbnRMaXN0ZW5lcigidG91Y2hzdGFydCIsdiwhMCksdC5hZGRFdmVudExpc3RlbmVyKCJ2aXNpYmlsaXR5Y2hhbmdlIixiLCEwKSl9KSxbXSl9fXZhciB4PW4oMjQpLEU9bigxNTEpLE89InVuZGVmaW5lZCI9PT10eXBlb2Ygd2luZG93P2kudXNlRWZmZWN0OmkudXNlTGF5b3V0RWZmZWN0O3ZhciBrPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2xhc3NlcyxuPWUucHVsc2F0ZSxyPXZvaWQgMCE9PW4mJm4sbz1lLnJpcHBsZVgsYT1lLnJpcHBsZVksdT1lLnJpcHBsZVNpemUsYz1lLmluLGQ9ZS5vbkV4aXRlZCxmPXZvaWQgMD09PWQ/ZnVuY3Rpb24oKXt9OmQscD1lLnRpbWVvdXQsaD1pLnVzZVN0YXRlKCExKSxtPWhbMF0sdj1oWzFdLGI9T2JqZWN0KGwuYSkodC5yaXBwbGUsdC5yaXBwbGVWaXNpYmxlLHImJnQucmlwcGxlUHVsc2F0ZSkseT17d2lkdGg6dSxoZWlnaHQ6dSx0b3A6LXUvMithLGxlZnQ6LXUvMitvfSxnPU9iamVjdChsLmEpKHQuY2hpbGQsbSYmdC5j",
                    "aGlsZExlYXZpbmcsciYmdC5jaGlsZFB1bHNhdGUpLHc9T2JqZWN0KHMuYSkoZik7cmV0dXJuIE8oKGZ1bmN0aW9uKCl7aWYoIWMpe3YoITApO3ZhciBlPXNldFRpbWVvdXQodyxwKTtyZXR1cm4gZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZSl9fX0pLFt3LGMscF0pLGkuY3JlYXRlRWxlbWVudCgic3BhbiIse2NsYXNzTmFtZTpiLHN0eWxlOnl9LGkuY3JlYXRlRWxlbWVudCgic3BhbiIse2NsYXNzTmFtZTpnfSkpfSxTPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNlbnRlcixhPXZvaWQgMCE9PW4mJm4sdT1lLmNsYXNzZXMscz1lLmNsYXNzTmFtZSxjPU9iamVjdChvLmEpKGUsWyJjZW50ZXIiLCJjbGFzc2VzIiwiY2xhc3NOYW1lIl0pLGQ9aS51c2VTdGF0ZShbXSksZj1kWzBdLHA9ZFsxXSxoPWkudXNlUmVmKDApLG09aS51c2VSZWYobnVsbCk7aS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7bS5jdXJyZW50JiYobS5jdXJyZW50KCksbS5jdXJyZW50PW51bGwpfSksW2ZdKTt2YXIgdj1pLnVzZVJlZighMSksYj1pLnVzZVJlZihudWxsKSx5PWkudXNlUmVmKG51bGwpLGc9aS51c2VSZWYobnVsbCk7aS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGIuY3VycmVudCl9fSksW10pO3ZhciB3PWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe3ZhciB0PWUucHVsc2F0ZSxuPWUucmlwcGxlWCxyPWUucmlwcGxlWSxvPWUucmlwcGxlU2l6ZSxhPWUuY2I7cCgoZnVu",
                    "Y3Rpb24oZSl7cmV0dXJuW10uY29uY2F0KE9iamVjdCh4LmEpKGUpLFtpLmNyZWF0ZUVsZW1lbnQoayx7a2V5OmguY3VycmVudCxjbGFzc2VzOnUsdGltZW91dDo1NTAscHVsc2F0ZTp0LHJpcHBsZVg6bixyaXBwbGVZOnIscmlwcGxlU2l6ZTpvfSldKX0pKSxoLmN1cnJlbnQrPTEsbS5jdXJyZW50PWF9KSxbdV0pLE89aS51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxyPXQucHVsc2F0ZSxvPXZvaWQgMCE9PXImJnIsaT10LmNlbnRlcixsPXZvaWQgMD09PWk/YXx8dC5wdWxzYXRlOmksdT10LmZha2VFbGVtZW50LHM9dm9pZCAwIT09dSYmdTtpZigibW91c2Vkb3duIj09PWUudHlwZSYmdi5jdXJyZW50KXYuY3VycmVudD0hMTtlbHNleyJ0b3VjaHN0YXJ0Ij09PWUudHlwZSYmKHYuY3VycmVudD0hMCk7dmFyIGMsZCxmLHA9cz9udWxsOmcuY3VycmVudCxoPXA/cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTp7d2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjB9O2lmKGx8fDA9PT1lLmNsaWVudFgmJjA9PT1lLmNsaWVudFl8fCFlLmNsaWVudFgmJiFlLnRvdWNoZXMpYz1NYXRoLnJvdW5kKGgud2lkdGgvMiksZD1NYXRoLnJvdW5kKGgu",
                    "aGVpZ2h0LzIpO2Vsc2V7dmFyIG09ZS50b3VjaGVzP2UudG91Y2hlc1swXTplLHg9bS5jbGllbnRYLEU9bS5jbGllbnRZO2M9TWF0aC5yb3VuZCh4LWgubGVmdCksZD1NYXRoLnJvdW5kKEUtaC50b3ApfWlmKGwpKGY9TWF0aC5zcXJ0KCgyKk1hdGgucG93KGgud2lkdGgsMikrTWF0aC5wb3coaC5oZWlnaHQsMikpLzMpKSUyPT09MCYmKGYrPTEpO2Vsc2V7dmFyIE89MipNYXRoLm1heChNYXRoLmFicygocD9wLmNsaWVudFdpZHRoOjApLWMpLGMpKzIsaz0yKk1hdGgubWF4KE1hdGguYWJzKChwP3AuY2xpZW50SGVpZ2h0OjApLWQpLGQpKzI7Zj1NYXRoLnNxcnQoTWF0aC5wb3coTywyKStNYXRoLnBvdyhrLDIpKX1lLnRvdWNoZXM/bnVsbD09PXkuY3VycmVudCYmKHkuY3VycmVudD1mdW5jdGlvbigpe3coe3B1bHNhdGU6byxyaXBwbGVYOmMscmlwcGxlWTpkLHJpcHBsZVNpemU6ZixjYjpufSl9LGIuY3VycmVudD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe3kuY3VycmVudCYmKHkuY3VycmVudCgpLHkuY3VycmVudD1udWxsKX0pLDgwKSk6dyh7cHVsc2F0ZTpvLHJpcHBsZVg6YyxyaXBwbGVZOmQscmlwcGxlU2l6ZTpmLGNiOm59KX19KSxbYSx3XSksUz1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbigpe08oe30se3B1bHNhdGU6ITB9KX0pLFtPXSksQz1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlLHQpe2lmKGNsZWFyVGltZW91dChiLmN1cnJlbnQpLCJ0b3VjaGVuZCI9PT1lLnR5cGUmJnkuY3VycmVudClyZXR1cm4gZS5wZXJz",
                    "aXN0KCkseS5jdXJyZW50KCkseS5jdXJyZW50PW51bGwsdm9pZChiLmN1cnJlbnQ9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtDKGUsdCl9KSkpO3kuY3VycmVudD1udWxsLHAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxlbmd0aD4wP2Uuc2xpY2UoMSk6ZX0pKSxtLmN1cnJlbnQ9dH0pLFtdKTtyZXR1cm4gaS51c2VJbXBlcmF0aXZlSGFuZGxlKHQsKGZ1bmN0aW9uKCl7cmV0dXJue3B1bHNhdGU6UyxzdGFydDpPLHN0b3A6Q319KSxbUyxPLENdKSxpLmNyZWF0ZUVsZW1lbnQoInNwYW4iLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGwuYSkodS5yb290LHMpLHJlZjpnfSxjKSxpLmNyZWF0ZUVsZW1lbnQoRS5hLHtjb21wb25lbnQ6bnVsbCxleGl0OiEwfSxmKSl9KSksQz1PYmplY3QoYy5hKSgoZnVuY3Rpb24oZSl7cmV0dXJue3Jvb3Q6e292ZXJmbG93OiJoaWRkZW4iLHBvaW50ZXJFdmVudHM6Im5vbmUiLHBvc2l0aW9uOiJhYnNvbHV0ZSIsekluZGV4OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MCxsZWZ0OjAsYm9yZGVyUmFkaXVzOiJpbmhlcml0In0scmlwcGxlOntvcGFjaXR5OjAscG9zaXRpb246ImFic29sdXRlIn0scmlwcGxlVmlzaWJsZTp7b3BhY2l0eTouMyx0cmFuc2Zvcm06InNjYWxlKDEpIixhbmltYXRpb246IiRlbnRlciAiLmNvbmNhdCg1NTAsIm1zICIpLmNvbmNhdChlLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXQpfSxyaXBwbGVQdWxzYXRlOnthbmltYXRpb25EdXJhdGlvbjoiIi5jb25jYXQo",
                    "ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLCJtcyIpfSxjaGlsZDp7b3BhY2l0eToxLGRpc3BsYXk6ImJsb2NrIix3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIixib3JkZXJSYWRpdXM6IjUwJSIsYmFja2dyb3VuZENvbG9yOiJjdXJyZW50Q29sb3IifSxjaGlsZExlYXZpbmc6e29wYWNpdHk6MCxhbmltYXRpb246IiRleGl0ICIuY29uY2F0KDU1MCwibXMgIikuY29uY2F0KGUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VJbk91dCl9LGNoaWxkUHVsc2F0ZTp7cG9zaXRpb246ImFic29sdXRlIixsZWZ0OjAsdG9wOjAsYW5pbWF0aW9uOiIkcHVsc2F0ZSAyNTAwbXMgIi5jb25jYXQoZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0LCIgMjAwbXMgaW5maW5pdGUiKX0sIkBrZXlmcmFtZXMgZW50ZXIiOnsiMCUiOnt0cmFuc2Zvcm06InNjYWxlKDApIixvcGFjaXR5Oi4xfSwiMTAwJSI6e3RyYW5zZm9ybToic2NhbGUoMSkiLG9wYWNpdHk6LjN9fSwiQGtleWZyYW1lcyBleGl0Ijp7IjAlIjp7b3BhY2l0eToxfSwiMTAwJSI6e29wYWNpdHk6MH19LCJAa2V5ZnJhbWVzIHB1bHNhdGUiOnsiMCUiOnt0cmFuc2Zvcm06InNjYWxlKDEpIn0sIjUwJSI6e3RyYW5zZm9ybToic2NhbGUoMC45MikifSwiMTAwJSI6e3RyYW5zZm9ybToic2NhbGUoMSkifX19fSkse2ZsaXA6ITEsbmFtZToiTXVpVG91Y2hSaXBwbGUifSkoaS5tZW1vKFMpKSxqPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmFjdGlvbixjPWUu",
                    "YnV0dG9uUmVmLGQ9ZS5jZW50ZXJSaXBwbGUsZj12b2lkIDAhPT1kJiZkLHA9ZS5jaGlsZHJlbixoPWUuY2xhc3NlcyxtPWUuY2xhc3NOYW1lLHY9ZS5jb21wb25lbnQsYj12b2lkIDA9PT12PyJidXR0b24iOnYseT1lLmRpc2FibGVkLGc9dm9pZCAwIT09eSYmeSx4PWUuZGlzYWJsZVJpcHBsZSxFPXZvaWQgMCE9PXgmJngsTz1lLmRpc2FibGVUb3VjaFJpcHBsZSxrPXZvaWQgMCE9PU8mJk8sUz1lLmZvY3VzUmlwcGxlLGo9dm9pZCAwIT09UyYmUyxUPWUuZm9jdXNWaXNpYmxlQ2xhc3NOYW1lLFA9ZS5vbkJsdXIsUj1lLm9uQ2xpY2ssTj1lLm9uRm9jdXMsTT1lLm9uRm9jdXNWaXNpYmxlLF89ZS5vbktleURvd24sQT1lLm9uS2V5VXAsST1lLm9uTW91c2VEb3duLEQ9ZS5vbk1vdXNlTGVhdmUsej1lLm9uTW91c2VVcCxMPWUub25Ub3VjaEVuZCxGPWUub25Ub3VjaE1vdmUsJD1lLm9uVG91Y2hTdGFydCxXPWUub25EcmFnTGVhdmUsQj1lLnRhYkluZGV4LEg9dm9pZCAwPT09Qj8wOkIsVj1lLlRvdWNoUmlwcGxlUHJvcHMsVT1lLnR5cGUscT12b2lkIDA9PT1VPyJidXR0b24iOlUsSz1PYmplY3Qoby5hKShlLFsiYWN0aW9uIiwiYnV0dG9uUmVmIiwiY2VudGVyUmlwcGxlIiwiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29tcG9uZW50IiwiZGlzYWJsZWQiLCJkaXNhYmxlUmlwcGxlIiwiZGlzYWJsZVRvdWNoUmlwcGxlIiwiZm9jdXNSaXBwbGUiLCJmb2N1c1Zpc2libGVDbGFzc05hbWUiLCJvbkJsdXIiLCJv",
                    "bkNsaWNrIiwib25Gb2N1cyIsIm9uRm9jdXNWaXNpYmxlIiwib25LZXlEb3duIiwib25LZXlVcCIsIm9uTW91c2VEb3duIiwib25Nb3VzZUxlYXZlIiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaFN0YXJ0Iiwib25EcmFnTGVhdmUiLCJ0YWJJbmRleCIsIlRvdWNoUmlwcGxlUHJvcHMiLCJ0eXBlIl0pLFk9aS51c2VSZWYobnVsbCk7dmFyIFE9aS51c2VSZWYobnVsbCksWD1pLnVzZVN0YXRlKCExKSxHPVhbMF0sSj1YWzFdO2cmJkcmJkooITEpO3ZhciBaPXcoKSxlZT1aLmlzRm9jdXNWaXNpYmxlLHRlPVoub25CbHVyVmlzaWJsZSxuZT1aLnJlZjtmdW5jdGlvbiByZShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTprO3JldHVybiBPYmplY3Qocy5hKSgoZnVuY3Rpb24ocil7cmV0dXJuIHQmJnQociksIW4mJlEuY3VycmVudCYmUS5jdXJyZW50W2VdKHIpLCEwfSkpfWkudXNlSW1wZXJhdGl2ZUhhbmRsZShuLChmdW5jdGlvbigpe3JldHVybntmb2N1c1Zpc2libGU6ZnVuY3Rpb24oKXtKKCEwKSxZLmN1cnJlbnQuZm9jdXMoKX19fSksW10pLGkudXNlRWZmZWN0KChmdW5jdGlvbigpe0cmJmomJiFFJiZRLmN1cnJlbnQucHVsc2F0ZSgpfSksW0UsaixHXSk7dmFyIG9lPXJlKCJzdGFydCIsSSksaWU9cmUoInN0b3AiLFcpLGFlPXJlKCJzdG9wIix6KSxsZT1yZSgic3RvcCIsKGZ1bmN0aW9uKGUpe0cmJmUucHJldmVu",
                    "dERlZmF1bHQoKSxEJiZEKGUpfSkpLHVlPXJlKCJzdGFydCIsJCksc2U9cmUoInN0b3AiLEwpLGNlPXJlKCJzdG9wIixGKSxkZT1yZSgic3RvcCIsKGZ1bmN0aW9uKGUpe0cmJih0ZShlKSxKKCExKSksUCYmUChlKX0pLCExKSxmZT1PYmplY3Qocy5hKSgoZnVuY3Rpb24oZSl7WS5jdXJyZW50fHwoWS5jdXJyZW50PWUuY3VycmVudFRhcmdldCksZWUoZSkmJihKKCEwKSxNJiZNKGUpKSxOJiZOKGUpfSkpLHBlPWZ1bmN0aW9uKCl7dmFyIGU9YS5maW5kRE9NTm9kZShZLmN1cnJlbnQpO3JldHVybiBiJiYiYnV0dG9uIiE9PWImJiEoIkEiPT09ZS50YWdOYW1lJiZlLmhyZWYpfSxoZT1pLnVzZVJlZighMSksbWU9T2JqZWN0KHMuYSkoKGZ1bmN0aW9uKGUpe2omJiFoZS5jdXJyZW50JiZHJiZRLmN1cnJlbnQmJiIgIj09PWUua2V5JiYoaGUuY3VycmVudD0hMCxlLnBlcnNpc3QoKSxRLmN1cnJlbnQuc3RvcChlLChmdW5jdGlvbigpe1EuY3VycmVudC5zdGFydChlKX0pKSksZS50YXJnZXQ9PT1lLmN1cnJlbnRUYXJnZXQmJnBlKCkmJiIgIj09PWUua2V5JiZlLnByZXZlbnREZWZhdWx0KCksXyYmXyhlKSxlLnRhcmdldD09PWUuY3VycmVudFRhcmdldCYmcGUoKSYmIkVudGVyIj09PWUua2V5JiYhZyYmKGUucHJldmVudERlZmF1bHQoKSxSJiZSKGUpKX0pKSx2ZT1PYmplY3Qocy5hKSgoZnVuY3Rpb24oZSl7aiYmIiAiPT09ZS5rZXkmJlEuY3VycmVudCYmRyYmIWUuZGVmYXVsdFByZXZlbnRlZCYmKGhlLmN1cnJlbnQ9ITEsZS5w",
                    "ZXJzaXN0KCksUS5jdXJyZW50LnN0b3AoZSwoZnVuY3Rpb24oKXtRLmN1cnJlbnQucHVsc2F0ZShlKX0pKSksQSYmQShlKSxSJiZlLnRhcmdldD09PWUuY3VycmVudFRhcmdldCYmcGUoKSYmIiAiPT09ZS5rZXkmJiFlLmRlZmF1bHRQcmV2ZW50ZWQmJlIoZSl9KSksYmU9YjsiYnV0dG9uIj09PWJlJiZLLmhyZWYmJihiZT0iYSIpO3ZhciB5ZT17fTsiYnV0dG9uIj09PWJlPyh5ZS50eXBlPXEseWUuZGlzYWJsZWQ9Zyk6KCJhIj09PWJlJiZLLmhyZWZ8fCh5ZS5yb2xlPSJidXR0b24iKSx5ZVsiYXJpYS1kaXNhYmxlZCJdPWcpO3ZhciBnZT1PYmplY3QodS5hKShjLHQpLHdlPU9iamVjdCh1LmEpKG5lLFkpLHhlPU9iamVjdCh1LmEpKGdlLHdlKSxFZT1pLnVzZVN0YXRlKCExKSxPZT1FZVswXSxrZT1FZVsxXTtpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtrZSghMCl9KSxbXSk7dmFyIFNlPU9lJiYhRSYmIWc7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChiZSxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChsLmEpKGgucm9vdCxtLEcmJltoLmZvY3VzVmlzaWJsZSxUXSxnJiZoLmRpc2FibGVkKSxvbkJsdXI6ZGUsb25DbGljazpSLG9uRm9jdXM6ZmUsb25LZXlEb3duOm1lLG9uS2V5VXA6dmUsb25Nb3VzZURvd246b2Usb25Nb3VzZUxlYXZlOmxlLG9uTW91c2VVcDphZSxvbkRyYWdMZWF2ZTppZSxvblRvdWNoRW5kOnNlLG9uVG91Y2hNb3ZlOmNlLG9uVG91Y2hTdGFydDp1ZSxyZWY6eGUsdGFiSW5kZXg6Zz8tMTpIfSx5ZSxL",
                    "KSxwLFNlP2kuY3JlYXRlRWxlbWVudChDLE9iamVjdChyLmEpKHtyZWY6USxjZW50ZXI6Zn0sVikpOm51bGwpfSkpO3QuYT1PYmplY3QoYy5hKSh7cm9vdDp7ZGlzcGxheToiaW5saW5lLWZsZXgiLGFsaWduSXRlbXM6ImNlbnRlciIsanVzdGlmeUNvbnRlbnQ6ImNlbnRlciIscG9zaXRpb246InJlbGF0aXZlIixXZWJraXRUYXBIaWdobGlnaHRDb2xvcjoidHJhbnNwYXJlbnQiLGJhY2tncm91bmRDb2xvcjoidHJhbnNwYXJlbnQiLG91dGxpbmU6MCxib3JkZXI6MCxtYXJnaW46MCxib3JkZXJSYWRpdXM6MCxwYWRkaW5nOjAsY3Vyc29yOiJwb2ludGVyIix1c2VyU2VsZWN0OiJub25lIix2ZXJ0aWNhbEFsaWduOiJtaWRkbGUiLCItbW96LWFwcGVhcmFuY2UiOiJub25lIiwiLXdlYmtpdC1hcHBlYXJhbmNlIjoibm9uZSIsdGV4dERlY29yYXRpb246Im5vbmUiLGNvbG9yOiJpbmhlcml0IiwiJjo6LW1vei1mb2N1cy1pbm5lciI6e2JvcmRlclN0eWxlOiJub25lIn0sIiYkZGlzYWJsZWQiOntwb2ludGVyRXZlbnRzOiJub25lIixjdXJzb3I6ImRlZmF1bHQifSwiQG1lZGlhIHByaW50Ijp7Y29sb3JBZGp1c3Q6ImV4YWN0In19LGRpc2FibGVkOnt9LGZvY3VzVmlzaWJsZTp7fX0se25hbWU6Ik11aUJ1dHRvbkJhc2UifSkoail9LCwsLCwsLGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxvPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksaT1PYmplY3Qu",
                    "cHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO2Z1bmN0aW9uIGEoZSl7aWYobnVsbD09PWV8fHZvaWQgMD09PWUpdGhyb3cgbmV3IFR5cGVFcnJvcigiT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQiKTtyZXR1cm4gT2JqZWN0KGUpfWUuZXhwb3J0cz1mdW5jdGlvbigpe3RyeXtpZighT2JqZWN0LmFzc2lnbilyZXR1cm4hMTt2YXIgZT1uZXcgU3RyaW5nKCJhYmMiKTtpZihlWzVdPSJkZSIsIjUiPT09T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSlbMF0pcmV0dXJuITE7Zm9yKHZhciB0PXt9LG49MDtuPDEwO24rKyl0WyJfIitTdHJpbmcuZnJvbUNoYXJDb2RlKG4pXT1uO2lmKCIwMTIzNDU2Nzg5IiE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KSkuam9pbigiIikpcmV0dXJuITE7dmFyIHI9e307cmV0dXJuImFiY2RlZmdoaWprbG1ub3BxcnN0Ii5zcGxpdCgiIikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cltlXT1lfSkpLCJhYmNkZWZnaGlqa2xtbm9wcXJzdCI9PT1PYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LHIpKS5qb2luKCIiKX1jYXRjaChvKXtyZXR1cm4hMX19KCk/T2JqZWN0LmFzc2lnbjpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbixsLHU9YShlKSxzPTE7czxhcmd1bWVudHMubGVuZ3RoO3MrKyl7Zm9yKHZhciBjIGluIG49T2JqZWN0KGFyZ3VtZW50c1tzXSkpby5jYWxsKG4sYykmJih1",
                    "W2NdPW5bY10pO2lmKHIpe2w9cihuKTtmb3IodmFyIGQ9MDtkPGwubGVuZ3RoO2QrKylpLmNhbGwobixsW2RdKSYmKHVbbFtkXV09bltsW2RdXSl9fXJldHVybiB1fX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3ZhciB0LG49ZS5TeW1ib2w7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBuP24ub2JzZXJ2YWJsZT90PW4ub2JzZXJ2YWJsZToodD1uKCJvYnNlcnZhYmxlIiksbi5vYnNlcnZhYmxlPXQpOnQ9IkBAb2JzZXJ2YWJsZSIsdH1uLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxMyksbz1uKDIxKSxpPShuKDUpLG4oMCkpLGE9bi5uKGkpLGw9big4KSx1PW4ubihsKSxzPSExLGM9bigzNCksZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7dmFyIHI7cj1lLmNhbGwodGhpcyx0LG4pfHx0aGlzO3ZhciBvLGk9biYmIW4uaXNNb3VudGluZz90LmVudGVyOnQuYXBwZWFyO3JldHVybiByLmFwcGVhclN0YXR1cz1udWxsLHQuaW4/aT8obz0iZXhpdGVkIixyLmFwcGVhclN0YXR1cz0iZW50ZXJpbmciKTpvPSJlbnRlcmVkIjpvPXQudW5tb3VudE9uRXhpdHx8dC5tb3VudE9uRW50ZXI/InVubW91bnRlZCI6ImV4aXRlZCIsci5zdGF0ZT17c3RhdHVzOm99LHIubmV4dENhbGxiYWNrPW51bGwscn1PYmplY3Qoby5hKSh0LGUpLHQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPWZ1bmN0aW9uKGUsdCl7cmV0dXJu",
                    "IGUuaW4mJiJ1bm1vdW50ZWQiPT09dC5zdGF0dXM/e3N0YXR1czoiZXhpdGVkIn06bnVsbH07dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4uY29tcG9uZW50RGlkTW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZVN0YXR1cyghMCx0aGlzLmFwcGVhclN0YXR1cyl9LG4uY29tcG9uZW50RGlkVXBkYXRlPWZ1bmN0aW9uKGUpe3ZhciB0PW51bGw7aWYoZSE9PXRoaXMucHJvcHMpe3ZhciBuPXRoaXMuc3RhdGUuc3RhdHVzO3RoaXMucHJvcHMuaW4/ImVudGVyaW5nIiE9PW4mJiJlbnRlcmVkIiE9PW4mJih0PSJlbnRlcmluZyIpOiJlbnRlcmluZyIhPT1uJiYiZW50ZXJlZCIhPT1ufHwodD0iZXhpdGluZyIpfXRoaXMudXBkYXRlU3RhdHVzKCExLHQpfSxuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKX0sbi5nZXRUaW1lb3V0cz1mdW5jdGlvbigpe3ZhciBlLHQsbixyPXRoaXMucHJvcHMudGltZW91dDtyZXR1cm4gZT10PW49cixudWxsIT1yJiYibnVtYmVyIiE9PXR5cGVvZiByJiYoZT1yLmV4aXQsdD1yLmVudGVyLG49dm9pZCAwIT09ci5hcHBlYXI/ci5hcHBlYXI6dCkse2V4aXQ6ZSxlbnRlcjp0LGFwcGVhcjpufX0sbi51cGRhdGVTdGF0dXM9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT1lJiYoZT0hMSksbnVsbCE9PXQ/KHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCksImVudGVyaW5nIj09PXQ/dGhpcy5wZXJmb3JtRW50ZXIoZSk6dGhpcy5wZXJmb3JtRXhpdCgpKTp0",
                    "aGlzLnByb3BzLnVubW91bnRPbkV4aXQmJiJleGl0ZWQiPT09dGhpcy5zdGF0ZS5zdGF0dXMmJnRoaXMuc2V0U3RhdGUoe3N0YXR1czoidW5tb3VudGVkIn0pfSxuLnBlcmZvcm1FbnRlcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLG49dGhpcy5wcm9wcy5lbnRlcixyPXRoaXMuY29udGV4dD90aGlzLmNvbnRleHQuaXNNb3VudGluZzplLG89dGhpcy5wcm9wcy5ub2RlUmVmP1tyXTpbdS5hLmZpbmRET01Ob2RlKHRoaXMpLHJdLGk9b1swXSxhPW9bMV0sbD10aGlzLmdldFRpbWVvdXRzKCksYz1yP2wuYXBwZWFyOmwuZW50ZXI7IWUmJiFufHxzP3RoaXMuc2FmZVNldFN0YXRlKHtzdGF0dXM6ImVudGVyZWQifSwoZnVuY3Rpb24oKXt0LnByb3BzLm9uRW50ZXJlZChpKX0pKToodGhpcy5wcm9wcy5vbkVudGVyKGksYSksdGhpcy5zYWZlU2V0U3RhdGUoe3N0YXR1czoiZW50ZXJpbmcifSwoZnVuY3Rpb24oKXt0LnByb3BzLm9uRW50ZXJpbmcoaSxhKSx0Lm9uVHJhbnNpdGlvbkVuZChjLChmdW5jdGlvbigpe3Quc2FmZVNldFN0YXRlKHtzdGF0dXM6ImVudGVyZWQifSwoZnVuY3Rpb24oKXt0LnByb3BzLm9uRW50ZXJlZChpLGEpfSkpfSkpfSkpKX0sbi5wZXJmb3JtRXhpdD1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnByb3BzLmV4aXQsbj10aGlzLmdldFRpbWVvdXRzKCkscj10aGlzLnByb3BzLm5vZGVSZWY/dm9pZCAwOnUuYS5maW5kRE9NTm9kZSh0aGlzKTt0JiYhcz8odGhpcy5wcm9wcy5vbkV4aXQociksdGhpcy5z",
                    "YWZlU2V0U3RhdGUoe3N0YXR1czoiZXhpdGluZyJ9LChmdW5jdGlvbigpe2UucHJvcHMub25FeGl0aW5nKHIpLGUub25UcmFuc2l0aW9uRW5kKG4uZXhpdCwoZnVuY3Rpb24oKXtlLnNhZmVTZXRTdGF0ZSh7c3RhdHVzOiJleGl0ZWQifSwoZnVuY3Rpb24oKXtlLnByb3BzLm9uRXhpdGVkKHIpfSkpfSkpfSkpKTp0aGlzLnNhZmVTZXRTdGF0ZSh7c3RhdHVzOiJleGl0ZWQifSwoZnVuY3Rpb24oKXtlLnByb3BzLm9uRXhpdGVkKHIpfSkpfSxuLmNhbmNlbE5leHRDYWxsYmFjaz1mdW5jdGlvbigpe251bGwhPT10aGlzLm5leHRDYWxsYmFjayYmKHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpLHRoaXMubmV4dENhbGxiYWNrPW51bGwpfSxuLnNhZmVTZXRTdGF0ZT1mdW5jdGlvbihlLHQpe3Q9dGhpcy5zZXROZXh0Q2FsbGJhY2sodCksdGhpcy5zZXRTdGF0ZShlLHQpfSxuLnNldE5leHRDYWxsYmFjaz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLG49ITA7cmV0dXJuIHRoaXMubmV4dENhbGxiYWNrPWZ1bmN0aW9uKHIpe24mJihuPSExLHQubmV4dENhbGxiYWNrPW51bGwsZShyKSl9LHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbD1mdW5jdGlvbigpe249ITF9LHRoaXMubmV4dENhbGxiYWNrfSxuLm9uVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihlLHQpe3RoaXMuc2V0TmV4dENhbGxiYWNrKHQpO3ZhciBuPXRoaXMucHJvcHMubm9kZVJlZj90aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudDp1LmEuZmluZERPTU5vZGUodGhpcykscj1udWxs",
                    "PT1lJiYhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtpZihuJiYhcil7aWYodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcil7dmFyIG89dGhpcy5wcm9wcy5ub2RlUmVmP1t0aGlzLm5leHRDYWxsYmFja106W24sdGhpcy5uZXh0Q2FsbGJhY2tdLGk9b1swXSxhPW9bMV07dGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcihpLGEpfW51bGwhPWUmJnNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssZSl9ZWxzZSBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLDApfSxuLnJlbmRlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RhdGUuc3RhdHVzO2lmKCJ1bm1vdW50ZWQiPT09ZSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLnByb3BzLG49dC5jaGlsZHJlbixvPSh0LmluLHQubW91bnRPbkVudGVyLHQudW5tb3VudE9uRXhpdCx0LmFwcGVhcix0LmVudGVyLHQuZXhpdCx0LnRpbWVvdXQsdC5hZGRFbmRMaXN0ZW5lcix0Lm9uRW50ZXIsdC5vbkVudGVyaW5nLHQub25FbnRlcmVkLHQub25FeGl0LHQub25FeGl0aW5nLHQub25FeGl0ZWQsdC5ub2RlUmVmLE9iamVjdChyLmEpKHQsWyJjaGlsZHJlbiIsImluIiwibW91bnRPbkVudGVyIiwidW5tb3VudE9uRXhpdCIsImFwcGVhciIsImVudGVyIiwiZXhpdCIsInRpbWVvdXQiLCJhZGRFbmRMaXN0ZW5lciIsIm9uRW50ZXIiLCJvbkVudGVyaW5nIiwib25FbnRlcmVkIiwib25FeGl0Iiwib25FeGl0aW5nIiwib25FeGl0ZWQiLCJub2RlUmVmIl0pKTtyZXR1cm4gYS5hLmNyZWF0ZUVsZW1l",
                    "bnQoYy5hLlByb3ZpZGVyLHt2YWx1ZTpudWxsfSwiZnVuY3Rpb24iPT09dHlwZW9mIG4/bihlLG8pOmEuYS5jbG9uZUVsZW1lbnQoYS5hLkNoaWxkcmVuLm9ubHkobiksbykpfSx0fShhLmEuQ29tcG9uZW50KTtmdW5jdGlvbiBmKCl7fWQuY29udGV4dFR5cGU9Yy5hLGQucHJvcFR5cGVzPXt9LGQuZGVmYXVsdFByb3BzPXtpbjohMSxtb3VudE9uRW50ZXI6ITEsdW5tb3VudE9uRXhpdDohMSxhcHBlYXI6ITEsZW50ZXI6ITAsZXhpdDohMCxvbkVudGVyOmYsb25FbnRlcmluZzpmLG9uRW50ZXJlZDpmLG9uRXhpdDpmLG9uRXhpdGluZzpmLG9uRXhpdGVkOmZ9LGQuVU5NT1VOVEVEPSJ1bm1vdW50ZWQiLGQuRVhJVEVEPSJleGl0ZWQiLGQuRU5URVJJTkc9ImVudGVyaW5nIixkLkVOVEVSRUQ9ImVudGVyZWQiLGQuRVhJVElORz0iZXhpdGluZyI7dC5hPWR9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9Imh0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3Byb2R1Y3Rpb24tZXJyb3IvP2NvZGU9IitlLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bis9MSl0Kz0iJmFyZ3NbXT0iK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbbl0pO3JldHVybiJNaW5pZmllZCBNYXRlcmlhbC1VSSBlcnJvciAjIitlKyI7IHZpc2l0ICIrdCsiIGZvciB0aGUgZnVsbCBtZXNzYWdlLiJ9bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiByfSkpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3Zh",
                    "ciByPW4oMSksbz1uKDIpLGk9bigwKSxhPShuKDUpLG4oMykpLGw9big0KSx1PW4oNikscz1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jaGlsZHJlbixsPWUuY2xhc3NlcyxzPWUuY2xhc3NOYW1lLGM9ZS5jb2xvcixkPXZvaWQgMD09PWM/ImluaGVyaXQiOmMsZj1lLmNvbXBvbmVudCxwPXZvaWQgMD09PWY/InN2ZyI6ZixoPWUuZm9udFNpemUsbT12b2lkIDA9PT1oPyJkZWZhdWx0IjpoLHY9ZS5odG1sQ29sb3IsYj1lLnRpdGxlQWNjZXNzLHk9ZS52aWV3Qm94LGc9dm9pZCAwPT09eT8iMCAwIDI0IDI0Ijp5LHc9T2JqZWN0KG8uYSkoZSxbImNoaWxkcmVuIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbG9yIiwiY29tcG9uZW50IiwiZm9udFNpemUiLCJodG1sQ29sb3IiLCJ0aXRsZUFjY2VzcyIsInZpZXdCb3giXSk7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChwLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkobC5yb290LHMsImluaGVyaXQiIT09ZCYmbFsiY29sb3IiLmNvbmNhdChPYmplY3QodS5hKShkKSldLCJkZWZhdWx0IiE9PW0mJmxbImZvbnRTaXplIi5jb25jYXQoT2JqZWN0KHUuYSkobSkpXSksZm9jdXNhYmxlOiJmYWxzZSIsdmlld0JveDpnLGNvbG9yOnYsImFyaWEtaGlkZGVuIjohYnx8dm9pZCAwLHJvbGU6Yj8iaW1nIjp2b2lkIDAscmVmOnR9LHcpLG4sYj9pLmNyZWF0ZUVsZW1lbnQoInRpdGxlIixudWxsLGIpOm51bGwpfSkpO3MubXVpTmFtZT0iU3ZnSWNvbiIsdC5h",
                    "PU9iamVjdChsLmEpKChmdW5jdGlvbihlKXtyZXR1cm57cm9vdDp7dXNlclNlbGVjdDoibm9uZSIsd2lkdGg6IjFlbSIsaGVpZ2h0OiIxZW0iLGRpc3BsYXk6ImlubGluZS1ibG9jayIsZmlsbDoiY3VycmVudENvbG9yIixmbGV4U2hyaW5rOjAsZm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoImZpbGwiLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJ9KX0sY29sb3JQcmltYXJ5Ontjb2xvcjplLnBhbGV0dGUucHJpbWFyeS5tYWlufSxjb2xvclNlY29uZGFyeTp7Y29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWlufSxjb2xvckFjdGlvbjp7Y29sb3I6ZS5wYWxldHRlLmFjdGlvbi5hY3RpdmV9LGNvbG9yRXJyb3I6e2NvbG9yOmUucGFsZXR0ZS5lcnJvci5tYWlufSxjb2xvckRpc2FibGVkOntjb2xvcjplLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkfSxmb250U2l6ZUluaGVyaXQ6e2ZvbnRTaXplOiJpbmhlcml0In0sZm9udFNpemVTbWFsbDp7Zm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjApfSxmb250U2l6ZUxhcmdlOntmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgzNSl9fX0pLHtuYW1lOiJNdWlTdmdJY29uIn0pKHMpfSwsLCwsLCxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oNjMpLG89ImZ1bmN0aW9uIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsaT1vP1N5bWJvbC5mb3IoInJl",
                    "YWN0LmVsZW1lbnQiKTo2MDEwMyxhPW8/U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIik6NjAxMDYsbD1vP1N5bWJvbC5mb3IoInJlYWN0LmZyYWdtZW50Iik6NjAxMDcsdT1vP1N5bWJvbC5mb3IoInJlYWN0LnN0cmljdF9tb2RlIik6NjAxMDgscz1vP1N5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIik6NjAxMTQsYz1vP1N5bWJvbC5mb3IoInJlYWN0LnByb3ZpZGVyIik6NjAxMDksZD1vP1N5bWJvbC5mb3IoInJlYWN0LmNvbnRleHQiKTo2MDExMCxmPW8/U3ltYm9sLmZvcigicmVhY3QuZm9yd2FyZF9yZWYiKTo2MDExMixwPW8/U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2UiKTo2MDExMyxoPW8/U3ltYm9sLmZvcigicmVhY3QubWVtbyIpOjYwMTE1LG09bz9TeW1ib2wuZm9yKCJyZWFjdC5sYXp5Iik6NjAxMTYsdj0iZnVuY3Rpb24iPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIGIoZSl7Zm9yKHZhciB0PSJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0iK2Usbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdCs9IiZhcmdzW109IitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW25dKTtyZXR1cm4iTWluaWZpZWQgUmVhY3QgZXJyb3IgIyIrZSsiOyB2aXNpdCAiK3QrIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhl",
                    "bHBmdWwgd2FybmluZ3MuIn12YXIgeT17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX0sZz17fTtmdW5jdGlvbiB3KGUsdCxuKXt0aGlzLnByb3BzPWUsdGhpcy5jb250ZXh0PXQsdGhpcy5yZWZzPWcsdGhpcy51cGRhdGVyPW58fHl9ZnVuY3Rpb24geCgpe31mdW5jdGlvbiBFKGUsdCxuKXt0aGlzLnByb3BzPWUsdGhpcy5jb250ZXh0PXQsdGhpcy5yZWZzPWcsdGhpcy51cGRhdGVyPW58fHl9dy5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fSx3LnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihlLHQpe2lmKCJvYmplY3QiIT09dHlwZW9mIGUmJiJmdW5jdGlvbiIhPT10eXBlb2YgZSYmbnVsbCE9ZSl0aHJvdyBFcnJvcihiKDg1KSk7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGUsdCwic2V0U3RhdGUiKX0sdy5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oZSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGUsImZvcmNlVXBkYXRlIil9LHgucHJvdG90eXBlPXcucHJvdG90eXBlO3ZhciBPPUUucHJvdG90eXBlPW5ldyB4O08uY29uc3RydWN0b3I9RSxyKE8sdy5wcm90b3R5cGUpLE8uaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIGs9e2N1cnJlbnQ6bnVsbH0sUz1PYmplY3QucHJvdG90eXBl",
                    "Lmhhc093blByb3BlcnR5LEM9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtmdW5jdGlvbiBqKGUsdCxuKXt2YXIgcixvPXt9LGE9bnVsbCxsPW51bGw7aWYobnVsbCE9dClmb3IociBpbiB2b2lkIDAhPT10LnJlZiYmKGw9dC5yZWYpLHZvaWQgMCE9PXQua2V5JiYoYT0iIit0LmtleSksdClTLmNhbGwodCxyKSYmIUMuaGFzT3duUHJvcGVydHkocikmJihvW3JdPXRbcl0pO3ZhciB1PWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09dSlvLmNoaWxkcmVuPW47ZWxzZSBpZigxPHUpe2Zvcih2YXIgcz1BcnJheSh1KSxjPTA7Yzx1O2MrKylzW2NdPWFyZ3VtZW50c1tjKzJdO28uY2hpbGRyZW49c31pZihlJiZlLmRlZmF1bHRQcm9wcylmb3IociBpbiB1PWUuZGVmYXVsdFByb3BzKXZvaWQgMD09PW9bcl0mJihvW3JdPXVbcl0pO3JldHVybnskJHR5cGVvZjppLHR5cGU6ZSxrZXk6YSxyZWY6bCxwcm9wczpvLF9vd25lcjprLmN1cnJlbnR9fWZ1bmN0aW9uIFQoZSl7cmV0dXJuIm9iamVjdCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJmUuJCR0eXBlb2Y9PT1pfXZhciBQPS9cLysvZyxSPVtdO2Z1bmN0aW9uIE4oZSx0LG4scil7aWYoUi5sZW5ndGgpe3ZhciBvPVIucG9wKCk7cmV0dXJuIG8ucmVzdWx0PWUsby5rZXlQcmVmaXg9dCxvLmZ1bmM9bixvLmNvbnRleHQ9cixvLmNvdW50PTAsb31yZXR1cm57cmVzdWx0OmUsa2V5UHJlZml4OnQsZnVuYzpuLGNvbnRleHQ6cixjb3VudDowfX1mdW5jdGlvbiBNKGUpe2Uu",
                    "cmVzdWx0PW51bGwsZS5rZXlQcmVmaXg9bnVsbCxlLmZ1bmM9bnVsbCxlLmNvbnRleHQ9bnVsbCxlLmNvdW50PTAsMTA+Ui5sZW5ndGgmJlIucHVzaChlKX1mdW5jdGlvbiBfKGUsdCxuKXtyZXR1cm4gbnVsbD09ZT8wOmZ1bmN0aW9uIGUodCxuLHIsbyl7dmFyIGw9dHlwZW9mIHQ7InVuZGVmaW5lZCIhPT1sJiYiYm9vbGVhbiIhPT1sfHwodD1udWxsKTt2YXIgdT0hMTtpZihudWxsPT09dCl1PSEwO2Vsc2Ugc3dpdGNoKGwpe2Nhc2Uic3RyaW5nIjpjYXNlIm51bWJlciI6dT0hMDticmVhaztjYXNlIm9iamVjdCI6c3dpdGNoKHQuJCR0eXBlb2Ype2Nhc2UgaTpjYXNlIGE6dT0hMH19aWYodSlyZXR1cm4gcihvLHQsIiI9PT1uPyIuIitBKHQsMCk6biksMTtpZih1PTAsbj0iIj09PW4/Ii4iOm4rIjoiLEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBjPW4rQShsPXRbc10scyk7dSs9ZShsLGMscixvKX1lbHNlIGlmKG51bGw9PT10fHwib2JqZWN0IiE9PXR5cGVvZiB0P2M9bnVsbDpjPSJmdW5jdGlvbiI9PT10eXBlb2YoYz12JiZ0W3ZdfHx0WyJAQGl0ZXJhdG9yIl0pP2M6bnVsbCwiZnVuY3Rpb24iPT09dHlwZW9mIGMpZm9yKHQ9Yy5jYWxsKHQpLHM9MDshKGw9dC5uZXh0KCkpLmRvbmU7KXUrPWUobD1sLnZhbHVlLGM9bitBKGwscysrKSxyLG8pO2Vsc2UgaWYoIm9iamVjdCI9PT1sKXRocm93IHI9IiIrdCxFcnJvcihiKDMxLCJbb2JqZWN0IE9iamVjdF0iPT09cj8ib2JqZWN0IHdp",
                    "dGgga2V5cyB7IitPYmplY3Qua2V5cyh0KS5qb2luKCIsICIpKyJ9IjpyLCIiKSk7cmV0dXJuIHV9KGUsIiIsdCxuKX1mdW5jdGlvbiBBKGUsdCl7cmV0dXJuIm9iamVjdCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJm51bGwhPWUua2V5P2Z1bmN0aW9uKGUpe3ZhciB0PXsiPSI6Ij0wIiwiOiI6Ij0yIn07cmV0dXJuIiQiKygiIitlKS5yZXBsYWNlKC9bPTpdL2csKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkpfShlLmtleSk6dC50b1N0cmluZygzNil9ZnVuY3Rpb24gSShlLHQpe2UuZnVuYy5jYWxsKGUuY29udGV4dCx0LGUuY291bnQrKyl9ZnVuY3Rpb24gRChlLHQsbil7dmFyIHI9ZS5yZXN1bHQsbz1lLmtleVByZWZpeDtlPWUuZnVuYy5jYWxsKGUuY29udGV4dCx0LGUuY291bnQrKyksQXJyYXkuaXNBcnJheShlKT96KGUscixuLChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKTpudWxsIT1lJiYoVChlKSYmKGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm57JCR0eXBlb2Y6aSx0eXBlOmUudHlwZSxrZXk6dCxyZWY6ZS5yZWYscHJvcHM6ZS5wcm9wcyxfb3duZXI6ZS5fb3duZXJ9fShlLG8rKCFlLmtleXx8dCYmdC5rZXk9PT1lLmtleT8iIjooIiIrZS5rZXkpLnJlcGxhY2UoUCwiJCYvIikrIi8iKStuKSksci5wdXNoKGUpKX1mdW5jdGlvbiB6KGUsdCxuLHIsbyl7dmFyIGk9IiI7bnVsbCE9biYmKGk9KCIiK24pLnJlcGxhY2UoUCwiJCYvIikrIi8iKSxfKGUsRCx0PU4odCxpLHIsbykpLE0odCl9dmFyIEw9e2N1cnJlbnQ6bnVsbH07",
                    "ZnVuY3Rpb24gRigpe3ZhciBlPUwuY3VycmVudDtpZihudWxsPT09ZSl0aHJvdyBFcnJvcihiKDMyMSkpO3JldHVybiBlfXZhciAkPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOkwsUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6e3N1c3BlbnNlOm51bGx9LFJlYWN0Q3VycmVudE93bmVyOmssSXNTb21lUmVuZGVyZXJBY3Rpbmc6e2N1cnJlbnQ6ITF9LGFzc2lnbjpyfTt0LkNoaWxkcmVuPXttYXA6ZnVuY3Rpb24oZSx0LG4pe2lmKG51bGw9PWUpcmV0dXJuIGU7dmFyIHI9W107cmV0dXJuIHooZSxyLG51bGwsdCxuKSxyfSxmb3JFYWNoOmZ1bmN0aW9uKGUsdCxuKXtpZihudWxsPT1lKXJldHVybiBlO18oZSxJLHQ9TihudWxsLG51bGwsdCxuKSksTSh0KX0sY291bnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIF8oZSwoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pLG51bGwpfSx0b0FycmF5OmZ1bmN0aW9uKGUpe3ZhciB0PVtdO3JldHVybiB6KGUsdCxudWxsLChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKSx0fSxvbmx5OmZ1bmN0aW9uKGUpe2lmKCFUKGUpKXRocm93IEVycm9yKGIoMTQzKSk7cmV0dXJuIGV9fSx0LkNvbXBvbmVudD13LHQuRnJhZ21lbnQ9bCx0LlByb2ZpbGVyPXMsdC5QdXJlQ29tcG9uZW50PUUsdC5TdHJpY3RNb2RlPXUsdC5TdXNwZW5zZT1wLHQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9JCx0LmNsb25lRWxlbWVudD1mdW5jdGlvbihlLHQsbil7aWYobnVsbD09PWV8fHZv",
                    "aWQgMD09PWUpdGhyb3cgRXJyb3IoYigyNjcsZSkpO3ZhciBvPXIoe30sZS5wcm9wcyksYT1lLmtleSxsPWUucmVmLHU9ZS5fb3duZXI7aWYobnVsbCE9dCl7aWYodm9pZCAwIT09dC5yZWYmJihsPXQucmVmLHU9ay5jdXJyZW50KSx2b2lkIDAhPT10LmtleSYmKGE9IiIrdC5rZXkpLGUudHlwZSYmZS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgcz1lLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihjIGluIHQpUy5jYWxsKHQsYykmJiFDLmhhc093blByb3BlcnR5KGMpJiYob1tjXT12b2lkIDA9PT10W2NdJiZ2b2lkIDAhPT1zP3NbY106dFtjXSl9dmFyIGM9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1jKW8uY2hpbGRyZW49bjtlbHNlIGlmKDE8Yyl7cz1BcnJheShjKTtmb3IodmFyIGQ9MDtkPGM7ZCsrKXNbZF09YXJndW1lbnRzW2QrMl07by5jaGlsZHJlbj1zfXJldHVybnskJHR5cGVvZjppLHR5cGU6ZS50eXBlLGtleTphLHJlZjpsLHByb3BzOm8sX293bmVyOnV9fSx0LmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksKGU9eyQkdHlwZW9mOmQsX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOnQsX2N1cnJlbnRWYWx1ZTplLF9jdXJyZW50VmFsdWUyOmUsX3RocmVhZENvdW50OjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsfSkuUHJvdmlkZXI9eyQkdHlwZW9mOmMsX2NvbnRleHQ6ZX0sZS5Db25zdW1lcj1lfSx0LmNyZWF0ZUVsZW1lbnQ9aix0LmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rp",
                    "b24oZSl7dmFyIHQ9ai5iaW5kKG51bGwsZSk7cmV0dXJuIHQudHlwZT1lLHR9LHQuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19LHQuZm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm57JCR0eXBlb2Y6ZixyZW5kZXI6ZX19LHQuaXNWYWxpZEVsZW1lbnQ9VCx0Lmxhenk9ZnVuY3Rpb24oZSl7cmV0dXJueyQkdHlwZW9mOm0sX2N0b3I6ZSxfc3RhdHVzOi0xLF9yZXN1bHQ6bnVsbH19LHQubWVtbz1mdW5jdGlvbihlLHQpe3JldHVybnskJHR5cGVvZjpoLHR5cGU6ZSxjb21wYXJlOnZvaWQgMD09PXQ/bnVsbDp0fX0sdC51c2VDYWxsYmFjaz1mdW5jdGlvbihlLHQpe3JldHVybiBGKCkudXNlQ2FsbGJhY2soZSx0KX0sdC51c2VDb250ZXh0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEYoKS51c2VDb250ZXh0KGUsdCl9LHQudXNlRGVidWdWYWx1ZT1mdW5jdGlvbigpe30sdC51c2VFZmZlY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gRigpLnVzZUVmZmVjdChlLHQpfSx0LnVzZUltcGVyYXRpdmVIYW5kbGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBGKCkudXNlSW1wZXJhdGl2ZUhhbmRsZShlLHQsbil9LHQudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEYoKS51c2VMYXlvdXRFZmZlY3QoZSx0KX0sdC51c2VNZW1vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEYoKS51c2VNZW1vKGUsdCl9LHQudXNlUmVkdWNlcj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIEYoKS51c2VSZWR1Y2VyKGUsdCxu",
                    "KX0sdC51c2VSZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIEYoKS51c2VSZWYoZSl9LHQudXNlU3RhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIEYoKS51c2VTdGF0ZShlKX0sdC52ZXJzaW9uPSIxNi4xMy4xIn0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDApLG89big2MyksaT1uKDc2KTtmdW5jdGlvbiBhKGUpe2Zvcih2YXIgdD0iaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9IitlLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXQrPSImYXJnc1tdPSIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tuXSk7cmV0dXJuIk1pbmlmaWVkIFJlYWN0IGVycm9yICMiK2UrIjsgdmlzaXQgIit0KyIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLiJ9aWYoIXIpdGhyb3cgRXJyb3IoYSgyMjcpKTtmdW5jdGlvbiBsKGUsdCxuLHIsbyxpLGEsbCx1KXt2YXIgcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e3QuYXBwbHkobixzKX1jYXRjaChjKXt0aGlzLm9uRXJyb3IoYyl9fXZhciB1PSExLHM9bnVsbCxjPSExLGQ9bnVsbCxmPXtvbkVycm9yOmZ1bmN0aW9uKGUpe3U9ITAscz1lfX07ZnVuY3Rpb24gcChlLHQsbixyLG8saSxhLGMsZCl7dT0hMSxzPW51bGwsbC5hcHBseShmLGFyZ3Vt",
                    "ZW50cyl9dmFyIGg9bnVsbCxtPW51bGwsdj1udWxsO2Z1bmN0aW9uIGIoZSx0LG4pe3ZhciByPWUudHlwZXx8InVua25vd24tZXZlbnQiO2UuY3VycmVudFRhcmdldD12KG4pLGZ1bmN0aW9uKGUsdCxuLHIsbyxpLGwsZixoKXtpZihwLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx1KXtpZighdSl0aHJvdyBFcnJvcihhKDE5OCkpO3ZhciBtPXM7dT0hMSxzPW51bGwsY3x8KGM9ITAsZD1tKX19KHIsdCx2b2lkIDAsZSksZS5jdXJyZW50VGFyZ2V0PW51bGx9dmFyIHk9bnVsbCxnPXt9O2Z1bmN0aW9uIHcoKXtpZih5KWZvcih2YXIgZSBpbiBnKXt2YXIgdD1nW2VdLG49eS5pbmRleE9mKGUpO2lmKCEoLTE8bikpdGhyb3cgRXJyb3IoYSg5NixlKSk7aWYoIUVbbl0pe2lmKCF0LmV4dHJhY3RFdmVudHMpdGhyb3cgRXJyb3IoYSg5NyxlKSk7Zm9yKHZhciByIGluIEVbbl09dCxuPXQuZXZlbnRUeXBlcyl7dmFyIG89dm9pZCAwLGk9bltyXSxsPXQsdT1yO2lmKE8uaGFzT3duUHJvcGVydHkodSkpdGhyb3cgRXJyb3IoYSg5OSx1KSk7T1t1XT1pO3ZhciBzPWkucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYocyl7Zm9yKG8gaW4gcylzLmhhc093blByb3BlcnR5KG8pJiZ4KHNbb10sbCx1KTtvPSEwfWVsc2UgaS5yZWdpc3RyYXRpb25OYW1lPyh4KGkucmVnaXN0cmF0aW9uTmFtZSxsLHUpLG89ITApOm89ITE7aWYoIW8pdGhyb3cgRXJyb3IoYSg5OCxyLGUpKX19fX1mdW5jdGlvbiB4KGUsdCxuKXtpZihrW2VdKXRocm93IEVycm9yKGEo",
                    "MTAwLGUpKTtrW2VdPXQsU1tlXT10LmV2ZW50VHlwZXNbbl0uZGVwZW5kZW5jaWVzfXZhciBFPVtdLE89e30saz17fSxTPXt9O2Z1bmN0aW9uIEMoZSl7dmFyIHQsbj0hMTtmb3IodCBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkodCkpe3ZhciByPWVbdF07aWYoIWcuaGFzT3duUHJvcGVydHkodCl8fGdbdF0hPT1yKXtpZihnW3RdKXRocm93IEVycm9yKGEoMTAyLHQpKTtnW3RdPXIsbj0hMH19biYmdygpfXZhciBqPSEoInVuZGVmaW5lZCI9PT10eXBlb2Ygd2luZG93fHwidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnR8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxUPW51bGwsUD1udWxsLFI9bnVsbDtmdW5jdGlvbiBOKGUpe2lmKGU9bShlKSl7aWYoImZ1bmN0aW9uIiE9PXR5cGVvZiBUKXRocm93IEVycm9yKGEoMjgwKSk7dmFyIHQ9ZS5zdGF0ZU5vZGU7dCYmKHQ9aCh0KSxUKGUuc3RhdGVOb2RlLGUudHlwZSx0KSl9fWZ1bmN0aW9uIE0oZSl7UD9SP1IucHVzaChlKTpSPVtlXTpQPWV9ZnVuY3Rpb24gXygpe2lmKFApe3ZhciBlPVAsdD1SO2lmKFI9UD1udWxsLE4oZSksdClmb3IoZT0wO2U8dC5sZW5ndGg7ZSsrKU4odFtlXSl9fWZ1bmN0aW9uIEEoZSx0KXtyZXR1cm4gZSh0KX1mdW5jdGlvbiBJKGUsdCxuLHIsbyl7cmV0dXJuIGUodCxuLHIsbyl9ZnVuY3Rpb24gRCgpe312YXIgej1BLEw9ITEsRj0hMTtmdW5jdGlvbiAkKCl7bnVsbD09PVAmJm51bGw9",
                    "PT1SfHwoRCgpLF8oKSl9ZnVuY3Rpb24gVyhlLHQsbil7aWYoRilyZXR1cm4gZSh0LG4pO0Y9ITA7dHJ5e3JldHVybiB6KGUsdCxuKX1maW5hbGx5e0Y9ITEsJCgpfX12YXIgQj0vXls6QS1aX2Etelx1MDBDMC1cdTAwRDZcdTAwRDgtXHUwMEY2XHUwMEY4LVx1MDJGRlx1MDM3MC1cdTAzN0RcdTAzN0YtXHUxRkZGXHUyMDBDLVx1MjAwRFx1MjA3MC1cdTIxOEZcdTJDMDAtXHUyRkVGXHUzMDAxLVx1RDdGRlx1RjkwMC1cdUZEQ0ZcdUZERjAtXHVGRkZEXVs6QS1aX2Etelx1MDBDMC1cdTAwRDZcdTAwRDgtXHUwMEY2XHUwMEY4LVx1MDJGRlx1MDM3MC1cdTAzN0RcdTAzN0YtXHUxRkZGXHUyMDBDLVx1MjAwRFx1MjA3MC1cdTIxOEZcdTJDMDAtXHUyRkVGXHUzMDAxLVx1RDdGRlx1RjkwMC1cdUZEQ0ZcdUZERjAtXHVGRkZEXC0uMC05XHUwMEI3XHUwMzAwLVx1MDM2Rlx1MjAzRi1cdTIwNDBdKiQvLEg9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxWPXt9LFU9e307ZnVuY3Rpb24gcShlLHQsbixyLG8saSl7dGhpcy5hY2NlcHRzQm9vbGVhbnM9Mj09PXR8fDM9PT10fHw0PT09dCx0aGlzLmF0dHJpYnV0ZU5hbWU9cix0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZT1vLHRoaXMubXVzdFVzZVByb3BlcnR5PW4sdGhpcy5wcm9wZXJ0eU5hbWU9ZSx0aGlzLnR5cGU9dCx0aGlzLnNhbml0aXplVVJMPWl9dmFyIEs9e307ImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tl",
                    "ZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZSIuc3BsaXQoIiAiKS5mb3JFYWNoKChmdW5jdGlvbihlKXtLW2VdPW5ldyBxKGUsMCwhMSxlLG51bGwsITEpfSkpLFtbImFjY2VwdENoYXJzZXQiLCJhY2NlcHQtY2hhcnNldCJdLFsiY2xhc3NOYW1lIiwiY2xhc3MiXSxbImh0bWxGb3IiLCJmb3IiXSxbImh0dHBFcXVpdiIsImh0dHAtZXF1aXYiXV0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXTtLW3RdPW5ldyBxKHQsMSwhMSxlWzFdLG51bGwsITEpfSkpLFsiY29udGVudEVkaXRhYmxlIiwiZHJhZ2dhYmxlIiwic3BlbGxDaGVjayIsInZhbHVlIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7S1tlXT1uZXcgcShlLDIsITEsZS50b0xvd2VyQ2FzZSgpLG51bGwsITEpfSkpLFsiYXV0b1JldmVyc2UiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiZm9jdXNhYmxlIiwicHJlc2VydmVBbHBoYSJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0tbZV09bmV3IHEoZSwyLCExLGUsbnVsbCwhMSl9KSksImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBmb3JtTm9WYWxpZGF0ZSBoaWRkZW4gbG9vcCBub01vZHVsZSBub1ZhbGlkYXRlIG9wZW4gcGxheXNJbmxpbmUgcmVhZE9ubHkgcmVxdWlyZWQgcmV2ZXJzZWQgc2NvcGVk",
                    "IHNlYW1sZXNzIGl0ZW1TY29wZSIuc3BsaXQoIiAiKS5mb3JFYWNoKChmdW5jdGlvbihlKXtLW2VdPW5ldyBxKGUsMywhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMSl9KSksWyJjaGVja2VkIiwibXVsdGlwbGUiLCJtdXRlZCIsInNlbGVjdGVkIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7S1tlXT1uZXcgcShlLDMsITAsZSxudWxsLCExKX0pKSxbImNhcHR1cmUiLCJkb3dubG9hZCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0tbZV09bmV3IHEoZSw0LCExLGUsbnVsbCwhMSl9KSksWyJjb2xzIiwicm93cyIsInNpemUiLCJzcGFuIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7S1tlXT1uZXcgcShlLDYsITEsZSxudWxsLCExKX0pKSxbInJvd1NwYW4iLCJzdGFydCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0tbZV09bmV3IHEoZSw1LCExLGUudG9Mb3dlckNhc2UoKSxudWxsLCExKX0pKTt2YXIgWT0vW1wtOl0oW2Etel0pL2c7ZnVuY3Rpb24gUShlKXtyZXR1cm4gZVsxXS50b1VwcGVyQ2FzZSgpfSJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1v",
                    "cGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVy",
                    "dC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4bWxuczp4bGluayB4LWhlaWdodCIuc3BsaXQoIiAiKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UoWSxRKTtLW3RdPW5ldyBxKHQsMSwhMSxlLG51bGwsITEpfSkpLCJ4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6cm9sZSB4bGluazpzaG93IHhsaW5rOnRpdGxlIHhsaW5rOnR5cGUiLnNwbGl0KCIgIikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKFksUSk7S1t0XT1uZXcgcSh0LDEsITEsZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsITEpfSkpLFsieG1sOmJhc2UiLCJ4bWw6bGFuZyIsInhtbDpzcGFjZSJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZShZLFEpO0tbdF09bmV3IHEodCwxLCExLGUsImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSIsITEpfSkpLFsidGFiSW5kZXgiLCJjcm9zc09yaWdpbiJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0tbZV09bmV3IHEoZSwxLCExLGUudG9Mb3dlckNhc2UoKSxudWxsLCExKX0pKSxLLnhsaW5rSHJlZj1uZXcgcSgieGxpbmtIcmVmIiwxLCExLCJ4bGluazpocmVmIiwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsITApLFsic3JjIiwiaHJlZiIsImFjdGlvbiIsImZvcm1BY3Rpb24iXS5mb3JFYWNoKChmdW5jdGlvbihlKXtLW2VdPW5ldyBxKGUsMSwh",
                    "MSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMCl9KSk7dmFyIFg9ci5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtmdW5jdGlvbiBHKGUsdCxuLHIpe3ZhciBvPUsuaGFzT3duUHJvcGVydHkodCk/S1t0XTpudWxsOyhudWxsIT09bz8wPT09by50eXBlOiFyJiYoMjx0Lmxlbmd0aCYmKCJvIj09PXRbMF18fCJPIj09PXRbMF0pJiYoIm4iPT09dFsxXXx8Ik4iPT09dFsxXSkpKXx8KGZ1bmN0aW9uKGUsdCxuLHIpe2lmKG51bGw9PT10fHwidW5kZWZpbmVkIj09PXR5cGVvZiB0fHxmdW5jdGlvbihlLHQsbixyKXtpZihudWxsIT09biYmMD09PW4udHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIHQpe2Nhc2UiZnVuY3Rpb24iOmNhc2Uic3ltYm9sIjpyZXR1cm4hMDtjYXNlImJvb2xlYW4iOnJldHVybiFyJiYobnVsbCE9PW4/IW4uYWNjZXB0c0Jvb2xlYW5zOiJkYXRhLSIhPT0oZT1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KSkmJiJhcmlhLSIhPT1lKTtkZWZhdWx0OnJldHVybiExfX0oZSx0LG4scikpcmV0dXJuITA7aWYocilyZXR1cm4hMTtpZihudWxsIT09bilzd2l0Y2gobi50eXBlKXtjYXNlIDM6cmV0dXJuIXQ7Y2FzZSA0OnJldHVybiExPT09dDtjYXNlIDU6cmV0dXJuIGlzTmFOKHQpO2Nhc2UgNjpyZXR1cm4gaXNOYU4odCl8fDE+dH1yZXR1cm4hMX0odCxuLG8scikmJihuPW51bGwpLHJ8fG51bGw9PT1vP2Z1bmN0aW9uKGUpe3JldHVybiEhSC5jYWxsKFUsZSl8fCFILmNh",
                    "bGwoVixlKSYmKEIudGVzdChlKT9VW2VdPSEwOihWW2VdPSEwLCExKSl9KHQpJiYobnVsbD09PW4/ZS5yZW1vdmVBdHRyaWJ1dGUodCk6ZS5zZXRBdHRyaWJ1dGUodCwiIituKSk6by5tdXN0VXNlUHJvcGVydHk/ZVtvLnByb3BlcnR5TmFtZV09bnVsbD09PW4/MyE9PW8udHlwZSYmIiI6bjoodD1vLmF0dHJpYnV0ZU5hbWUscj1vLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09bj9lLnJlbW92ZUF0dHJpYnV0ZSh0KToobj0zPT09KG89by50eXBlKXx8ND09PW8mJiEwPT09bj8iIjoiIituLHI/ZS5zZXRBdHRyaWJ1dGVOUyhyLHQsbik6ZS5zZXRBdHRyaWJ1dGUodCxuKSkpKX1YLmhhc093blByb3BlcnR5KCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIil8fChYLlJlYWN0Q3VycmVudERpc3BhdGNoZXI9e2N1cnJlbnQ6bnVsbH0pLFguaGFzT3duUHJvcGVydHkoIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnIil8fChYLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnPXtzdXNwZW5zZTpudWxsfSk7dmFyIEo9L14oLiopW1xcXC9dLyxaPSJmdW5jdGlvbiI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGVlPVo/U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpOjYwMTAzLHRlPVo/U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIik6NjAxMDYsbmU9Wj9TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpOjYwMTA3LHJlPVo/U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKTo2MDEwOCxvZT1aP1N5bWJvbC5mb3IoInJlYWN0LnByb2Zp",
                    "bGVyIik6NjAxMTQsaWU9Wj9TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpOjYwMTA5LGFlPVo/U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpOjYwMTEwLGxlPVo/U3ltYm9sLmZvcigicmVhY3QuY29uY3VycmVudF9tb2RlIik6NjAxMTEsdWU9Wj9TeW1ib2wuZm9yKCJyZWFjdC5mb3J3YXJkX3JlZiIpOjYwMTEyLHNlPVo/U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2UiKTo2MDExMyxjZT1aP1N5bWJvbC5mb3IoInJlYWN0LnN1c3BlbnNlX2xpc3QiKTo2MDEyMCxkZT1aP1N5bWJvbC5mb3IoInJlYWN0Lm1lbW8iKTo2MDExNSxmZT1aP1N5bWJvbC5mb3IoInJlYWN0LmxhenkiKTo2MDExNixwZT1aP1N5bWJvbC5mb3IoInJlYWN0LmJsb2NrIik6NjAxMjEsaGU9ImZ1bmN0aW9uIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBtZShlKXtyZXR1cm4gbnVsbD09PWV8fCJvYmplY3QiIT09dHlwZW9mIGU/bnVsbDoiZnVuY3Rpb24iPT09dHlwZW9mKGU9aGUmJmVbaGVdfHxlWyJAQGl0ZXJhdG9yIl0pP2U6bnVsbH1mdW5jdGlvbiB2ZShlKXtpZihudWxsPT1lKXJldHVybiBudWxsO2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgZSlyZXR1cm4gZS5kaXNwbGF5TmFtZXx8ZS5uYW1lfHxudWxsO2lmKCJzdHJpbmciPT09dHlwZW9mIGUpcmV0dXJuIGU7c3dpdGNoKGUpe2Nhc2UgbmU6cmV0dXJuIkZyYWdtZW50IjtjYXNlIHRlOnJldHVybiJQb3J0YWwiO2Nhc2Ugb2U6cmV0dXJuIlByb2ZpbGVyIjtj",
                    "YXNlIHJlOnJldHVybiJTdHJpY3RNb2RlIjtjYXNlIHNlOnJldHVybiJTdXNwZW5zZSI7Y2FzZSBjZTpyZXR1cm4iU3VzcGVuc2VMaXN0In1pZigib2JqZWN0Ij09PXR5cGVvZiBlKXN3aXRjaChlLiQkdHlwZW9mKXtjYXNlIGFlOnJldHVybiJDb250ZXh0LkNvbnN1bWVyIjtjYXNlIGllOnJldHVybiJDb250ZXh0LlByb3ZpZGVyIjtjYXNlIHVlOnZhciB0PWUucmVuZGVyO3JldHVybiB0PXQuZGlzcGxheU5hbWV8fHQubmFtZXx8IiIsZS5kaXNwbGF5TmFtZXx8KCIiIT09dD8iRm9yd2FyZFJlZigiK3QrIikiOiJGb3J3YXJkUmVmIik7Y2FzZSBkZTpyZXR1cm4gdmUoZS50eXBlKTtjYXNlIHBlOnJldHVybiB2ZShlLnJlbmRlcik7Y2FzZSBmZTppZihlPTE9PT1lLl9zdGF0dXM/ZS5fcmVzdWx0Om51bGwpcmV0dXJuIHZlKGUpfXJldHVybiBudWxsfWZ1bmN0aW9uIGJlKGUpe3ZhciB0PSIiO2Rve2U6c3dpdGNoKGUudGFnKXtjYXNlIDM6Y2FzZSA0OmNhc2UgNjpjYXNlIDc6Y2FzZSAxMDpjYXNlIDk6dmFyIG49IiI7YnJlYWsgZTtkZWZhdWx0OnZhciByPWUuX2RlYnVnT3duZXIsbz1lLl9kZWJ1Z1NvdXJjZSxpPXZlKGUudHlwZSk7bj1udWxsLHImJihuPXZlKHIudHlwZSkpLHI9aSxpPSIiLG8/aT0iIChhdCAiK28uZmlsZU5hbWUucmVwbGFjZShKLCIiKSsiOiIrby5saW5lTnVtYmVyKyIpIjpuJiYoaT0iIChjcmVhdGVkIGJ5ICIrbisiKSIpLG49IlxuICAgIGluICIrKHJ8fCJVbmtub3duIikraX10Kz1uLGU9ZS5yZXR1",
                    "cm59d2hpbGUoZSk7cmV0dXJuIHR9ZnVuY3Rpb24geWUoZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlImJvb2xlYW4iOmNhc2UibnVtYmVyIjpjYXNlIm9iamVjdCI6Y2FzZSJzdHJpbmciOmNhc2UidW5kZWZpbmVkIjpyZXR1cm4gZTtkZWZhdWx0OnJldHVybiIifX1mdW5jdGlvbiBnZShlKXt2YXIgdD1lLnR5cGU7cmV0dXJuKGU9ZS5ub2RlTmFtZSkmJiJpbnB1dCI9PT1lLnRvTG93ZXJDYXNlKCkmJigiY2hlY2tib3giPT09dHx8InJhZGlvIj09PXQpfWZ1bmN0aW9uIHdlKGUpe2UuX3ZhbHVlVHJhY2tlcnx8KGUuX3ZhbHVlVHJhY2tlcj1mdW5jdGlvbihlKXt2YXIgdD1nZShlKT8iY2hlY2tlZCI6InZhbHVlIixuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsdCkscj0iIitlW3RdO2lmKCFlLmhhc093blByb3BlcnR5KHQpJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBuJiYiZnVuY3Rpb24iPT09dHlwZW9mIG4uZ2V0JiYiZnVuY3Rpb24iPT09dHlwZW9mIG4uc2V0KXt2YXIgbz1uLmdldCxpPW4uc2V0O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGUpe3I9IiIrZSxpLmNhbGwodGhpcyxlKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOm4uZW51bWVyYWJsZX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBy",
                    "fSxzZXRWYWx1ZTpmdW5jdGlvbihlKXtyPSIiK2V9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2UuX3ZhbHVlVHJhY2tlcj1udWxsLGRlbGV0ZSBlW3RdfX19fShlKSl9ZnVuY3Rpb24geGUoZSl7aWYoIWUpcmV0dXJuITE7dmFyIHQ9ZS5fdmFsdWVUcmFja2VyO2lmKCF0KXJldHVybiEwO3ZhciBuPXQuZ2V0VmFsdWUoKSxyPSIiO3JldHVybiBlJiYocj1nZShlKT9lLmNoZWNrZWQ/InRydWUiOiJmYWxzZSI6ZS52YWx1ZSksKGU9cikhPT1uJiYodC5zZXRWYWx1ZShlKSwhMCl9ZnVuY3Rpb24gRWUoZSx0KXt2YXIgbj10LmNoZWNrZWQ7cmV0dXJuIG8oe30sdCx7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6dm9pZCAwLGNoZWNrZWQ6bnVsbCE9bj9uOmUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIE9lKGUsdCl7dmFyIG49bnVsbD09dC5kZWZhdWx0VmFsdWU/IiI6dC5kZWZhdWx0VmFsdWUscj1udWxsIT10LmNoZWNrZWQ/dC5jaGVja2VkOnQuZGVmYXVsdENoZWNrZWQ7bj15ZShudWxsIT10LnZhbHVlP3QudmFsdWU6biksZS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpyLGluaXRpYWxWYWx1ZTpuLGNvbnRyb2xsZWQ6ImNoZWNrYm94Ij09PXQudHlwZXx8InJhZGlvIj09PXQudHlwZT9udWxsIT10LmNoZWNrZWQ6bnVsbCE9dC52YWx1ZX19ZnVuY3Rpb24ga2UoZSx0KXtudWxsIT0odD10LmNoZWNrZWQpJiZHKGUsImNoZWNrZWQiLHQsITEpfWZ1",
                    "bmN0aW9uIFNlKGUsdCl7a2UoZSx0KTt2YXIgbj15ZSh0LnZhbHVlKSxyPXQudHlwZTtpZihudWxsIT1uKSJudW1iZXIiPT09cj8oMD09PW4mJiIiPT09ZS52YWx1ZXx8ZS52YWx1ZSE9bikmJihlLnZhbHVlPSIiK24pOmUudmFsdWUhPT0iIituJiYoZS52YWx1ZT0iIituKTtlbHNlIGlmKCJzdWJtaXQiPT09cnx8InJlc2V0Ij09PXIpcmV0dXJuIHZvaWQgZS5yZW1vdmVBdHRyaWJ1dGUoInZhbHVlIik7dC5oYXNPd25Qcm9wZXJ0eSgidmFsdWUiKT9qZShlLHQudHlwZSxuKTp0Lmhhc093blByb3BlcnR5KCJkZWZhdWx0VmFsdWUiKSYmamUoZSx0LnR5cGUseWUodC5kZWZhdWx0VmFsdWUpKSxudWxsPT10LmNoZWNrZWQmJm51bGwhPXQuZGVmYXVsdENoZWNrZWQmJihlLmRlZmF1bHRDaGVja2VkPSEhdC5kZWZhdWx0Q2hlY2tlZCl9ZnVuY3Rpb24gQ2UoZSx0LG4pe2lmKHQuaGFzT3duUHJvcGVydHkoInZhbHVlIil8fHQuaGFzT3duUHJvcGVydHkoImRlZmF1bHRWYWx1ZSIpKXt2YXIgcj10LnR5cGU7aWYoISgic3VibWl0IiE9PXImJiJyZXNldCIhPT1yfHx2b2lkIDAhPT10LnZhbHVlJiZudWxsIT09dC52YWx1ZSkpcmV0dXJuO3Q9IiIrZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxufHx0PT09ZS52YWx1ZXx8KGUudmFsdWU9dCksZS5kZWZhdWx0VmFsdWU9dH0iIiE9PShuPWUubmFtZSkmJihlLm5hbWU9IiIpLGUuZGVmYXVsdENoZWNrZWQ9ISFlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsIiIhPT1uJiYo",
                    "ZS5uYW1lPW4pfWZ1bmN0aW9uIGplKGUsdCxuKXsibnVtYmVyIj09PXQmJmUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50PT09ZXx8KG51bGw9PW4/ZS5kZWZhdWx0VmFsdWU9IiIrZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTplLmRlZmF1bHRWYWx1ZSE9PSIiK24mJihlLmRlZmF1bHRWYWx1ZT0iIituKSl9ZnVuY3Rpb24gVGUoZSx0KXtyZXR1cm4gZT1vKHtjaGlsZHJlbjp2b2lkIDB9LHQpLCh0PWZ1bmN0aW9uKGUpe3ZhciB0PSIiO3JldHVybiByLkNoaWxkcmVuLmZvckVhY2goZSwoZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKHQrPWUpfSkpLHR9KHQuY2hpbGRyZW4pKSYmKGUuY2hpbGRyZW49dCksZX1mdW5jdGlvbiBQZShlLHQsbixyKXtpZihlPWUub3B0aW9ucyx0KXt0PXt9O2Zvcih2YXIgbz0wO288bi5sZW5ndGg7bysrKXRbIiQiK25bb11dPSEwO2ZvcihuPTA7bjxlLmxlbmd0aDtuKyspbz10Lmhhc093blByb3BlcnR5KCIkIitlW25dLnZhbHVlKSxlW25dLnNlbGVjdGVkIT09byYmKGVbbl0uc2VsZWN0ZWQ9byksbyYmciYmKGVbbl0uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2ZvcihuPSIiK3llKG4pLHQ9bnVsbCxvPTA7bzxlLmxlbmd0aDtvKyspe2lmKGVbb10udmFsdWU9PT1uKXJldHVybiBlW29dLnNlbGVjdGVkPSEwLHZvaWQociYmKGVbb10uZGVmYXVsdFNlbGVjdGVkPSEwKSk7bnVsbCE9PXR8fGVbb10uZGlzYWJsZWR8fCh0PWVbb10pfW51bGwhPT10JiYodC5zZWxlY3RlZD0hMCl9fWZ1bmN0",
                    "aW9uIFJlKGUsdCl7aWYobnVsbCE9dC5kYW5nZXJvdXNseVNldElubmVySFRNTCl0aHJvdyBFcnJvcihhKDkxKSk7cmV0dXJuIG8oe30sdCx7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46IiIrZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIE5lKGUsdCl7dmFyIG49dC52YWx1ZTtpZihudWxsPT1uKXtpZihuPXQuY2hpbGRyZW4sdD10LmRlZmF1bHRWYWx1ZSxudWxsIT1uKXtpZihudWxsIT10KXRocm93IEVycm9yKGEoOTIpKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZighKDE+PW4ubGVuZ3RoKSl0aHJvdyBFcnJvcihhKDkzKSk7bj1uWzBdfXQ9bn1udWxsPT10JiYodD0iIiksbj10fWUuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOnllKG4pfX1mdW5jdGlvbiBNZShlLHQpe3ZhciBuPXllKHQudmFsdWUpLHI9eWUodC5kZWZhdWx0VmFsdWUpO251bGwhPW4mJigobj0iIituKSE9PWUudmFsdWUmJihlLnZhbHVlPW4pLG51bGw9PXQuZGVmYXVsdFZhbHVlJiZlLmRlZmF1bHRWYWx1ZSE9PW4mJihlLmRlZmF1bHRWYWx1ZT1uKSksbnVsbCE9ciYmKGUuZGVmYXVsdFZhbHVlPSIiK3IpfWZ1bmN0aW9uIF9lKGUpe3ZhciB0PWUudGV4dENvbnRlbnQ7dD09PWUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJiIiIT09dCYmbnVsbCE9PXQmJihlLnZhbHVlPXQpfXZhciBBZT0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsSWU9Imh0dHA6Ly93d3cudzMub3JnLzIw",
                    "MDAvc3ZnIjtmdW5jdGlvbiBEZShlKXtzd2l0Y2goZSl7Y2FzZSJzdmciOnJldHVybiJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI7Y2FzZSJtYXRoIjpyZXR1cm4iaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCI7ZGVmYXVsdDpyZXR1cm4iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCJ9fWZ1bmN0aW9uIHplKGUsdCl7cmV0dXJuIG51bGw9PWV8fCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj09PWU/RGUodCk6Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj09PWUmJiJmb3JlaWduT2JqZWN0Ij09PXQ/Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiOmV9dmFyIExlLEZlPWZ1bmN0aW9uKGUpe3JldHVybiJ1bmRlZmluZWQiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbih0LG4scixvKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbigoZnVuY3Rpb24oKXtyZXR1cm4gZSh0LG4pfSkpfTplfSgoZnVuY3Rpb24oZSx0KXtpZihlLm5hbWVzcGFjZVVSSSE9PUllfHwiaW5uZXJIVE1MImluIGUpZS5pbm5lckhUTUw9dDtlbHNle2ZvcigoTGU9TGV8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpKS5pbm5lckhUTUw9Ijxzdmc+Iit0LnZhbHVlT2YoKS50b1N0cmluZygpKyI8L3N2Zz4iLHQ9TGUuZmlyc3RDaGlsZDtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtmb3IoO3QuZmlyc3RDaGlsZDsp",
                    "ZS5hcHBlbmRDaGlsZCh0LmZpcnN0Q2hpbGQpfX0pKTtmdW5jdGlvbiAkZShlLHQpe2lmKHQpe3ZhciBuPWUuZmlyc3RDaGlsZDtpZihuJiZuPT09ZS5sYXN0Q2hpbGQmJjM9PT1uLm5vZGVUeXBlKXJldHVybiB2b2lkKG4ubm9kZVZhbHVlPXQpfWUudGV4dENvbnRlbnQ9dH1mdW5jdGlvbiBXZShlLHQpe3ZhciBuPXt9O3JldHVybiBuW2UudG9Mb3dlckNhc2UoKV09dC50b0xvd2VyQ2FzZSgpLG5bIldlYmtpdCIrZV09IndlYmtpdCIrdCxuWyJNb3oiK2VdPSJtb3oiK3Qsbn12YXIgQmU9e2FuaW1hdGlvbmVuZDpXZSgiQW5pbWF0aW9uIiwiQW5pbWF0aW9uRW5kIiksYW5pbWF0aW9uaXRlcmF0aW9uOldlKCJBbmltYXRpb24iLCJBbmltYXRpb25JdGVyYXRpb24iKSxhbmltYXRpb25zdGFydDpXZSgiQW5pbWF0aW9uIiwiQW5pbWF0aW9uU3RhcnQiKSx0cmFuc2l0aW9uZW5kOldlKCJUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbkVuZCIpfSxIZT17fSxWZT17fTtmdW5jdGlvbiBVZShlKXtpZihIZVtlXSlyZXR1cm4gSGVbZV07aWYoIUJlW2VdKXJldHVybiBlO3ZhciB0LG49QmVbZV07Zm9yKHQgaW4gbilpZihuLmhhc093blByb3BlcnR5KHQpJiZ0IGluIFZlKXJldHVybiBIZVtlXT1uW3RdO3JldHVybiBlfWomJihWZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKS5zdHlsZSwiQW5pbWF0aW9uRXZlbnQiaW4gd2luZG93fHwoZGVsZXRlIEJlLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIEJlLmFuaW1hdGlvbml0",
                    "ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIEJlLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksIlRyYW5zaXRpb25FdmVudCJpbiB3aW5kb3d8fGRlbGV0ZSBCZS50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO3ZhciBxZT1VZSgiYW5pbWF0aW9uZW5kIiksS2U9VWUoImFuaW1hdGlvbml0ZXJhdGlvbiIpLFllPVVlKCJhbmltYXRpb25zdGFydCIpLFFlPVVlKCJ0cmFuc2l0aW9uZW5kIiksWGU9ImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2Ugc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmciLnNwbGl0KCIgIiksR2U9bmV3KCJmdW5jdGlvbiI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcCk7ZnVuY3Rpb24gSmUoZSl7dmFyIHQ9R2UuZ2V0KGUpO3JldHVybiB2b2lkIDA9PT10JiYodD1uZXcgTWFwLEdlLnNldChlLHQpKSx0fWZ1bmN0aW9uIFplKGUpe3ZhciB0PWUsbj1lO2lmKGUuYWx0ZXJuYXRlKWZvcig7dC5yZXR1cm47KXQ9dC5yZXR1cm47ZWxzZXtlPXQ7ZG97MCE9PSgxMDI2Jih0PWUpLmVmZmVjdFRhZykmJihuPXQucmV0dXJuKSxlPXQucmV0dXJufXdoaWxlKGUpfXJldHVybiAzPT09dC50YWc/bjpudWxsfWZ1bmN0aW9uIGV0KGUp",
                    "e2lmKDEzPT09ZS50YWcpe3ZhciB0PWUubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09dCYmKG51bGwhPT0oZT1lLmFsdGVybmF0ZSkmJih0PWUubWVtb2l6ZWRTdGF0ZSkpLG51bGwhPT10KXJldHVybiB0LmRlaHlkcmF0ZWR9cmV0dXJuIG51bGx9ZnVuY3Rpb24gdHQoZSl7aWYoWmUoZSkhPT1lKXRocm93IEVycm9yKGEoMTg4KSl9ZnVuY3Rpb24gbnQoZSl7aWYoIShlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuYWx0ZXJuYXRlO2lmKCF0KXtpZihudWxsPT09KHQ9WmUoZSkpKXRocm93IEVycm9yKGEoMTg4KSk7cmV0dXJuIHQhPT1lP251bGw6ZX1mb3IodmFyIG49ZSxyPXQ7Oyl7dmFyIG89bi5yZXR1cm47aWYobnVsbD09PW8pYnJlYWs7dmFyIGk9by5hbHRlcm5hdGU7aWYobnVsbD09PWkpe2lmKG51bGwhPT0ocj1vLnJldHVybikpe249cjtjb250aW51ZX1icmVha31pZihvLmNoaWxkPT09aS5jaGlsZCl7Zm9yKGk9by5jaGlsZDtpOyl7aWYoaT09PW4pcmV0dXJuIHR0KG8pLGU7aWYoaT09PXIpcmV0dXJuIHR0KG8pLHQ7aT1pLnNpYmxpbmd9dGhyb3cgRXJyb3IoYSgxODgpKX1pZihuLnJldHVybiE9PXIucmV0dXJuKW49byxyPWk7ZWxzZXtmb3IodmFyIGw9ITEsdT1vLmNoaWxkO3U7KXtpZih1PT09bil7bD0hMCxuPW8scj1pO2JyZWFrfWlmKHU9PT1yKXtsPSEwLHI9byxuPWk7YnJlYWt9dT11LnNpYmxpbmd9aWYoIWwpe2Zvcih1PWkuY2hpbGQ7dTspe2lmKHU9PT1uKXtsPSEwLG49aSxyPW87YnJlYWt9aWYodT09PXIpe2w9",
                    "ITAscj1pLG49bzticmVha311PXUuc2libGluZ31pZighbCl0aHJvdyBFcnJvcihhKDE4OSkpfX1pZihuLmFsdGVybmF0ZSE9PXIpdGhyb3cgRXJyb3IoYSgxOTApKX1pZigzIT09bi50YWcpdGhyb3cgRXJyb3IoYSgxODgpKTtyZXR1cm4gbi5zdGF0ZU5vZGUuY3VycmVudD09PW4/ZTp0fShlKSkpcmV0dXJuIG51bGw7Zm9yKHZhciB0PWU7Oyl7aWYoNT09PXQudGFnfHw2PT09dC50YWcpcmV0dXJuIHQ7aWYodC5jaGlsZCl0LmNoaWxkLnJldHVybj10LHQ9dC5jaGlsZDtlbHNle2lmKHQ9PT1lKWJyZWFrO2Zvcig7IXQuc2libGluZzspe2lmKCF0LnJldHVybnx8dC5yZXR1cm49PT1lKXJldHVybiBudWxsO3Q9dC5yZXR1cm59dC5zaWJsaW5nLnJldHVybj10LnJldHVybix0PXQuc2libGluZ319cmV0dXJuIG51bGx9ZnVuY3Rpb24gcnQoZSx0KXtpZihudWxsPT10KXRocm93IEVycm9yKGEoMzApKTtyZXR1cm4gbnVsbD09ZT90OkFycmF5LmlzQXJyYXkoZSk/QXJyYXkuaXNBcnJheSh0KT8oZS5wdXNoLmFwcGx5KGUsdCksZSk6KGUucHVzaCh0KSxlKTpBcnJheS5pc0FycmF5KHQpP1tlXS5jb25jYXQodCk6W2UsdF19ZnVuY3Rpb24gb3QoZSx0LG4pe0FycmF5LmlzQXJyYXkoZSk/ZS5mb3JFYWNoKHQsbik6ZSYmdC5jYWxsKG4sZSl9dmFyIGl0PW51bGw7ZnVuY3Rpb24gYXQoZSl7aWYoZSl7dmFyIHQ9ZS5fZGlzcGF0Y2hMaXN0ZW5lcnMsbj1lLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KHQpKWZvcih2",
                    "YXIgcj0wO3I8dC5sZW5ndGgmJiFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7cisrKWIoZSx0W3JdLG5bcl0pO2Vsc2UgdCYmYihlLHQsbik7ZS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbCxlLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsLGUuaXNQZXJzaXN0ZW50KCl8fGUuY29uc3RydWN0b3IucmVsZWFzZShlKX19ZnVuY3Rpb24gbHQoZSl7aWYobnVsbCE9PWUmJihpdD1ydChpdCxlKSksZT1pdCxpdD1udWxsLGUpe2lmKG90KGUsYXQpLGl0KXRocm93IEVycm9yKGEoOTUpKTtpZihjKXRocm93IGU9ZCxjPSExLGQ9bnVsbCxlfX1mdW5jdGlvbiB1dChlKXtyZXR1cm4oZT1lLnRhcmdldHx8ZS5zcmNFbGVtZW50fHx3aW5kb3cpLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoZT1lLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSwzPT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGU6ZX1mdW5jdGlvbiBzdChlKXtpZighailyZXR1cm4hMTt2YXIgdD0oZT0ib24iK2UpaW4gZG9jdW1lbnQ7cmV0dXJuIHR8fCgodD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSkuc2V0QXR0cmlidXRlKGUsInJldHVybjsiKSx0PSJmdW5jdGlvbiI9PT10eXBlb2YgdFtlXSksdH12YXIgY3Q9W107ZnVuY3Rpb24gZHQoZSl7ZS50b3BMZXZlbFR5cGU9bnVsbCxlLm5hdGl2ZUV2ZW50PW51bGwsZS50YXJnZXRJbnN0PW51bGwsZS5hbmNlc3RvcnMubGVuZ3RoPTAsMTA+Y3QubGVuZ3RoJiZjdC5wdXNoKGUpfWZ1bmN0aW9uIGZ0KGUsdCxuLHIpe2lm",
                    "KGN0Lmxlbmd0aCl7dmFyIG89Y3QucG9wKCk7cmV0dXJuIG8udG9wTGV2ZWxUeXBlPWUsby5ldmVudFN5c3RlbUZsYWdzPXIsby5uYXRpdmVFdmVudD10LG8udGFyZ2V0SW5zdD1uLG99cmV0dXJue3RvcExldmVsVHlwZTplLGV2ZW50U3lzdGVtRmxhZ3M6cixuYXRpdmVFdmVudDp0LHRhcmdldEluc3Q6bixhbmNlc3RvcnM6W119fWZ1bmN0aW9uIHB0KGUpe3ZhciB0PWUudGFyZ2V0SW5zdCxuPXQ7ZG97aWYoIW4pe2UuYW5jZXN0b3JzLnB1c2gobik7YnJlYWt9dmFyIHI9bjtpZigzPT09ci50YWcpcj1yLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Vsc2V7Zm9yKDtyLnJldHVybjspcj1yLnJldHVybjtyPTMhPT1yLnRhZz9udWxsOnIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm99aWYoIXIpYnJlYWs7NSE9PSh0PW4udGFnKSYmNiE9PXR8fGUuYW5jZXN0b3JzLnB1c2gobiksbj1qbihyKX13aGlsZShuKTtmb3Iobj0wO248ZS5hbmNlc3RvcnMubGVuZ3RoO24rKyl7dD1lLmFuY2VzdG9yc1tuXTt2YXIgbz11dChlLm5hdGl2ZUV2ZW50KTtyPWUudG9wTGV2ZWxUeXBlO3ZhciBpPWUubmF0aXZlRXZlbnQsYT1lLmV2ZW50U3lzdGVtRmxhZ3M7MD09PW4mJihhfD02NCk7Zm9yKHZhciBsPW51bGwsdT0wO3U8RS5sZW5ndGg7dSsrKXt2YXIgcz1FW3VdO3MmJihzPXMuZXh0cmFjdEV2ZW50cyhyLHQsaSxvLGEpKSYmKGw9cnQobCxzKSl9bHQobCl9fWZ1bmN0aW9uIGh0KGUsdCxuKXtpZighbi5oYXMoZSkpe3N3aXRjaChlKXtjYXNl",
                    "InNjcm9sbCI6WXQodCwic2Nyb2xsIiwhMCk7YnJlYWs7Y2FzZSJmb2N1cyI6Y2FzZSJibHVyIjpZdCh0LCJmb2N1cyIsITApLFl0KHQsImJsdXIiLCEwKSxuLnNldCgiYmx1ciIsbnVsbCksbi5zZXQoImZvY3VzIixudWxsKTticmVhaztjYXNlImNhbmNlbCI6Y2FzZSJjbG9zZSI6c3QoZSkmJll0KHQsZSwhMCk7YnJlYWs7Y2FzZSJpbnZhbGlkIjpjYXNlInN1Ym1pdCI6Y2FzZSJyZXNldCI6YnJlYWs7ZGVmYXVsdDotMT09PVhlLmluZGV4T2YoZSkmJkt0KGUsdCl9bi5zZXQoZSxudWxsKX19dmFyIG10LHZ0LGJ0LHl0PSExLGd0PVtdLHd0PW51bGwseHQ9bnVsbCxFdD1udWxsLE90PW5ldyBNYXAsa3Q9bmV3IE1hcCxTdD1bXSxDdD0ibW91c2Vkb3duIG1vdXNldXAgdG91Y2hjYW5jZWwgdG91Y2hlbmQgdG91Y2hzdGFydCBhdXhjbGljayBkYmxjbGljayBwb2ludGVyY2FuY2VsIHBvaW50ZXJkb3duIHBvaW50ZXJ1cCBkcmFnZW5kIGRyYWdzdGFydCBkcm9wIGNvbXBvc2l0aW9uZW5kIGNvbXBvc2l0aW9uc3RhcnQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dCB0ZXh0SW5wdXQgY2xvc2UgY2FuY2VsIGNvcHkgY3V0IHBhc3RlIGNsaWNrIGNoYW5nZSBjb250ZXh0bWVudSByZXNldCBzdWJtaXQiLnNwbGl0KCIgIiksanQ9ImZvY3VzIGJsdXIgZHJhZ2VudGVyIGRyYWdsZWF2ZSBtb3VzZW92ZXIgbW91c2VvdXQgcG9pbnRlcm92ZXIgcG9pbnRlcm91dCBnb3Rwb2ludGVyY2FwdHVyZSBsb3N0cG9pbnRlcmNhcHR1cmUi",
                    "LnNwbGl0KCIgIik7ZnVuY3Rpb24gVHQoZSx0LG4scixvKXtyZXR1cm57YmxvY2tlZE9uOmUsdG9wTGV2ZWxUeXBlOnQsZXZlbnRTeXN0ZW1GbGFnczozMnxuLG5hdGl2ZUV2ZW50Om8sY29udGFpbmVyOnJ9fWZ1bmN0aW9uIFB0KGUsdCl7c3dpdGNoKGUpe2Nhc2UiZm9jdXMiOmNhc2UiYmx1ciI6d3Q9bnVsbDticmVhaztjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnbGVhdmUiOnh0PW51bGw7YnJlYWs7Y2FzZSJtb3VzZW92ZXIiOmNhc2UibW91c2VvdXQiOkV0PW51bGw7YnJlYWs7Y2FzZSJwb2ludGVyb3ZlciI6Y2FzZSJwb2ludGVyb3V0IjpPdC5kZWxldGUodC5wb2ludGVySWQpO2JyZWFrO2Nhc2UiZ290cG9pbnRlcmNhcHR1cmUiOmNhc2UibG9zdHBvaW50ZXJjYXB0dXJlIjprdC5kZWxldGUodC5wb2ludGVySWQpfX1mdW5jdGlvbiBSdChlLHQsbixyLG8saSl7cmV0dXJuIG51bGw9PT1lfHxlLm5hdGl2ZUV2ZW50IT09aT8oZT1UdCh0LG4scixvLGkpLG51bGwhPT10JiYobnVsbCE9PSh0PVRuKHQpKSYmdnQodCkpLGUpOihlLmV2ZW50U3lzdGVtRmxhZ3N8PXIsZSl9ZnVuY3Rpb24gTnQoZSl7dmFyIHQ9am4oZS50YXJnZXQpO2lmKG51bGwhPT10KXt2YXIgbj1aZSh0KTtpZihudWxsIT09bilpZigxMz09PSh0PW4udGFnKSl7aWYobnVsbCE9PSh0PWV0KG4pKSlyZXR1cm4gZS5ibG9ja2VkT249dCx2b2lkIGkudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGUucHJpb3JpdHksKGZ1bmN0aW9uKCl7YnQobil9KSl9ZWxz",
                    "ZSBpZigzPT09dCYmbi5zdGF0ZU5vZGUuaHlkcmF0ZSlyZXR1cm4gdm9pZChlLmJsb2NrZWRPbj0zPT09bi50YWc/bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsKX1lLmJsb2NrZWRPbj1udWxsfWZ1bmN0aW9uIE10KGUpe2lmKG51bGwhPT1lLmJsb2NrZWRPbilyZXR1cm4hMTt2YXIgdD1KdChlLnRvcExldmVsVHlwZSxlLmV2ZW50U3lzdGVtRmxhZ3MsZS5jb250YWluZXIsZS5uYXRpdmVFdmVudCk7aWYobnVsbCE9PXQpe3ZhciBuPVRuKHQpO3JldHVybiBudWxsIT09biYmdnQobiksZS5ibG9ja2VkT249dCwhMX1yZXR1cm4hMH1mdW5jdGlvbiBfdChlLHQsbil7TXQoZSkmJm4uZGVsZXRlKHQpfWZ1bmN0aW9uIEF0KCl7Zm9yKHl0PSExOzA8Z3QubGVuZ3RoOyl7dmFyIGU9Z3RbMF07aWYobnVsbCE9PWUuYmxvY2tlZE9uKXtudWxsIT09KGU9VG4oZS5ibG9ja2VkT24pKSYmbXQoZSk7YnJlYWt9dmFyIHQ9SnQoZS50b3BMZXZlbFR5cGUsZS5ldmVudFN5c3RlbUZsYWdzLGUuY29udGFpbmVyLGUubmF0aXZlRXZlbnQpO251bGwhPT10P2UuYmxvY2tlZE9uPXQ6Z3Quc2hpZnQoKX1udWxsIT09d3QmJk10KHd0KSYmKHd0PW51bGwpLG51bGwhPT14dCYmTXQoeHQpJiYoeHQ9bnVsbCksbnVsbCE9PUV0JiZNdChFdCkmJihFdD1udWxsKSxPdC5mb3JFYWNoKF90KSxrdC5mb3JFYWNoKF90KX1mdW5jdGlvbiBJdChlLHQpe2UuYmxvY2tlZE9uPT09dCYmKGUuYmxvY2tlZE9uPW51bGwseXR8fCh5dD0hMCxpLnVuc3RhYmxl",
                    "X3NjaGVkdWxlQ2FsbGJhY2soaS51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxBdCkpKX1mdW5jdGlvbiBEdChlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBJdCh0LGUpfWlmKDA8Z3QubGVuZ3RoKXtJdChndFswXSxlKTtmb3IodmFyIG49MTtuPGd0Lmxlbmd0aDtuKyspe3ZhciByPWd0W25dO3IuYmxvY2tlZE9uPT09ZSYmKHIuYmxvY2tlZE9uPW51bGwpfX1mb3IobnVsbCE9PXd0JiZJdCh3dCxlKSxudWxsIT09eHQmJkl0KHh0LGUpLG51bGwhPT1FdCYmSXQoRXQsZSksT3QuZm9yRWFjaCh0KSxrdC5mb3JFYWNoKHQpLG49MDtuPFN0Lmxlbmd0aDtuKyspKHI9U3Rbbl0pLmJsb2NrZWRPbj09PWUmJihyLmJsb2NrZWRPbj1udWxsKTtmb3IoOzA8U3QubGVuZ3RoJiZudWxsPT09KG49U3RbMF0pLmJsb2NrZWRPbjspTnQobiksbnVsbD09PW4uYmxvY2tlZE9uJiZTdC5zaGlmdCgpfXZhciB6dD17fSxMdD1uZXcgTWFwLEZ0PW5ldyBNYXAsJHQ9WyJhYm9ydCIsImFib3J0IixxZSwiYW5pbWF0aW9uRW5kIixLZSwiYW5pbWF0aW9uSXRlcmF0aW9uIixZZSwiYW5pbWF0aW9uU3RhcnQiLCJjYW5wbGF5IiwiY2FuUGxheSIsImNhbnBsYXl0aHJvdWdoIiwiY2FuUGxheVRocm91Z2giLCJkdXJhdGlvbmNoYW5nZSIsImR1cmF0aW9uQ2hhbmdlIiwiZW1wdGllZCIsImVtcHRpZWQiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0ZWQiLCJlbmRlZCIsImVuZGVkIiwiZXJyb3IiLCJlcnJvciIsImdvdHBvaW50ZXJjYXB0dXJlIiwiZ290UG9pbnRlckNh",
                    "cHR1cmUiLCJsb2FkIiwibG9hZCIsImxvYWRlZGRhdGEiLCJsb2FkZWREYXRhIiwibG9hZGVkbWV0YWRhdGEiLCJsb2FkZWRNZXRhZGF0YSIsImxvYWRzdGFydCIsImxvYWRTdGFydCIsImxvc3Rwb2ludGVyY2FwdHVyZSIsImxvc3RQb2ludGVyQ2FwdHVyZSIsInBsYXlpbmciLCJwbGF5aW5nIiwicHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInNlZWtpbmciLCJzZWVraW5nIiwic3RhbGxlZCIsInN0YWxsZWQiLCJzdXNwZW5kIiwic3VzcGVuZCIsInRpbWV1cGRhdGUiLCJ0aW1lVXBkYXRlIixRZSwidHJhbnNpdGlvbkVuZCIsIndhaXRpbmciLCJ3YWl0aW5nIl07ZnVuY3Rpb24gV3QoZSx0KXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rPTIpe3ZhciByPWVbbl0sbz1lW24rMV0saT0ib24iKyhvWzBdLnRvVXBwZXJDYXNlKCkrby5zbGljZSgxKSk7aT17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6aSxjYXB0dXJlZDppKyJDYXB0dXJlIn0sZGVwZW5kZW5jaWVzOltyXSxldmVudFByaW9yaXR5OnR9LEZ0LnNldChyLHQpLEx0LnNldChyLGkpLHp0W29dPWl9fVd0KCJibHVyIGJsdXIgY2FuY2VsIGNhbmNlbCBjbGljayBjbGljayBjbG9zZSBjbG9zZSBjb250ZXh0bWVudSBjb250ZXh0TWVudSBjb3B5IGNvcHkgY3V0IGN1dCBhdXhjbGljayBhdXhDbGljayBkYmxjbGljayBkb3VibGVDbGljayBkcmFnZW5kIGRyYWdFbmQgZHJhZ3N0YXJ0IGRyYWdTdGFydCBkcm9wIGRyb3AgZm9jdXMgZm9jdXMgaW5wdXQgaW5wdXQg",
                    "aW52YWxpZCBpbnZhbGlkIGtleWRvd24ga2V5RG93biBrZXlwcmVzcyBrZXlQcmVzcyBrZXl1cCBrZXlVcCBtb3VzZWRvd24gbW91c2VEb3duIG1vdXNldXAgbW91c2VVcCBwYXN0ZSBwYXN0ZSBwYXVzZSBwYXVzZSBwbGF5IHBsYXkgcG9pbnRlcmNhbmNlbCBwb2ludGVyQ2FuY2VsIHBvaW50ZXJkb3duIHBvaW50ZXJEb3duIHBvaW50ZXJ1cCBwb2ludGVyVXAgcmF0ZWNoYW5nZSByYXRlQ2hhbmdlIHJlc2V0IHJlc2V0IHNlZWtlZCBzZWVrZWQgc3VibWl0IHN1Ym1pdCB0b3VjaGNhbmNlbCB0b3VjaENhbmNlbCB0b3VjaGVuZCB0b3VjaEVuZCB0b3VjaHN0YXJ0IHRvdWNoU3RhcnQgdm9sdW1lY2hhbmdlIHZvbHVtZUNoYW5nZSIuc3BsaXQoIiAiKSwwKSxXdCgiZHJhZyBkcmFnIGRyYWdlbnRlciBkcmFnRW50ZXIgZHJhZ2V4aXQgZHJhZ0V4aXQgZHJhZ2xlYXZlIGRyYWdMZWF2ZSBkcmFnb3ZlciBkcmFnT3ZlciBtb3VzZW1vdmUgbW91c2VNb3ZlIG1vdXNlb3V0IG1vdXNlT3V0IG1vdXNlb3ZlciBtb3VzZU92ZXIgcG9pbnRlcm1vdmUgcG9pbnRlck1vdmUgcG9pbnRlcm91dCBwb2ludGVyT3V0IHBvaW50ZXJvdmVyIHBvaW50ZXJPdmVyIHNjcm9sbCBzY3JvbGwgdG9nZ2xlIHRvZ2dsZSB0b3VjaG1vdmUgdG91Y2hNb3ZlIHdoZWVsIHdoZWVsIi5zcGxpdCgiICIpLDEpLFd0KCR0LDIpO2Zvcih2YXIgQnQ9ImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQg",
                    "Y29tcG9zaXRpb251cGRhdGUiLnNwbGl0KCIgIiksSHQ9MDtIdDxCdC5sZW5ndGg7SHQrKylGdC5zZXQoQnRbSHRdLDApO3ZhciBWdD1pLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFV0PWkudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5LHF0PSEwO2Z1bmN0aW9uIEt0KGUsdCl7WXQodCxlLCExKX1mdW5jdGlvbiBZdChlLHQsbil7dmFyIHI9RnQuZ2V0KHQpO3N3aXRjaCh2b2lkIDA9PT1yPzI6cil7Y2FzZSAwOnI9UXQuYmluZChudWxsLHQsMSxlKTticmVhaztjYXNlIDE6cj1YdC5iaW5kKG51bGwsdCwxLGUpO2JyZWFrO2RlZmF1bHQ6cj1HdC5iaW5kKG51bGwsdCwxLGUpfW4/ZS5hZGRFdmVudExpc3RlbmVyKHQsciwhMCk6ZS5hZGRFdmVudExpc3RlbmVyKHQsciwhMSl9ZnVuY3Rpb24gUXQoZSx0LG4scil7THx8RCgpO3ZhciBvPUd0LGk9TDtMPSEwO3RyeXtJKG8sZSx0LG4scil9ZmluYWxseXsoTD1pKXx8JCgpfX1mdW5jdGlvbiBYdChlLHQsbixyKXtVdChWdCxHdC5iaW5kKG51bGwsZSx0LG4scikpfWZ1bmN0aW9uIEd0KGUsdCxuLHIpe2lmKHF0KWlmKDA8Z3QubGVuZ3RoJiYtMTxDdC5pbmRleE9mKGUpKWU9VHQobnVsbCxlLHQsbixyKSxndC5wdXNoKGUpO2Vsc2V7dmFyIG89SnQoZSx0LG4scik7aWYobnVsbD09PW8pUHQoZSxyKTtlbHNlIGlmKC0xPEN0LmluZGV4T2YoZSkpZT1UdChvLGUsdCxuLHIpLGd0LnB1c2goZSk7ZWxzZSBpZighZnVuY3Rpb24oZSx0LG4scixvKXtzd2l0Y2godCl7Y2FzZSJm",
                    "b2N1cyI6cmV0dXJuIHd0PVJ0KHd0LGUsdCxuLHIsbyksITA7Y2FzZSJkcmFnZW50ZXIiOnJldHVybiB4dD1SdCh4dCxlLHQsbixyLG8pLCEwO2Nhc2UibW91c2VvdmVyIjpyZXR1cm4gRXQ9UnQoRXQsZSx0LG4scixvKSwhMDtjYXNlInBvaW50ZXJvdmVyIjp2YXIgaT1vLnBvaW50ZXJJZDtyZXR1cm4gT3Quc2V0KGksUnQoT3QuZ2V0KGkpfHxudWxsLGUsdCxuLHIsbykpLCEwO2Nhc2UiZ290cG9pbnRlcmNhcHR1cmUiOnJldHVybiBpPW8ucG9pbnRlcklkLGt0LnNldChpLFJ0KGt0LmdldChpKXx8bnVsbCxlLHQsbixyLG8pKSwhMH1yZXR1cm4hMX0obyxlLHQsbixyKSl7UHQoZSxyKSxlPWZ0KGUscixudWxsLHQpO3RyeXtXKHB0LGUpfWZpbmFsbHl7ZHQoZSl9fX19ZnVuY3Rpb24gSnQoZSx0LG4scil7aWYobnVsbCE9PShuPWpuKG49dXQocikpKSl7dmFyIG89WmUobik7aWYobnVsbD09PW8pbj1udWxsO2Vsc2V7dmFyIGk9by50YWc7aWYoMTM9PT1pKXtpZihudWxsIT09KG49ZXQobykpKXJldHVybiBuO249bnVsbH1lbHNlIGlmKDM9PT1pKXtpZihvLnN0YXRlTm9kZS5oeWRyYXRlKXJldHVybiAzPT09by50YWc/by5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO249bnVsbH1lbHNlIG8hPT1uJiYobj1udWxsKX19ZT1mdChlLHIsbix0KTt0cnl7VyhwdCxlKX1maW5hbGx5e2R0KGUpfXJldHVybiBudWxsfXZhciBadD17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVy",
                    "SW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkQXJlYTohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0sZW49WyJXZWJraXQiLCJtcyIsIk1veiIsIk8iXTtmdW5jdGlvbiB0bihlLHQsbil7cmV0dXJuIG51bGw9PXR8fCJib29sZWFuIj09PXR5cGVvZiB0fHwiIj09PXQ/IiI6bnx8Im51bWJlciIhPT10eXBlb2YgdHx8MD09PXR8fFp0Lmhhc093blByb3BlcnR5KGUpJiZadFtlXT8oIiIrdCkudHJpbSgpOnQrInB4In1mdW5j",
                    "dGlvbiBubihlLHQpe2Zvcih2YXIgbiBpbiBlPWUuc3R5bGUsdClpZih0Lmhhc093blByb3BlcnR5KG4pKXt2YXIgcj0wPT09bi5pbmRleE9mKCItLSIpLG89dG4obix0W25dLHIpOyJmbG9hdCI9PT1uJiYobj0iY3NzRmxvYXQiKSxyP2Uuc2V0UHJvcGVydHkobixvKTplW25dPW99fU9iamVjdC5rZXlzKFp0KS5mb3JFYWNoKChmdW5jdGlvbihlKXtlbi5mb3JFYWNoKChmdW5jdGlvbih0KXt0PXQrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnN1YnN0cmluZygxKSxadFt0XT1adFtlXX0pKX0pKTt2YXIgcm49byh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtmdW5jdGlvbiBvbihlLHQpe2lmKHQpe2lmKHJuW2VdJiYobnVsbCE9dC5jaGlsZHJlbnx8bnVsbCE9dC5kYW5nZXJvdXNseVNldElubmVySFRNTCkpdGhyb3cgRXJyb3IoYSgxMzcsZSwiIikpO2lmKG51bGwhPXQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpe2lmKG51bGwhPXQuY2hpbGRyZW4pdGhyb3cgRXJyb3IoYSg2MCkpO2lmKCJvYmplY3QiIT09dHlwZW9mIHQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8fCEoIl9faHRtbCJpbiB0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcihhKDYxKSl9aWYobnVsbCE9dC5zdHlsZSYmIm9iamVjdCIh",
                    "PT10eXBlb2YgdC5zdHlsZSl0aHJvdyBFcnJvcihhKDYyLCIiKSl9fWZ1bmN0aW9uIGFuKGUsdCl7aWYoLTE9PT1lLmluZGV4T2YoIi0iKSlyZXR1cm4ic3RyaW5nIj09PXR5cGVvZiB0LmlzO3N3aXRjaChlKXtjYXNlImFubm90YXRpb24teG1sIjpjYXNlImNvbG9yLXByb2ZpbGUiOmNhc2UiZm9udC1mYWNlIjpjYXNlImZvbnQtZmFjZS1zcmMiOmNhc2UiZm9udC1mYWNlLXVyaSI6Y2FzZSJmb250LWZhY2UtZm9ybWF0IjpjYXNlImZvbnQtZmFjZS1uYW1lIjpjYXNlIm1pc3NpbmctZ2x5cGgiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciBsbj1BZTtmdW5jdGlvbiB1bihlLHQpe3ZhciBuPUplKGU9OT09PWUubm9kZVR5cGV8fDExPT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudCk7dD1TW3RdO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKWh0KHRbcl0sZSxuKX1mdW5jdGlvbiBzbigpe31mdW5jdGlvbiBjbihlKXtpZigidW5kZWZpbmVkIj09PXR5cGVvZihlPWV8fCgidW5kZWZpbmVkIiE9PXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudDp2b2lkIDApKSlyZXR1cm4gbnVsbDt0cnl7cmV0dXJuIGUuYWN0aXZlRWxlbWVudHx8ZS5ib2R5fWNhdGNoKHQpe3JldHVybiBlLmJvZHl9fWZ1bmN0aW9uIGRuKGUpe2Zvcig7ZSYmZS5maXJzdENoaWxkOyllPWUuZmlyc3RDaGlsZDtyZXR1cm4gZX1mdW5jdGlvbiBmbihlLHQpe3ZhciBuLHI9ZG4oZSk7Zm9yKGU9MDtyOyl7aWYoMz09PXIubm9kZVR5cGUpe2lmKG49",
                    "ZStyLnRleHRDb250ZW50Lmxlbmd0aCxlPD10JiZuPj10KXJldHVybntub2RlOnIsb2Zmc2V0OnQtZX07ZT1ufWU6e2Zvcig7cjspe2lmKHIubmV4dFNpYmxpbmcpe3I9ci5uZXh0U2libGluZzticmVhayBlfXI9ci5wYXJlbnROb2RlfXI9dm9pZCAwfXI9ZG4ocil9fWZ1bmN0aW9uIHBuKCl7Zm9yKHZhciBlPXdpbmRvdyx0PWNuKCk7dCBpbnN0YW5jZW9mIGUuSFRNTElGcmFtZUVsZW1lbnQ7KXt0cnl7dmFyIG49InN0cmluZyI9PT10eXBlb2YgdC5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2gocil7bj0hMX1pZighbilicmVhazt0PWNuKChlPXQuY29udGVudFdpbmRvdykuZG9jdW1lbnQpfXJldHVybiB0fWZ1bmN0aW9uIGhuKGUpe3ZhciB0PWUmJmUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gdCYmKCJpbnB1dCI9PT10JiYoInRleHQiPT09ZS50eXBlfHwic2VhcmNoIj09PWUudHlwZXx8InRlbCI9PT1lLnR5cGV8fCJ1cmwiPT09ZS50eXBlfHwicGFzc3dvcmQiPT09ZS50eXBlKXx8InRleHRhcmVhIj09PXR8fCJ0cnVlIj09PWUuY29udGVudEVkaXRhYmxlKX12YXIgbW49bnVsbCx2bj1udWxsO2Z1bmN0aW9uIGJuKGUsdCl7c3dpdGNoKGUpe2Nhc2UiYnV0dG9uIjpjYXNlImlucHV0IjpjYXNlInNlbGVjdCI6Y2FzZSJ0ZXh0YXJlYSI6cmV0dXJuISF0LmF1dG9Gb2N1c31yZXR1cm4hMX1mdW5jdGlvbiB5bihlLHQpe3JldHVybiJ0ZXh0YXJlYSI9PT1lfHwib3B0aW9uIj09",
                    "PWV8fCJub3NjcmlwdCI9PT1lfHwic3RyaW5nIj09PXR5cGVvZiB0LmNoaWxkcmVufHwibnVtYmVyIj09PXR5cGVvZiB0LmNoaWxkcmVufHwib2JqZWN0Ij09PXR5cGVvZiB0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09dC5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9dC5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9dmFyIGduPSJmdW5jdGlvbiI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCx3bj0iZnVuY3Rpb24iPT09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6dm9pZCAwO2Z1bmN0aW9uIHhuKGUpe2Zvcig7bnVsbCE9ZTtlPWUubmV4dFNpYmxpbmcpe3ZhciB0PWUubm9kZVR5cGU7aWYoMT09PXR8fDM9PT10KWJyZWFrfXJldHVybiBlfWZ1bmN0aW9uIEVuKGUpe2U9ZS5wcmV2aW91c1NpYmxpbmc7Zm9yKHZhciB0PTA7ZTspe2lmKDg9PT1lLm5vZGVUeXBlKXt2YXIgbj1lLmRhdGE7aWYoIiQiPT09bnx8IiQhIj09PW58fCIkPyI9PT1uKXtpZigwPT09dClyZXR1cm4gZTt0LS19ZWxzZSIvJCI9PT1uJiZ0Kyt9ZT1lLnByZXZpb3VzU2libGluZ31yZXR1cm4gbnVsbH12YXIgT249TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksa249Il9fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCIrT24sU249Il9fcmVhY3RFdmVudEhhbmRsZXJzJCIrT24sQ249Il9fcmVhY3RDb250YWluZXJlJCIrT247ZnVuY3Rpb24gam4oZSl7dmFyIHQ9ZVtrbl07",
                    "aWYodClyZXR1cm4gdDtmb3IodmFyIG49ZS5wYXJlbnROb2RlO247KXtpZih0PW5bQ25dfHxuW2tuXSl7aWYobj10LmFsdGVybmF0ZSxudWxsIT09dC5jaGlsZHx8bnVsbCE9PW4mJm51bGwhPT1uLmNoaWxkKWZvcihlPUVuKGUpO251bGwhPT1lOyl7aWYobj1lW2tuXSlyZXR1cm4gbjtlPUVuKGUpfXJldHVybiB0fW49KGU9bikucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBUbihlKXtyZXR1cm4hKGU9ZVtrbl18fGVbQ25dKXx8NSE9PWUudGFnJiY2IT09ZS50YWcmJjEzIT09ZS50YWcmJjMhPT1lLnRhZz9udWxsOmV9ZnVuY3Rpb24gUG4oZSl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpcmV0dXJuIGUuc3RhdGVOb2RlO3Rocm93IEVycm9yKGEoMzMpKX1mdW5jdGlvbiBSbihlKXtyZXR1cm4gZVtTbl18fG51bGx9ZnVuY3Rpb24gTm4oZSl7ZG97ZT1lLnJldHVybn13aGlsZShlJiY1IT09ZS50YWcpO3JldHVybiBlfHxudWxsfWZ1bmN0aW9uIE1uKGUsdCl7dmFyIG49ZS5zdGF0ZU5vZGU7aWYoIW4pcmV0dXJuIG51bGw7dmFyIHI9aChuKTtpZighcilyZXR1cm4gbnVsbDtuPXJbdF07ZTpzd2l0Y2godCl7Y2FzZSJvbkNsaWNrIjpjYXNlIm9uQ2xpY2tDYXB0dXJlIjpjYXNlIm9uRG91YmxlQ2xpY2siOmNhc2Uib25Eb3VibGVDbGlja0NhcHR1cmUiOmNhc2Uib25Nb3VzZURvd24iOmNhc2Uib25Nb3VzZURvd25DYXB0dXJlIjpjYXNlIm9uTW91c2VNb3ZlIjpjYXNlIm9uTW91c2VNb3ZlQ2FwdHVyZSI6Y2FzZSJv",
                    "bk1vdXNlVXAiOmNhc2Uib25Nb3VzZVVwQ2FwdHVyZSI6Y2FzZSJvbk1vdXNlRW50ZXIiOihyPSFyLmRpc2FibGVkKXx8KHI9ISgiYnV0dG9uIj09PShlPWUudHlwZSl8fCJpbnB1dCI9PT1lfHwic2VsZWN0Ij09PWV8fCJ0ZXh0YXJlYSI9PT1lKSksZT0hcjticmVhayBlO2RlZmF1bHQ6ZT0hMX1pZihlKXJldHVybiBudWxsO2lmKG4mJiJmdW5jdGlvbiIhPT10eXBlb2Ygbil0aHJvdyBFcnJvcihhKDIzMSx0LHR5cGVvZiBuKSk7cmV0dXJuIG59ZnVuY3Rpb24gX24oZSx0LG4peyh0PU1uKGUsbi5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1t0XSkpJiYobi5fZGlzcGF0Y2hMaXN0ZW5lcnM9cnQobi5fZGlzcGF0Y2hMaXN0ZW5lcnMsdCksbi5fZGlzcGF0Y2hJbnN0YW5jZXM9cnQobi5fZGlzcGF0Y2hJbnN0YW5jZXMsZSkpfWZ1bmN0aW9uIEFuKGUpe2lmKGUmJmUuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe2Zvcih2YXIgdD1lLl90YXJnZXRJbnN0LG49W107dDspbi5wdXNoKHQpLHQ9Tm4odCk7Zm9yKHQ9bi5sZW5ndGg7MDx0LS07KV9uKG5bdF0sImNhcHR1cmVkIixlKTtmb3IodD0wO3Q8bi5sZW5ndGg7dCsrKV9uKG5bdF0sImJ1YmJsZWQiLGUpfX1mdW5jdGlvbiBJbihlLHQsbil7ZSYmbiYmbi5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYodD1NbihlLG4uZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYobi5fZGlzcGF0Y2hMaXN0ZW5l",
                    "cnM9cnQobi5fZGlzcGF0Y2hMaXN0ZW5lcnMsdCksbi5fZGlzcGF0Y2hJbnN0YW5jZXM9cnQobi5fZGlzcGF0Y2hJbnN0YW5jZXMsZSkpfWZ1bmN0aW9uIERuKGUpe2UmJmUuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmSW4oZS5fdGFyZ2V0SW5zdCxudWxsLGUpfWZ1bmN0aW9uIHpuKGUpe290KGUsQW4pfXZhciBMbj1udWxsLEZuPW51bGwsJG49bnVsbDtmdW5jdGlvbiBXbigpe2lmKCRuKXJldHVybiAkbjt2YXIgZSx0LG49Rm4scj1uLmxlbmd0aCxvPSJ2YWx1ZSJpbiBMbj9Mbi52YWx1ZTpMbi50ZXh0Q29udGVudCxpPW8ubGVuZ3RoO2ZvcihlPTA7ZTxyJiZuW2VdPT09b1tlXTtlKyspO3ZhciBhPXItZTtmb3IodD0xO3Q8PWEmJm5bci10XT09PW9baS10XTt0KyspO3JldHVybiAkbj1vLnNsaWNlKGUsMTx0PzEtdDp2b2lkIDApfWZ1bmN0aW9uIEJuKCl7cmV0dXJuITB9ZnVuY3Rpb24gSG4oKXtyZXR1cm4hMX1mdW5jdGlvbiBWbihlLHQsbixyKXtmb3IodmFyIG8gaW4gdGhpcy5kaXNwYXRjaENvbmZpZz1lLHRoaXMuX3RhcmdldEluc3Q9dCx0aGlzLm5hdGl2ZUV2ZW50PW4sZT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSllLmhhc093blByb3BlcnR5KG8pJiYoKHQ9ZVtvXSk/dGhpc1tvXT10KG4pOiJ0YXJnZXQiPT09bz90aGlzLnRhcmdldD1yOnRoaXNbb109bltvXSk7cmV0dXJuIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1uLmRlZmF1bHRQcmV2ZW50ZWQ/bi5kZWZhdWx0UHJldmVu",
                    "dGVkOiExPT09bi5yZXR1cm5WYWx1ZSk/Qm46SG4sdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1Ibix0aGlzfWZ1bmN0aW9uIFVuKGUsdCxuLHIpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIG89dGhpcy5ldmVudFBvb2wucG9wKCk7cmV0dXJuIHRoaXMuY2FsbChvLGUsdCxuLHIpLG99cmV0dXJuIG5ldyB0aGlzKGUsdCxuLHIpfWZ1bmN0aW9uIHFuKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHRoaXMpKXRocm93IEVycm9yKGEoMjc5KSk7ZS5kZXN0cnVjdG9yKCksMTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGUpfWZ1bmN0aW9uIEtuKGUpe2UuZXZlbnRQb29sPVtdLGUuZ2V0UG9vbGVkPVVuLGUucmVsZWFzZT1xbn1vKFZuLnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGU9dGhpcy5uYXRpdmVFdmVudDtlJiYoZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6InVua25vd24iIT09dHlwZW9mIGUucmV0dXJuVmFsdWUmJihlLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1Cbil9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMubmF0aXZlRXZlbnQ7ZSYmKGUuc3RvcFByb3BhZ2F0aW9uP2Uuc3RvcFByb3BhZ2F0aW9uKCk6InVua25vd24iIT09dHlwZW9mIGUuY2FuY2VsQnViYmxlJiYoZS5jYW5jZWxCdWJibGU9ITApLHRoaXMuaXNQcm9wYWdhdGlv",
                    "blN0b3BwZWQ9Qm4pfSxwZXJzaXN0OmZ1bmN0aW9uKCl7dGhpcy5pc1BlcnNpc3RlbnQ9Qm59LGlzUGVyc2lzdGVudDpIbixkZXN0cnVjdG9yOmZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IoZSBpbiB0KXRoaXNbZV09bnVsbDt0aGlzLm5hdGl2ZUV2ZW50PXRoaXMuX3RhcmdldEluc3Q9dGhpcy5kaXNwYXRjaENvbmZpZz1udWxsLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9SG4sdGhpcy5fZGlzcGF0Y2hJbnN0YW5jZXM9dGhpcy5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbH19KSxWbi5JbnRlcmZhY2U9e3R5cGU6bnVsbCx0YXJnZXQ6bnVsbCxjdXJyZW50VGFyZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGV2ZW50UGhhc2U6bnVsbCxidWJibGVzOm51bGwsY2FuY2VsYWJsZTpudWxsLHRpbWVTdGFtcDpmdW5jdGlvbihlKXtyZXR1cm4gZS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6bnVsbCxpc1RydXN0ZWQ6bnVsbH0sVm4uZXh0ZW5kPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt9ZnVuY3Rpb24gbigpe3JldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgcj10aGlzO3QucHJvdG90eXBlPXIucHJvdG90eXBlO3ZhciBpPW5ldyB0O3JldHVybiBvKGksbi5wcm90b3R5cGUpLG4ucHJvdG90eXBlPWksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bixuLkludGVyZmFjZT1vKHt9LHIuSW50ZXJmYWNl",
                    "LGUpLG4uZXh0ZW5kPXIuZXh0ZW5kLEtuKG4pLG59LEtuKFZuKTt2YXIgWW49Vm4uZXh0ZW5kKHtkYXRhOm51bGx9KSxRbj1Wbi5leHRlbmQoe2RhdGE6bnVsbH0pLFhuPVs5LDEzLDI3LDMyXSxHbj1qJiYiQ29tcG9zaXRpb25FdmVudCJpbiB3aW5kb3csSm49bnVsbDtqJiYiZG9jdW1lbnRNb2RlImluIGRvY3VtZW50JiYoSm49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgWm49aiYmIlRleHRFdmVudCJpbiB3aW5kb3cmJiFKbixlcj1qJiYoIUdufHxKbiYmODxKbiYmMTE+PUpuKSx0cj1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxucj17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOiJvbkJlZm9yZUlucHV0IixjYXB0dXJlZDoib25CZWZvcmVJbnB1dENhcHR1cmUifSxkZXBlbmRlbmNpZXM6WyJjb21wb3NpdGlvbmVuZCIsImtleXByZXNzIiwidGV4dElucHV0IiwicGFzdGUiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOiJvbkNvbXBvc2l0aW9uRW5kIixjYXB0dXJlZDoib25Db21wb3NpdGlvbkVuZENhcHR1cmUifSxkZXBlbmRlbmNpZXM6ImJsdXIgY29tcG9zaXRpb25lbmQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOiJvbkNvbXBvc2l0aW9uU3RhcnQiLGNhcHR1cmVkOiJvbkNvbXBvc2l0aW9uU3RhcnRD",
                    "YXB0dXJlIn0sZGVwZW5kZW5jaWVzOiJibHVyIGNvbXBvc2l0aW9uc3RhcnQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDoib25Db21wb3NpdGlvblVwZGF0ZSIsY2FwdHVyZWQ6Im9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlIn0sZGVwZW5kZW5jaWVzOiJibHVyIGNvbXBvc2l0aW9udXBkYXRlIGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duIi5zcGxpdCgiICIpfX0scnI9ITE7ZnVuY3Rpb24gb3IoZSx0KXtzd2l0Y2goZSl7Y2FzZSJrZXl1cCI6cmV0dXJuLTEhPT1Ybi5pbmRleE9mKHQua2V5Q29kZSk7Y2FzZSJrZXlkb3duIjpyZXR1cm4gMjI5IT09dC5rZXlDb2RlO2Nhc2Uia2V5cHJlc3MiOmNhc2UibW91c2Vkb3duIjpjYXNlImJsdXIiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGlyKGUpe3JldHVybiJvYmplY3QiPT09dHlwZW9mKGU9ZS5kZXRhaWwpJiYiZGF0YSJpbiBlP2UuZGF0YTpudWxsfXZhciBhcj0hMTt2YXIgbHI9e2V2ZW50VHlwZXM6bnIsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihlLHQsbixyKXt2YXIgbztpZihHbillOntzd2l0Y2goZSl7Y2FzZSJjb21wb3NpdGlvbnN0YXJ0Ijp2YXIgaT1uci5jb21wb3NpdGlvblN0YXJ0O2JyZWFrIGU7Y2FzZSJjb21wb3NpdGlvbmVuZCI6aT1uci5jb21wb3NpdGlvbkVuZDticmVhayBlO2Nhc2UiY29t",
                    "cG9zaXRpb251cGRhdGUiOmk9bnIuY29tcG9zaXRpb25VcGRhdGU7YnJlYWsgZX1pPXZvaWQgMH1lbHNlIGFyP29yKGUsbikmJihpPW5yLmNvbXBvc2l0aW9uRW5kKToia2V5ZG93biI9PT1lJiYyMjk9PT1uLmtleUNvZGUmJihpPW5yLmNvbXBvc2l0aW9uU3RhcnQpO3JldHVybiBpPyhlciYmImtvIiE9PW4ubG9jYWxlJiYoYXJ8fGkhPT1uci5jb21wb3NpdGlvblN0YXJ0P2k9PT1uci5jb21wb3NpdGlvbkVuZCYmYXImJihvPVduKCkpOihGbj0idmFsdWUiaW4oTG49cik/TG4udmFsdWU6TG4udGV4dENvbnRlbnQsYXI9ITApKSxpPVluLmdldFBvb2xlZChpLHQsbixyKSxvP2kuZGF0YT1vOm51bGwhPT0obz1pcihuKSkmJihpLmRhdGE9byksem4oaSksbz1pKTpvPW51bGwsKGU9Wm4/ZnVuY3Rpb24oZSx0KXtzd2l0Y2goZSl7Y2FzZSJjb21wb3NpdGlvbmVuZCI6cmV0dXJuIGlyKHQpO2Nhc2Uia2V5cHJlc3MiOnJldHVybiAzMiE9PXQud2hpY2g/bnVsbDoocnI9ITAsdHIpO2Nhc2UidGV4dElucHV0IjpyZXR1cm4oZT10LmRhdGEpPT09dHImJnJyP251bGw6ZTtkZWZhdWx0OnJldHVybiBudWxsfX0oZSxuKTpmdW5jdGlvbihlLHQpe2lmKGFyKXJldHVybiJjb21wb3NpdGlvbmVuZCI9PT1lfHwhR24mJm9yKGUsdCk/KGU9V24oKSwkbj1Gbj1Mbj1udWxsLGFyPSExLGUpOm51bGw7c3dpdGNoKGUpe2Nhc2UicGFzdGUiOnJldHVybiBudWxsO2Nhc2Uia2V5cHJlc3MiOmlmKCEodC5jdHJsS2V5fHx0LmFsdEtleXx8dC5tZXRh",
                    "S2V5KXx8dC5jdHJsS2V5JiZ0LmFsdEtleSl7aWYodC5jaGFyJiYxPHQuY2hhci5sZW5ndGgpcmV0dXJuIHQuY2hhcjtpZih0LndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHQud2hpY2gpfXJldHVybiBudWxsO2Nhc2UiY29tcG9zaXRpb25lbmQiOnJldHVybiBlciYmImtvIiE9PXQubG9jYWxlP251bGw6dC5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fShlLG4pKT8oKHQ9UW4uZ2V0UG9vbGVkKG5yLmJlZm9yZUlucHV0LHQsbixyKSkuZGF0YT1lLHpuKHQpKTp0PW51bGwsbnVsbD09PW8/dDpudWxsPT09dD9vOltvLHRdfX0sdXI9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsImRhdGV0aW1lLWxvY2FsIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIHNyKGUpe3ZhciB0PWUmJmUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4iaW5wdXQiPT09dD8hIXVyW2UudHlwZV06InRleHRhcmVhIj09PXR9dmFyIGNyPXtjaGFuZ2U6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOiJvbkNoYW5nZSIsY2FwdHVyZWQ6Im9uQ2hhbmdlQ2FwdHVyZSJ9LGRlcGVuZGVuY2llczoiYmx1ciBjaGFuZ2UgY2xpY2sgZm9jdXMgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2UiLnNwbGl0KCIgIil9fTtmdW5jdGlvbiBk",
                    "cihlLHQsbil7cmV0dXJuKGU9Vm4uZ2V0UG9vbGVkKGNyLmNoYW5nZSxlLHQsbikpLnR5cGU9ImNoYW5nZSIsTShuKSx6bihlKSxlfXZhciBmcj1udWxsLHByPW51bGw7ZnVuY3Rpb24gaHIoZSl7bHQoZSl9ZnVuY3Rpb24gbXIoZSl7aWYoeGUoUG4oZSkpKXJldHVybiBlfWZ1bmN0aW9uIHZyKGUsdCl7aWYoImNoYW5nZSI9PT1lKXJldHVybiB0fXZhciBicj0hMTtmdW5jdGlvbiB5cigpe2ZyJiYoZnIuZGV0YWNoRXZlbnQoIm9ucHJvcGVydHljaGFuZ2UiLGdyKSxwcj1mcj1udWxsKX1mdW5jdGlvbiBncihlKXtpZigidmFsdWUiPT09ZS5wcm9wZXJ0eU5hbWUmJm1yKHByKSlpZihlPWRyKHByLGUsdXQoZSkpLEwpbHQoZSk7ZWxzZXtMPSEwO3RyeXtBKGhyLGUpfWZpbmFsbHl7TD0hMSwkKCl9fX1mdW5jdGlvbiB3cihlLHQsbil7ImZvY3VzIj09PWU/KHlyKCkscHI9biwoZnI9dCkuYXR0YWNoRXZlbnQoIm9ucHJvcGVydHljaGFuZ2UiLGdyKSk6ImJsdXIiPT09ZSYmeXIoKX1mdW5jdGlvbiB4cihlKXtpZigic2VsZWN0aW9uY2hhbmdlIj09PWV8fCJrZXl1cCI9PT1lfHwia2V5ZG93biI9PT1lKXJldHVybiBtcihwcil9ZnVuY3Rpb24gRXIoZSx0KXtpZigiY2xpY2siPT09ZSlyZXR1cm4gbXIodCl9ZnVuY3Rpb24gT3IoZSx0KXtpZigiaW5wdXQiPT09ZXx8ImNoYW5nZSI9PT1lKXJldHVybiBtcih0KX1qJiYoYnI9c3QoImlucHV0IikmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9k",
                    "ZSkpO3ZhciBrcj17ZXZlbnRUeXBlczpjcixfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOmJyLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89dD9Qbih0KTp3aW5kb3csaT1vLm5vZGVOYW1lJiZvLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoInNlbGVjdCI9PT1pfHwiaW5wdXQiPT09aSYmImZpbGUiPT09by50eXBlKXZhciBhPXZyO2Vsc2UgaWYoc3IobykpaWYoYnIpYT1PcjtlbHNle2E9eHI7dmFyIGw9d3J9ZWxzZShpPW8ubm9kZU5hbWUpJiYiaW5wdXQiPT09aS50b0xvd2VyQ2FzZSgpJiYoImNoZWNrYm94Ij09PW8udHlwZXx8InJhZGlvIj09PW8udHlwZSkmJihhPUVyKTtpZihhJiYoYT1hKGUsdCkpKXJldHVybiBkcihhLG4scik7bCYmbChlLG8sdCksImJsdXIiPT09ZSYmKGU9by5fd3JhcHBlclN0YXRlKSYmZS5jb250cm9sbGVkJiYibnVtYmVyIj09PW8udHlwZSYmamUobywibnVtYmVyIixvLnZhbHVlKX19LFNyPVZuLmV4dGVuZCh7dmlldzpudWxsLGRldGFpbDpudWxsfSksQ3I9e0FsdDoiYWx0S2V5IixDb250cm9sOiJjdHJsS2V5IixNZXRhOiJtZXRhS2V5IixTaGlmdDoic2hpZnRLZXkifTtmdW5jdGlvbiBqcihlKXt2YXIgdD10aGlzLm5hdGl2ZUV2ZW50O3JldHVybiB0LmdldE1vZGlmaWVyU3RhdGU/dC5nZXRNb2RpZmllclN0YXRlKGUpOiEhKGU9Q3JbZV0pJiYhIXRbZV19ZnVuY3Rpb24gVHIoKXtyZXR1cm4ganJ9dmFyIFByPTAsUnI9MCxOcj0hMSxNcj0hMSxfcj1Tci5leHRlbmQo",
                    "e3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6VHIsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVsYXRlZFRhcmdldHx8KGUuZnJvbUVsZW1lbnQ9PT1lLnNyY0VsZW1lbnQ/ZS50b0VsZW1lbnQ6ZS5mcm9tRWxlbWVudCl9LG1vdmVtZW50WDpmdW5jdGlvbihlKXtpZigibW92ZW1lbnRYImluIGUpcmV0dXJuIGUubW92ZW1lbnRYO3ZhciB0PVByO3JldHVybiBQcj1lLnNjcmVlblgsTnI/Im1vdXNlbW92ZSI9PT1lLnR5cGU/ZS5zY3JlZW5YLXQ6MDooTnI9ITAsMCl9LG1vdmVtZW50WTpmdW5jdGlvbihlKXtpZigibW92ZW1lbnRZImluIGUpcmV0dXJuIGUubW92ZW1lbnRZO3ZhciB0PVJyO3JldHVybiBScj1lLnNjcmVlblksTXI/Im1vdXNlbW92ZSI9PT1lLnR5cGU/ZS5zY3JlZW5ZLXQ6MDooTXI9ITAsMCl9fSksQXI9X3IuZXh0ZW5kKHtwb2ludGVySWQ6bnVsbCx3aWR0aDpudWxsLGhlaWdodDpudWxsLHByZXNzdXJlOm51bGwsdGFuZ2VudGlhbFByZXNzdXJlOm51bGwsdGlsdFg6bnVsbCx0aWx0WTpudWxsLHR3aXN0Om51bGwscG9pbnRlclR5cGU6bnVsbCxpc1ByaW1hcnk6bnVsbH0pLElyPXttb3VzZUVudGVyOntyZWdpc3RyYXRpb25OYW1lOiJv",
                    "bk1vdXNlRW50ZXIiLGRlcGVuZGVuY2llczpbIm1vdXNlb3V0IiwibW91c2VvdmVyIl19LG1vdXNlTGVhdmU6e3JlZ2lzdHJhdGlvbk5hbWU6Im9uTW91c2VMZWF2ZSIsZGVwZW5kZW5jaWVzOlsibW91c2VvdXQiLCJtb3VzZW92ZXIiXX0scG9pbnRlckVudGVyOntyZWdpc3RyYXRpb25OYW1lOiJvblBvaW50ZXJFbnRlciIsZGVwZW5kZW5jaWVzOlsicG9pbnRlcm91dCIsInBvaW50ZXJvdmVyIl19LHBvaW50ZXJMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZToib25Qb2ludGVyTGVhdmUiLGRlcGVuZGVuY2llczpbInBvaW50ZXJvdXQiLCJwb2ludGVyb3ZlciJdfX0sRHI9e2V2ZW50VHlwZXM6SXIsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihlLHQsbixyLG8pe3ZhciBpPSJtb3VzZW92ZXIiPT09ZXx8InBvaW50ZXJvdmVyIj09PWUsYT0ibW91c2VvdXQiPT09ZXx8InBvaW50ZXJvdXQiPT09ZTtpZihpJiYwPT09KDMyJm8pJiYobi5yZWxhdGVkVGFyZ2V0fHxuLmZyb21FbGVtZW50KXx8IWEmJiFpKXJldHVybiBudWxsOyhpPXIud2luZG93PT09cj9yOihpPXIub3duZXJEb2N1bWVudCk/aS5kZWZhdWx0Vmlld3x8aS5wYXJlbnRXaW5kb3c6d2luZG93LGEpPyhhPXQsbnVsbCE9PSh0PSh0PW4ucmVsYXRlZFRhcmdldHx8bi50b0VsZW1lbnQpP2puKHQpOm51bGwpJiYodCE9PVplKHQpfHw1IT09dC50YWcmJjYhPT10LnRhZykmJih0PW51bGwpKTphPW51bGw7aWYoYT09PXQpcmV0dXJuIG51bGw7aWYoIm1vdXNlb3V0Ij09PWV8fCJt",
                    "b3VzZW92ZXIiPT09ZSl2YXIgbD1fcix1PUlyLm1vdXNlTGVhdmUscz1Jci5tb3VzZUVudGVyLGM9Im1vdXNlIjtlbHNlInBvaW50ZXJvdXQiIT09ZSYmInBvaW50ZXJvdmVyIiE9PWV8fChsPUFyLHU9SXIucG9pbnRlckxlYXZlLHM9SXIucG9pbnRlckVudGVyLGM9InBvaW50ZXIiKTtpZihlPW51bGw9PWE/aTpQbihhKSxpPW51bGw9PXQ/aTpQbih0KSwodT1sLmdldFBvb2xlZCh1LGEsbixyKSkudHlwZT1jKyJsZWF2ZSIsdS50YXJnZXQ9ZSx1LnJlbGF0ZWRUYXJnZXQ9aSwobj1sLmdldFBvb2xlZChzLHQsbixyKSkudHlwZT1jKyJlbnRlciIsbi50YXJnZXQ9aSxuLnJlbGF0ZWRUYXJnZXQ9ZSxjPXQsKHI9YSkmJmMpZTp7Zm9yKHM9YyxhPTAsZT1sPXI7ZTtlPU5uKGUpKWErKztmb3IoZT0wLHQ9czt0O3Q9Tm4odCkpZSsrO2Zvcig7MDxhLWU7KWw9Tm4obCksYS0tO2Zvcig7MDxlLWE7KXM9Tm4ocyksZS0tO2Zvcig7YS0tOyl7aWYobD09PXN8fGw9PT1zLmFsdGVybmF0ZSlicmVhayBlO2w9Tm4obCkscz1ObihzKX1sPW51bGx9ZWxzZSBsPW51bGw7Zm9yKHM9bCxsPVtdO3ImJnIhPT1zJiYobnVsbD09PShhPXIuYWx0ZXJuYXRlKXx8YSE9PXMpOylsLnB1c2gocikscj1ObihyKTtmb3Iocj1bXTtjJiZjIT09cyYmKG51bGw9PT0oYT1jLmFsdGVybmF0ZSl8fGEhPT1zKTspci5wdXNoKGMpLGM9Tm4oYyk7Zm9yKGM9MDtjPGwubGVuZ3RoO2MrKylJbihsW2NdLCJidWJibGVkIix1KTtmb3IoYz1yLmxlbmd0aDswPGMtLTsp",
                    "SW4ocltjXSwiY2FwdHVyZWQiLG4pO3JldHVybiAwPT09KDY0Jm8pP1t1XTpbdSxuXX19O3ZhciB6cj0iZnVuY3Rpb24iPT09dHlwZW9mIE9iamVjdC5pcz9PYmplY3QuaXM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PXQmJigwIT09ZXx8MS9lPT09MS90KXx8ZSE9PWUmJnQhPT10fSxMcj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEZyKGUsdCl7aWYoenIoZSx0KSlyZXR1cm4hMDtpZigib2JqZWN0IiE9PXR5cGVvZiBlfHxudWxsPT09ZXx8Im9iamVjdCIhPT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuITE7dmFyIG49T2JqZWN0LmtleXMoZSkscj1PYmplY3Qua2V5cyh0KTtpZihuLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2ZvcihyPTA7cjxuLmxlbmd0aDtyKyspaWYoIUxyLmNhbGwodCxuW3JdKXx8IXpyKGVbbltyXV0sdFtuW3JdXSkpcmV0dXJuITE7cmV0dXJuITB9dmFyICRyPWomJiJkb2N1bWVudE1vZGUiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsV3I9e3NlbGVjdDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6Im9uU2VsZWN0IixjYXB0dXJlZDoib25TZWxlY3RDYXB0dXJlIn0sZGVwZW5kZW5jaWVzOiJibHVyIGNvbnRleHRtZW51IGRyYWdlbmQgZm9jdXMga2V5ZG93biBrZXl1cCBtb3VzZWRvd24gbW91c2V1cCBzZWxlY3Rpb25jaGFuZ2UiLnNwbGl0KCIgIil9fSxCcj1udWxsLEhyPW51bGwsVnI9bnVsbCxVcj0hMTtmdW5jdGlv",
                    "biBxcihlLHQpe3ZhciBuPXQud2luZG93PT09dD90LmRvY3VtZW50Ojk9PT10Lm5vZGVUeXBlP3Q6dC5vd25lckRvY3VtZW50O3JldHVybiBVcnx8bnVsbD09QnJ8fEJyIT09Y24obik/bnVsbDooInNlbGVjdGlvblN0YXJ0ImluKG49QnIpJiZobihuKT9uPXtzdGFydDpuLnNlbGVjdGlvblN0YXJ0LGVuZDpuLnNlbGVjdGlvbkVuZH06bj17YW5jaG9yTm9kZToobj0obi5vd25lckRvY3VtZW50JiZuLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkpLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0Om4uYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpuLmZvY3VzTm9kZSxmb2N1c09mZnNldDpuLmZvY3VzT2Zmc2V0fSxWciYmRnIoVnIsbik/bnVsbDooVnI9biwoZT1Wbi5nZXRQb29sZWQoV3Iuc2VsZWN0LEhyLGUsdCkpLnR5cGU9InNlbGVjdCIsZS50YXJnZXQ9QnIsem4oZSksZSkpfXZhciBLcj17ZXZlbnRUeXBlczpXcixleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGUsdCxuLHIsbyxpKXtpZighKGk9IShvPWl8fChyLndpbmRvdz09PXI/ci5kb2N1bWVudDo5PT09ci5ub2RlVHlwZT9yOnIub3duZXJEb2N1bWVudCkpKSl7ZTp7bz1KZShvKSxpPVMub25TZWxlY3Q7Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspaWYoIW8uaGFzKGlbYV0pKXtvPSExO2JyZWFrIGV9bz0hMH1pPSFvfWlmKGkpcmV0dXJuIG51bGw7c3dpdGNoKG89dD9Qbih0KTp3aW5kb3csZSl7Y2FzZSJmb2N1cyI6KHNyKG8pfHwi",
                    "dHJ1ZSI9PT1vLmNvbnRlbnRFZGl0YWJsZSkmJihCcj1vLEhyPXQsVnI9bnVsbCk7YnJlYWs7Y2FzZSJibHVyIjpWcj1Icj1Ccj1udWxsO2JyZWFrO2Nhc2UibW91c2Vkb3duIjpVcj0hMDticmVhaztjYXNlImNvbnRleHRtZW51IjpjYXNlIm1vdXNldXAiOmNhc2UiZHJhZ2VuZCI6cmV0dXJuIFVyPSExLHFyKG4scik7Y2FzZSJzZWxlY3Rpb25jaGFuZ2UiOmlmKCRyKWJyZWFrO2Nhc2Uia2V5ZG93biI6Y2FzZSJrZXl1cCI6cmV0dXJuIHFyKG4scil9cmV0dXJuIG51bGx9fSxZcj1Wbi5leHRlbmQoe2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pLFFyPVZuLmV4dGVuZCh7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4iY2xpcGJvYXJkRGF0YSJpbiBlP2UuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxYcj1Tci5leHRlbmQoe3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO2Z1bmN0aW9uIEdyKGUpe3ZhciB0PWUua2V5Q29kZTtyZXR1cm4iY2hhckNvZGUiaW4gZT8wPT09KGU9ZS5jaGFyQ29kZSkmJjEzPT09dCYmKGU9MTMpOmU9dCwxMD09PWUmJihlPTEzKSwzMjw9ZXx8MTM9PT1lP2U6MH12YXIgSnI9e0VzYzoiRXNjYXBlIixTcGFjZWJhcjoiICIsTGVmdDoiQXJyb3dMZWZ0IixVcDoiQXJyb3dVcCIsUmlnaHQ6IkFycm93UmlnaHQiLERvd246IkFycm93RG93biIsRGVsOiJEZWxldGUiLFdpbjoiT1MiLE1lbnU6IkNvbnRleHRNZW51IixBcHBz",
                    "OiJDb250ZXh0TWVudSIsU2Nyb2xsOiJTY3JvbGxMb2NrIixNb3pQcmludGFibGVLZXk6IlVuaWRlbnRpZmllZCJ9LFpyPXs4OiJCYWNrc3BhY2UiLDk6IlRhYiIsMTI6IkNsZWFyIiwxMzoiRW50ZXIiLDE2OiJTaGlmdCIsMTc6IkNvbnRyb2wiLDE4OiJBbHQiLDE5OiJQYXVzZSIsMjA6IkNhcHNMb2NrIiwyNzoiRXNjYXBlIiwzMjoiICIsMzM6IlBhZ2VVcCIsMzQ6IlBhZ2VEb3duIiwzNToiRW5kIiwzNjoiSG9tZSIsMzc6IkFycm93TGVmdCIsMzg6IkFycm93VXAiLDM5OiJBcnJvd1JpZ2h0Iiw0MDoiQXJyb3dEb3duIiw0NToiSW5zZXJ0Iiw0NjoiRGVsZXRlIiwxMTI6IkYxIiwxMTM6IkYyIiwxMTQ6IkYzIiwxMTU6IkY0IiwxMTY6IkY1IiwxMTc6IkY2IiwxMTg6IkY3IiwxMTk6IkY4IiwxMjA6IkY5IiwxMjE6IkYxMCIsMTIyOiJGMTEiLDEyMzoiRjEyIiwxNDQ6Ik51bUxvY2siLDE0NToiU2Nyb2xsTG9jayIsMjI0OiJNZXRhIn0sZW89U3IuZXh0ZW5kKHtrZXk6ZnVuY3Rpb24oZSl7aWYoZS5rZXkpe3ZhciB0PUpyW2Uua2V5XXx8ZS5rZXk7aWYoIlVuaWRlbnRpZmllZCIhPT10KXJldHVybiB0fXJldHVybiJrZXlwcmVzcyI9PT1lLnR5cGU/MTM9PT0oZT1HcihlKSk/IkVudGVyIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGUpOiJrZXlkb3duIj09PWUudHlwZXx8ImtleXVwIj09PWUudHlwZT9acltlLmtleUNvZGVdfHwiVW5pZGVudGlmaWVkIjoiIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVs",
                    "bCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTpUcixjaGFyQ29kZTpmdW5jdGlvbihlKXtyZXR1cm4ia2V5cHJlc3MiPT09ZS50eXBlP0dyKGUpOjB9LGtleUNvZGU6ZnVuY3Rpb24oZSl7cmV0dXJuImtleWRvd24iPT09ZS50eXBlfHwia2V5dXAiPT09ZS50eXBlP2Uua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihlKXtyZXR1cm4ia2V5cHJlc3MiPT09ZS50eXBlP0dyKGUpOiJrZXlkb3duIj09PWUudHlwZXx8ImtleXVwIj09PWUudHlwZT9lLmtleUNvZGU6MH19KSx0bz1fci5leHRlbmQoe2RhdGFUcmFuc2ZlcjpudWxsfSksbm89U3IuZXh0ZW5kKHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6VHJ9KSxybz1Wbi5leHRlbmQoe3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSksb289X3IuZXh0ZW5kKHtkZWx0YVg6ZnVuY3Rpb24oZSl7cmV0dXJuImRlbHRhWCJpbiBlP2UuZGVsdGFYOiJ3aGVlbERlbHRhWCJpbiBlPy1lLndoZWVsRGVsdGFYOjB9LGRlbHRhWTpmdW5jdGlvbihlKXtyZXR1cm4iZGVsdGFZImluIGU/ZS5kZWx0YVk6IndoZWVsRGVsdGFZImluIGU/LWUud2hlZWxEZWx0YVk6IndoZWVsRGVsdGEiaW4gZT8tZS53aGVl",
                    "bERlbHRhOjB9LGRlbHRhWjpudWxsLGRlbHRhTW9kZTpudWxsfSksaW89e2V2ZW50VHlwZXM6enQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihlLHQsbixyKXt2YXIgbz1MdC5nZXQoZSk7aWYoIW8pcmV0dXJuIG51bGw7c3dpdGNoKGUpe2Nhc2Uia2V5cHJlc3MiOmlmKDA9PT1HcihuKSlyZXR1cm4gbnVsbDtjYXNlImtleWRvd24iOmNhc2Uia2V5dXAiOmU9ZW87YnJlYWs7Y2FzZSJibHVyIjpjYXNlImZvY3VzIjplPVhyO2JyZWFrO2Nhc2UiY2xpY2siOmlmKDI9PT1uLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlImF1eGNsaWNrIjpjYXNlImRibGNsaWNrIjpjYXNlIm1vdXNlZG93biI6Y2FzZSJtb3VzZW1vdmUiOmNhc2UibW91c2V1cCI6Y2FzZSJtb3VzZW91dCI6Y2FzZSJtb3VzZW92ZXIiOmNhc2UiY29udGV4dG1lbnUiOmU9X3I7YnJlYWs7Y2FzZSJkcmFnIjpjYXNlImRyYWdlbmQiOmNhc2UiZHJhZ2VudGVyIjpjYXNlImRyYWdleGl0IjpjYXNlImRyYWdsZWF2ZSI6Y2FzZSJkcmFnb3ZlciI6Y2FzZSJkcmFnc3RhcnQiOmNhc2UiZHJvcCI6ZT10bzticmVhaztjYXNlInRvdWNoY2FuY2VsIjpjYXNlInRvdWNoZW5kIjpjYXNlInRvdWNobW92ZSI6Y2FzZSJ0b3VjaHN0YXJ0IjplPW5vO2JyZWFrO2Nhc2UgcWU6Y2FzZSBLZTpjYXNlIFllOmU9WXI7YnJlYWs7Y2FzZSBRZTplPXJvO2JyZWFrO2Nhc2Uic2Nyb2xsIjplPVNyO2JyZWFrO2Nhc2Uid2hlZWwiOmU9b287YnJlYWs7Y2FzZSJjb3B5IjpjYXNlImN1dCI6Y2FzZSJw",
                    "YXN0ZSI6ZT1RcjticmVhaztjYXNlImdvdHBvaW50ZXJjYXB0dXJlIjpjYXNlImxvc3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJwb2ludGVyY2FuY2VsIjpjYXNlInBvaW50ZXJkb3duIjpjYXNlInBvaW50ZXJtb3ZlIjpjYXNlInBvaW50ZXJvdXQiOmNhc2UicG9pbnRlcm92ZXIiOmNhc2UicG9pbnRlcnVwIjplPUFyO2JyZWFrO2RlZmF1bHQ6ZT1Wbn1yZXR1cm4gem4odD1lLmdldFBvb2xlZChvLHQsbixyKSksdH19O2lmKHkpdGhyb3cgRXJyb3IoYSgxMDEpKTt5PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCJSZXNwb25kZXJFdmVudFBsdWdpbiBTaW1wbGVFdmVudFBsdWdpbiBFbnRlckxlYXZlRXZlbnRQbHVnaW4gQ2hhbmdlRXZlbnRQbHVnaW4gU2VsZWN0RXZlbnRQbHVnaW4gQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIuc3BsaXQoIiAiKSksdygpLGg9Um4sbT1Ubix2PVBuLEMoe1NpbXBsZUV2ZW50UGx1Z2luOmlvLEVudGVyTGVhdmVFdmVudFBsdWdpbjpEcixDaGFuZ2VFdmVudFBsdWdpbjprcixTZWxlY3RFdmVudFBsdWdpbjpLcixCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOmxyfSk7dmFyIGFvPVtdLGxvPS0xO2Z1bmN0aW9uIHVvKGUpezA+bG98fChlLmN1cnJlbnQ9YW9bbG9dLGFvW2xvXT1udWxsLGxvLS0pfWZ1bmN0aW9uIHNvKGUsdCl7bG8rKyxhb1tsb109ZS5jdXJyZW50LGUuY3VycmVudD10fXZhciBjbz17fSxmbz17Y3VycmVudDpjb30scG89e2N1cnJlbnQ6ITF9LGhvPWNvO2Z1bmN0aW9uIG1vKGUsdCl7",
                    "dmFyIG49ZS50eXBlLmNvbnRleHRUeXBlcztpZighbilyZXR1cm4gY287dmFyIHI9ZS5zdGF0ZU5vZGU7aWYociYmci5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09dClyZXR1cm4gci5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgbyxpPXt9O2ZvcihvIGluIG4paVtvXT10W29dO3JldHVybiByJiYoKGU9ZS5zdGF0ZU5vZGUpLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9dCxlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWkpLGl9ZnVuY3Rpb24gdm8oZSl7cmV0dXJuIG51bGwhPT0oZT1lLmNoaWxkQ29udGV4dFR5cGVzKSYmdm9pZCAwIT09ZX1mdW5jdGlvbiBibygpe3VvKHBvKSx1byhmbyl9ZnVuY3Rpb24geW8oZSx0LG4pe2lmKGZvLmN1cnJlbnQhPT1jbyl0aHJvdyBFcnJvcihhKDE2OCkpO3NvKGZvLHQpLHNvKHBvLG4pfWZ1bmN0aW9uIGdvKGUsdCxuKXt2YXIgcj1lLnN0YXRlTm9kZTtpZihlPXQuY2hpbGRDb250ZXh0VHlwZXMsImZ1bmN0aW9uIiE9PXR5cGVvZiByLmdldENoaWxkQ29udGV4dClyZXR1cm4gbjtmb3IodmFyIGkgaW4gcj1yLmdldENoaWxkQ29udGV4dCgpKWlmKCEoaSBpbiBlKSl0aHJvdyBFcnJvcihhKDEwOCx2ZSh0KXx8IlVua25vd24iLGkpKTtyZXR1cm4gbyh7fSxuLHt9LHIpfWZ1bmN0aW9uIHdvKGUpe3JldHVybiBlPShlPWUuc3RhdGVOb2RlKSYmZS5f",
                    "X3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8Y28saG89Zm8uY3VycmVudCxzbyhmbyxlKSxzbyhwbyxwby5jdXJyZW50KSwhMH1mdW5jdGlvbiB4byhlLHQsbil7dmFyIHI9ZS5zdGF0ZU5vZGU7aWYoIXIpdGhyb3cgRXJyb3IoYSgxNjkpKTtuPyhlPWdvKGUsdCxobyksci5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1lLHVvKHBvKSx1byhmbyksc28oZm8sZSkpOnVvKHBvKSxzbyhwbyxuKX12YXIgRW89aS51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksT289aS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLGtvPWkudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssU289aS51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsQ289aS51bnN0YWJsZV9ub3csam89aS51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxUbz1pLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFBvPWkudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksUm89aS51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxObz1pLnVuc3RhYmxlX0xvd1ByaW9yaXR5LE1vPWkudW5zdGFibGVfSWRsZVByaW9yaXR5LF9vPXt9LEFvPWkudW5zdGFibGVfc2hvdWxkWWllbGQsSW89dm9pZCAwIT09U28/U286ZnVuY3Rpb24oKXt9LERvPW51bGwsem89bnVsbCxMbz0hMSxGbz1DbygpLCRvPTFlND5Gbz9DbzpmdW5jdGlvbigpe3JldHVybiBDbygpLUZvfTtmdW5jdGlvbiBXbygpe3N3aXRjaChqbygpKXtjYXNlIFRvOnJl",
                    "dHVybiA5OTtjYXNlIFBvOnJldHVybiA5ODtjYXNlIFJvOnJldHVybiA5NztjYXNlIE5vOnJldHVybiA5NjtjYXNlIE1vOnJldHVybiA5NTtkZWZhdWx0OnRocm93IEVycm9yKGEoMzMyKSl9fWZ1bmN0aW9uIEJvKGUpe3N3aXRjaChlKXtjYXNlIDk5OnJldHVybiBUbztjYXNlIDk4OnJldHVybiBQbztjYXNlIDk3OnJldHVybiBSbztjYXNlIDk2OnJldHVybiBObztjYXNlIDk1OnJldHVybiBNbztkZWZhdWx0OnRocm93IEVycm9yKGEoMzMyKSl9fWZ1bmN0aW9uIEhvKGUsdCl7cmV0dXJuIGU9Qm8oZSksRW8oZSx0KX1mdW5jdGlvbiBWbyhlLHQsbil7cmV0dXJuIGU9Qm8oZSksT28oZSx0LG4pfWZ1bmN0aW9uIFVvKGUpe3JldHVybiBudWxsPT09RG8/KERvPVtlXSx6bz1PbyhUbyxLbykpOkRvLnB1c2goZSksX299ZnVuY3Rpb24gcW8oKXtpZihudWxsIT09em8pe3ZhciBlPXpvO3pvPW51bGwsa28oZSl9S28oKX1mdW5jdGlvbiBLbygpe2lmKCFMbyYmbnVsbCE9PURvKXtMbz0hMDt2YXIgZT0wO3RyeXt2YXIgdD1EbztIbyg5OSwoZnVuY3Rpb24oKXtmb3IoO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdO2Rve249bighMCl9d2hpbGUobnVsbCE9PW4pfX0pKSxEbz1udWxsfWNhdGNoKG4pe3Rocm93IG51bGwhPT1EbyYmKERvPURvLnNsaWNlKGUrMSkpLE9vKFRvLHFvKSxufWZpbmFsbHl7TG89ITF9fX1mdW5jdGlvbiBZbyhlLHQsbil7cmV0dXJuIDEwNzM3NDE4MjEtKDErKCgxMDczNzQxODIxLWUrdC8xMCkvKG4vPTEw",
                    "KXwwKSkqbn1mdW5jdGlvbiBRbyhlLHQpe2lmKGUmJmUuZGVmYXVsdFByb3BzKWZvcih2YXIgbiBpbiB0PW8oe30sdCksZT1lLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT10W25dJiYodFtuXT1lW25dKTtyZXR1cm4gdH12YXIgWG89e2N1cnJlbnQ6bnVsbH0sR289bnVsbCxKbz1udWxsLFpvPW51bGw7ZnVuY3Rpb24gZWkoKXtabz1Kbz1Hbz1udWxsfWZ1bmN0aW9uIHRpKGUpe3ZhciB0PVhvLmN1cnJlbnQ7dW8oWG8pLGUudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPXR9ZnVuY3Rpb24gbmkoZSx0KXtmb3IoO251bGwhPT1lOyl7dmFyIG49ZS5hbHRlcm5hdGU7aWYoZS5jaGlsZEV4cGlyYXRpb25UaW1lPHQpZS5jaGlsZEV4cGlyYXRpb25UaW1lPXQsbnVsbCE9PW4mJm4uY2hpbGRFeHBpcmF0aW9uVGltZTx0JiYobi5jaGlsZEV4cGlyYXRpb25UaW1lPXQpO2Vsc2V7aWYoIShudWxsIT09biYmbi5jaGlsZEV4cGlyYXRpb25UaW1lPHQpKWJyZWFrO24uY2hpbGRFeHBpcmF0aW9uVGltZT10fWU9ZS5yZXR1cm59fWZ1bmN0aW9uIHJpKGUsdCl7R289ZSxabz1Kbz1udWxsLG51bGwhPT0oZT1lLmRlcGVuZGVuY2llcykmJm51bGwhPT1lLmZpcnN0Q29udGV4dCYmKGUuZXhwaXJhdGlvblRpbWU+PXQmJihSYT0hMCksZS5maXJzdENvbnRleHQ9bnVsbCl9ZnVuY3Rpb24gb2koZSx0KXtpZihabyE9PWUmJiExIT09dCYmMCE9PXQpaWYoIm51bWJlciI9PT10eXBlb2YgdCYmMTA3Mzc0MTgyMyE9PXR8fChabz1lLHQ9MTA3Mzc0MTgy",
                    "MyksdD17Y29udGV4dDplLG9ic2VydmVkQml0czp0LG5leHQ6bnVsbH0sbnVsbD09PUpvKXtpZihudWxsPT09R28pdGhyb3cgRXJyb3IoYSgzMDgpKTtKbz10LEdvLmRlcGVuZGVuY2llcz17ZXhwaXJhdGlvblRpbWU6MCxmaXJzdENvbnRleHQ6dCxyZXNwb25kZXJzOm51bGx9fWVsc2UgSm89Sm8ubmV4dD10O3JldHVybiBlLl9jdXJyZW50VmFsdWV9dmFyIGlpPSExO2Z1bmN0aW9uIGFpKGUpe2UudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTplLm1lbW9pemVkU3RhdGUsYmFzZVF1ZXVlOm51bGwsc2hhcmVkOntwZW5kaW5nOm51bGx9LGVmZmVjdHM6bnVsbH19ZnVuY3Rpb24gbGkoZSx0KXtlPWUudXBkYXRlUXVldWUsdC51cGRhdGVRdWV1ZT09PWUmJih0LnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6ZS5iYXNlU3RhdGUsYmFzZVF1ZXVlOmUuYmFzZVF1ZXVlLHNoYXJlZDplLnNoYXJlZCxlZmZlY3RzOmUuZWZmZWN0c30pfWZ1bmN0aW9uIHVpKGUsdCl7cmV0dXJuKGU9e2V4cGlyYXRpb25UaW1lOmUsc3VzcGVuc2VDb25maWc6dCx0YWc6MCxwYXlsb2FkOm51bGwsY2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KS5uZXh0PWV9ZnVuY3Rpb24gc2koZSx0KXtpZihudWxsIT09KGU9ZS51cGRhdGVRdWV1ZSkpe3ZhciBuPShlPWUuc2hhcmVkKS5wZW5kaW5nO251bGw9PT1uP3QubmV4dD10Oih0Lm5leHQ9bi5uZXh0LG4ubmV4dD10KSxlLnBlbmRpbmc9dH19ZnVuY3Rpb24gY2koZSx0KXt2YXIgbj1lLmFsdGVybmF0ZTtudWxsIT09biYm",
                    "bGkobixlKSxudWxsPT09KG49KGU9ZS51cGRhdGVRdWV1ZSkuYmFzZVF1ZXVlKT8oZS5iYXNlUXVldWU9dC5uZXh0PXQsdC5uZXh0PXQpOih0Lm5leHQ9bi5uZXh0LG4ubmV4dD10KX1mdW5jdGlvbiBkaShlLHQsbixyKXt2YXIgaT1lLnVwZGF0ZVF1ZXVlO2lpPSExO3ZhciBhPWkuYmFzZVF1ZXVlLGw9aS5zaGFyZWQucGVuZGluZztpZihudWxsIT09bCl7aWYobnVsbCE9PWEpe3ZhciB1PWEubmV4dDthLm5leHQ9bC5uZXh0LGwubmV4dD11fWE9bCxpLnNoYXJlZC5wZW5kaW5nPW51bGwsbnVsbCE9PSh1PWUuYWx0ZXJuYXRlKSYmKG51bGwhPT0odT11LnVwZGF0ZVF1ZXVlKSYmKHUuYmFzZVF1ZXVlPWwpKX1pZihudWxsIT09YSl7dT1hLm5leHQ7dmFyIHM9aS5iYXNlU3RhdGUsYz0wLGQ9bnVsbCxmPW51bGwscD1udWxsO2lmKG51bGwhPT11KWZvcih2YXIgaD11Ozspe2lmKChsPWguZXhwaXJhdGlvblRpbWUpPHIpe3ZhciBtPXtleHBpcmF0aW9uVGltZTpoLmV4cGlyYXRpb25UaW1lLHN1c3BlbnNlQ29uZmlnOmguc3VzcGVuc2VDb25maWcsdGFnOmgudGFnLHBheWxvYWQ6aC5wYXlsb2FkLGNhbGxiYWNrOmguY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09cD8oZj1wPW0sZD1zKTpwPXAubmV4dD1tLGw+YyYmKGM9bCl9ZWxzZXtudWxsIT09cCYmKHA9cC5uZXh0PXtleHBpcmF0aW9uVGltZToxMDczNzQxODIzLHN1c3BlbnNlQ29uZmlnOmguc3VzcGVuc2VDb25maWcsdGFnOmgudGFnLHBheWxvYWQ6aC5wYXlsb2FkLGNh",
                    "bGxiYWNrOmguY2FsbGJhY2ssbmV4dDpudWxsfSksaXUobCxoLnN1c3BlbnNlQ29uZmlnKTtlOnt2YXIgdj1lLGI9aDtzd2l0Y2gobD10LG09bixiLnRhZyl7Y2FzZSAxOmlmKCJmdW5jdGlvbiI9PT10eXBlb2Yodj1iLnBheWxvYWQpKXtzPXYuY2FsbChtLHMsbCk7YnJlYWsgZX1zPXY7YnJlYWsgZTtjYXNlIDM6di5lZmZlY3RUYWc9LTQwOTcmdi5lZmZlY3RUYWd8NjQ7Y2FzZSAwOmlmKG51bGw9PT0obD0iZnVuY3Rpb24iPT09dHlwZW9mKHY9Yi5wYXlsb2FkKT92LmNhbGwobSxzLGwpOnYpfHx2b2lkIDA9PT1sKWJyZWFrIGU7cz1vKHt9LHMsbCk7YnJlYWsgZTtjYXNlIDI6aWk9ITB9fW51bGwhPT1oLmNhbGxiYWNrJiYoZS5lZmZlY3RUYWd8PTMyLG51bGw9PT0obD1pLmVmZmVjdHMpP2kuZWZmZWN0cz1baF06bC5wdXNoKGgpKX1pZihudWxsPT09KGg9aC5uZXh0KXx8aD09PXUpe2lmKG51bGw9PT0obD1pLnNoYXJlZC5wZW5kaW5nKSlicmVhaztoPWEubmV4dD1sLm5leHQsbC5uZXh0PXUsaS5iYXNlUXVldWU9YT1sLGkuc2hhcmVkLnBlbmRpbmc9bnVsbH19bnVsbD09PXA/ZD1zOnAubmV4dD1mLGkuYmFzZVN0YXRlPWQsaS5iYXNlUXVldWU9cCxhdShjKSxlLmV4cGlyYXRpb25UaW1lPWMsZS5tZW1vaXplZFN0YXRlPXN9fWZ1bmN0aW9uIGZpKGUsdCxuKXtpZihlPXQuZWZmZWN0cyx0LmVmZmVjdHM9bnVsbCxudWxsIT09ZSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgcj1lW3RdLG89ci5jYWxsYmFjaztpZihu",
                    "dWxsIT09byl7aWYoci5jYWxsYmFjaz1udWxsLHI9byxvPW4sImZ1bmN0aW9uIiE9PXR5cGVvZiByKXRocm93IEVycm9yKGEoMTkxLHIpKTtyLmNhbGwobyl9fX12YXIgcGk9WC5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxoaT0obmV3IHIuQ29tcG9uZW50KS5yZWZzO2Z1bmN0aW9uIG1pKGUsdCxuLHIpe249bnVsbD09PShuPW4ocix0PWUubWVtb2l6ZWRTdGF0ZSkpfHx2b2lkIDA9PT1uP3Q6byh7fSx0LG4pLGUubWVtb2l6ZWRTdGF0ZT1uLDA9PT1lLmV4cGlyYXRpb25UaW1lJiYoZS51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9bil9dmFyIHZpPXtpc01vdW50ZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuISEoZT1lLl9yZWFjdEludGVybmFsRmliZXIpJiZaZShlKT09PWV9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihlLHQsbil7ZT1lLl9yZWFjdEludGVybmFsRmliZXI7dmFyIHI9cWwoKSxvPXBpLnN1c3BlbnNlOyhvPXVpKHI9S2wocixlLG8pLG8pKS5wYXlsb2FkPXQsdm9pZCAwIT09biYmbnVsbCE9PW4mJihvLmNhbGxiYWNrPW4pLHNpKGUsbyksWWwoZSxyKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihlLHQsbil7ZT1lLl9yZWFjdEludGVybmFsRmliZXI7dmFyIHI9cWwoKSxvPXBpLnN1c3BlbnNlOyhvPXVpKHI9S2wocixlLG8pLG8pKS50YWc9MSxvLnBheWxvYWQ9dCx2b2lkIDAhPT1uJiZudWxsIT09biYmKG8uY2FsbGJhY2s9biksc2koZSxvKSxZbChlLHIpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24o",
                    "ZSx0KXtlPWUuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgbj1xbCgpLHI9cGkuc3VzcGVuc2U7KHI9dWkobj1LbChuLGUscikscikpLnRhZz0yLHZvaWQgMCE9PXQmJm51bGwhPT10JiYoci5jYWxsYmFjaz10KSxzaShlLHIpLFlsKGUsbil9fTtmdW5jdGlvbiBiaShlLHQsbixyLG8saSxhKXtyZXR1cm4iZnVuY3Rpb24iPT09dHlwZW9mKGU9ZS5zdGF0ZU5vZGUpLnNob3VsZENvbXBvbmVudFVwZGF0ZT9lLnNob3VsZENvbXBvbmVudFVwZGF0ZShyLGksYSk6IXQucHJvdG90eXBlfHwhdC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnR8fCghRnIobixyKXx8IUZyKG8saSkpfWZ1bmN0aW9uIHlpKGUsdCxuKXt2YXIgcj0hMSxvPWNvLGk9dC5jb250ZXh0VHlwZTtyZXR1cm4ib2JqZWN0Ij09PXR5cGVvZiBpJiZudWxsIT09aT9pPW9pKGkpOihvPXZvKHQpP2hvOmZvLmN1cnJlbnQsaT0ocj1udWxsIT09KHI9dC5jb250ZXh0VHlwZXMpJiZ2b2lkIDAhPT1yKT9tbyhlLG8pOmNvKSx0PW5ldyB0KG4saSksZS5tZW1vaXplZFN0YXRlPW51bGwhPT10LnN0YXRlJiZ2b2lkIDAhPT10LnN0YXRlP3Quc3RhdGU6bnVsbCx0LnVwZGF0ZXI9dmksZS5zdGF0ZU5vZGU9dCx0Ll9yZWFjdEludGVybmFsRmliZXI9ZSxyJiYoKGU9ZS5zdGF0ZU5vZGUpLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9byxlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWkpLHR9ZnVuY3Rpb24g",
                    "Z2koZSx0LG4scil7ZT10LnN0YXRlLCJmdW5jdGlvbiI9PT10eXBlb2YgdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZ0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobixyKSwiZnVuY3Rpb24iPT09dHlwZW9mIHQuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJnQuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobixyKSx0LnN0YXRlIT09ZSYmdmkuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0LHQuc3RhdGUsbnVsbCl9ZnVuY3Rpb24gd2koZSx0LG4scil7dmFyIG89ZS5zdGF0ZU5vZGU7by5wcm9wcz1uLG8uc3RhdGU9ZS5tZW1vaXplZFN0YXRlLG8ucmVmcz1oaSxhaShlKTt2YXIgaT10LmNvbnRleHRUeXBlOyJvYmplY3QiPT09dHlwZW9mIGkmJm51bGwhPT1pP28uY29udGV4dD1vaShpKTooaT12byh0KT9obzpmby5jdXJyZW50LG8uY29udGV4dD1tbyhlLGkpKSxkaShlLG4sbyxyKSxvLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSwiZnVuY3Rpb24iPT09dHlwZW9mKGk9dC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpJiYobWkoZSx0LGksbiksby5zdGF0ZT1lLm1lbW9pemVkU3RhdGUpLCJmdW5jdGlvbiI9PT10eXBlb2YgdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fCJmdW5jdGlvbiI9PT10eXBlb2Ygby5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8ImZ1bmN0aW9uIiE9PXR5cGVvZiBvLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJiJmdW5jdGlvbiIhPT10eXBlb2Ygby5jb21wb25lbnRX",
                    "aWxsTW91bnR8fCh0PW8uc3RhdGUsImZ1bmN0aW9uIj09PXR5cGVvZiBvLmNvbXBvbmVudFdpbGxNb3VudCYmby5jb21wb25lbnRXaWxsTW91bnQoKSwiZnVuY3Rpb24iPT09dHlwZW9mIG8uVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmby5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksdCE9PW8uc3RhdGUmJnZpLmVucXVldWVSZXBsYWNlU3RhdGUobyxvLnN0YXRlLG51bGwpLGRpKGUsbixvLHIpLG8uc3RhdGU9ZS5tZW1vaXplZFN0YXRlKSwiZnVuY3Rpb24iPT09dHlwZW9mIG8uY29tcG9uZW50RGlkTW91bnQmJihlLmVmZmVjdFRhZ3w9NCl9dmFyIHhpPUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gRWkoZSx0LG4pe2lmKG51bGwhPT0oZT1uLnJlZikmJiJmdW5jdGlvbiIhPT10eXBlb2YgZSYmIm9iamVjdCIhPT10eXBlb2YgZSl7aWYobi5fb3duZXIpe2lmKG49bi5fb3duZXIpe2lmKDEhPT1uLnRhZyl0aHJvdyBFcnJvcihhKDMwOSkpO3ZhciByPW4uc3RhdGVOb2RlfWlmKCFyKXRocm93IEVycm9yKGEoMTQ3LGUpKTt2YXIgbz0iIitlO3JldHVybiBudWxsIT09dCYmbnVsbCE9PXQucmVmJiYiZnVuY3Rpb24iPT09dHlwZW9mIHQucmVmJiZ0LnJlZi5fc3RyaW5nUmVmPT09bz90LnJlZjooKHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ci5yZWZzO3Q9PT1oaSYmKHQ9ci5yZWZzPXt9KSxudWxsPT09ZT9kZWxldGUgdFtvXTp0W29dPWV9KS5fc3RyaW5nUmVmPW8sdCl9aWYoInN0cmluZyIhPT10eXBlb2YgZSl0aHJvdyBFcnJv",
                    "cihhKDI4NCkpO2lmKCFuLl9vd25lcil0aHJvdyBFcnJvcihhKDI5MCxlKSl9cmV0dXJuIGV9ZnVuY3Rpb24gT2koZSx0KXtpZigidGV4dGFyZWEiIT09ZS50eXBlKXRocm93IEVycm9yKGEoMzEsIltvYmplY3QgT2JqZWN0XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk/Im9iamVjdCB3aXRoIGtleXMgeyIrT2JqZWN0LmtleXModCkuam9pbigiLCAiKSsifSI6dCwiIikpfWZ1bmN0aW9uIGtpKGUpe2Z1bmN0aW9uIHQodCxuKXtpZihlKXt2YXIgcj10Lmxhc3RFZmZlY3Q7bnVsbCE9PXI/KHIubmV4dEVmZmVjdD1uLHQubGFzdEVmZmVjdD1uKTp0LmZpcnN0RWZmZWN0PXQubGFzdEVmZmVjdD1uLG4ubmV4dEVmZmVjdD1udWxsLG4uZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIG4obixyKXtpZighZSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1yOyl0KG4scikscj1yLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gcihlLHQpe2ZvcihlPW5ldyBNYXA7bnVsbCE9PXQ7KW51bGwhPT10LmtleT9lLnNldCh0LmtleSx0KTplLnNldCh0LmluZGV4LHQpLHQ9dC5zaWJsaW5nO3JldHVybiBlfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4oZT1DdShlLHQpKS5pbmRleD0wLGUuc2libGluZz1udWxsLGV9ZnVuY3Rpb24gaSh0LG4scil7cmV0dXJuIHQuaW5kZXg9cixlP251bGwhPT0ocj10LmFsdGVybmF0ZSk/KHI9ci5pbmRleCk8bj8odC5lZmZlY3RUYWc9MixuKTpyOih0LmVmZmVjdFRhZz0yLG4pOm59ZnVuY3Rpb24g",
                    "bCh0KXtyZXR1cm4gZSYmbnVsbD09PXQuYWx0ZXJuYXRlJiYodC5lZmZlY3RUYWc9MiksdH1mdW5jdGlvbiB1KGUsdCxuLHIpe3JldHVybiBudWxsPT09dHx8NiE9PXQudGFnPygodD1QdShuLGUubW9kZSxyKSkucmV0dXJuPWUsdCk6KCh0PW8odCxuKSkucmV0dXJuPWUsdCl9ZnVuY3Rpb24gcyhlLHQsbixyKXtyZXR1cm4gbnVsbCE9PXQmJnQuZWxlbWVudFR5cGU9PT1uLnR5cGU/KChyPW8odCxuLnByb3BzKSkucmVmPUVpKGUsdCxuKSxyLnJldHVybj1lLHIpOigocj1qdShuLnR5cGUsbi5rZXksbi5wcm9wcyxudWxsLGUubW9kZSxyKSkucmVmPUVpKGUsdCxuKSxyLnJldHVybj1lLHIpfWZ1bmN0aW9uIGMoZSx0LG4scil7cmV0dXJuIG51bGw9PT10fHw0IT09dC50YWd8fHQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1uLmNvbnRhaW5lckluZm98fHQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09bi5pbXBsZW1lbnRhdGlvbj8oKHQ9UnUobixlLm1vZGUscikpLnJldHVybj1lLHQpOigodD1vKHQsbi5jaGlsZHJlbnx8W10pKS5yZXR1cm49ZSx0KX1mdW5jdGlvbiBkKGUsdCxuLHIsaSl7cmV0dXJuIG51bGw9PT10fHw3IT09dC50YWc/KCh0PVR1KG4sZS5tb2RlLHIsaSkpLnJldHVybj1lLHQpOigodD1vKHQsbikpLnJldHVybj1lLHQpfWZ1bmN0aW9uIGYoZSx0LG4pe2lmKCJzdHJpbmciPT09dHlwZW9mIHR8fCJudW1iZXIiPT09dHlwZW9mIHQpcmV0dXJuKHQ9UHUoIiIrdCxlLm1vZGUsbikpLnJldHVybj1lLHQ7",
                    "aWYoIm9iamVjdCI9PT10eXBlb2YgdCYmbnVsbCE9PXQpe3N3aXRjaCh0LiQkdHlwZW9mKXtjYXNlIGVlOnJldHVybihuPWp1KHQudHlwZSx0LmtleSx0LnByb3BzLG51bGwsZS5tb2RlLG4pKS5yZWY9RWkoZSxudWxsLHQpLG4ucmV0dXJuPWUsbjtjYXNlIHRlOnJldHVybih0PVJ1KHQsZS5tb2RlLG4pKS5yZXR1cm49ZSx0fWlmKHhpKHQpfHxtZSh0KSlyZXR1cm4odD1UdSh0LGUubW9kZSxuLG51bGwpKS5yZXR1cm49ZSx0O09pKGUsdCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gcChlLHQsbixyKXt2YXIgbz1udWxsIT09dD90LmtleTpudWxsO2lmKCJzdHJpbmciPT09dHlwZW9mIG58fCJudW1iZXIiPT09dHlwZW9mIG4pcmV0dXJuIG51bGwhPT1vP251bGw6dShlLHQsIiIrbixyKTtpZigib2JqZWN0Ij09PXR5cGVvZiBuJiZudWxsIT09bil7c3dpdGNoKG4uJCR0eXBlb2Ype2Nhc2UgZWU6cmV0dXJuIG4ua2V5PT09bz9uLnR5cGU9PT1uZT9kKGUsdCxuLnByb3BzLmNoaWxkcmVuLHIsbyk6cyhlLHQsbixyKTpudWxsO2Nhc2UgdGU6cmV0dXJuIG4ua2V5PT09bz9jKGUsdCxuLHIpOm51bGx9aWYoeGkobil8fG1lKG4pKXJldHVybiBudWxsIT09bz9udWxsOmQoZSx0LG4scixudWxsKTtPaShlLG4pfXJldHVybiBudWxsfWZ1bmN0aW9uIGgoZSx0LG4scixvKXtpZigic3RyaW5nIj09PXR5cGVvZiByfHwibnVtYmVyIj09PXR5cGVvZiByKXJldHVybiB1KHQsZT1lLmdldChuKXx8bnVsbCwiIityLG8pO2lmKCJvYmplY3QiPT09",
                    "dHlwZW9mIHImJm51bGwhPT1yKXtzd2l0Y2goci4kJHR5cGVvZil7Y2FzZSBlZTpyZXR1cm4gZT1lLmdldChudWxsPT09ci5rZXk/bjpyLmtleSl8fG51bGwsci50eXBlPT09bmU/ZCh0LGUsci5wcm9wcy5jaGlsZHJlbixvLHIua2V5KTpzKHQsZSxyLG8pO2Nhc2UgdGU6cmV0dXJuIGModCxlPWUuZ2V0KG51bGw9PT1yLmtleT9uOnIua2V5KXx8bnVsbCxyLG8pfWlmKHhpKHIpfHxtZShyKSlyZXR1cm4gZCh0LGU9ZS5nZXQobil8fG51bGwscixvLG51bGwpO09pKHQscil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbShvLGEsbCx1KXtmb3IodmFyIHM9bnVsbCxjPW51bGwsZD1hLG09YT0wLHY9bnVsbDtudWxsIT09ZCYmbTxsLmxlbmd0aDttKyspe2QuaW5kZXg+bT8odj1kLGQ9bnVsbCk6dj1kLnNpYmxpbmc7dmFyIGI9cChvLGQsbFttXSx1KTtpZihudWxsPT09Yil7bnVsbD09PWQmJihkPXYpO2JyZWFrfWUmJmQmJm51bGw9PT1iLmFsdGVybmF0ZSYmdChvLGQpLGE9aShiLGEsbSksbnVsbD09PWM/cz1iOmMuc2libGluZz1iLGM9YixkPXZ9aWYobT09PWwubGVuZ3RoKXJldHVybiBuKG8sZCkscztpZihudWxsPT09ZCl7Zm9yKDttPGwubGVuZ3RoO20rKyludWxsIT09KGQ9ZihvLGxbbV0sdSkpJiYoYT1pKGQsYSxtKSxudWxsPT09Yz9zPWQ6Yy5zaWJsaW5nPWQsYz1kKTtyZXR1cm4gc31mb3IoZD1yKG8sZCk7bTxsLmxlbmd0aDttKyspbnVsbCE9PSh2PWgoZCxvLG0sbFttXSx1KSkmJihlJiZudWxsIT09di5hbHRlcm5hdGUm",
                    "JmQuZGVsZXRlKG51bGw9PT12LmtleT9tOnYua2V5KSxhPWkodixhLG0pLG51bGw9PT1jP3M9djpjLnNpYmxpbmc9dixjPXYpO3JldHVybiBlJiZkLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB0KG8sZSl9KSksc31mdW5jdGlvbiB2KG8sbCx1LHMpe3ZhciBjPW1lKHUpO2lmKCJmdW5jdGlvbiIhPT10eXBlb2YgYyl0aHJvdyBFcnJvcihhKDE1MCkpO2lmKG51bGw9PSh1PWMuY2FsbCh1KSkpdGhyb3cgRXJyb3IoYSgxNTEpKTtmb3IodmFyIGQ9Yz1udWxsLG09bCx2PWw9MCxiPW51bGwseT11Lm5leHQoKTtudWxsIT09bSYmIXkuZG9uZTt2KysseT11Lm5leHQoKSl7bS5pbmRleD52PyhiPW0sbT1udWxsKTpiPW0uc2libGluZzt2YXIgZz1wKG8sbSx5LnZhbHVlLHMpO2lmKG51bGw9PT1nKXtudWxsPT09bSYmKG09Yik7YnJlYWt9ZSYmbSYmbnVsbD09PWcuYWx0ZXJuYXRlJiZ0KG8sbSksbD1pKGcsbCx2KSxudWxsPT09ZD9jPWc6ZC5zaWJsaW5nPWcsZD1nLG09Yn1pZih5LmRvbmUpcmV0dXJuIG4obyxtKSxjO2lmKG51bGw9PT1tKXtmb3IoOyF5LmRvbmU7disrLHk9dS5uZXh0KCkpbnVsbCE9PSh5PWYobyx5LnZhbHVlLHMpKSYmKGw9aSh5LGwsdiksbnVsbD09PWQ/Yz15OmQuc2libGluZz15LGQ9eSk7cmV0dXJuIGN9Zm9yKG09cihvLG0pOyF5LmRvbmU7disrLHk9dS5uZXh0KCkpbnVsbCE9PSh5PWgobSxvLHYseS52YWx1ZSxzKSkmJihlJiZudWxsIT09eS5hbHRlcm5hdGUmJm0uZGVsZXRlKG51bGw9PT15Lmtl",
                    "eT92Onkua2V5KSxsPWkoeSxsLHYpLG51bGw9PT1kP2M9eTpkLnNpYmxpbmc9eSxkPXkpO3JldHVybiBlJiZtLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB0KG8sZSl9KSksY31yZXR1cm4gZnVuY3Rpb24oZSxyLGksdSl7dmFyIHM9Im9iamVjdCI9PT10eXBlb2YgaSYmbnVsbCE9PWkmJmkudHlwZT09PW5lJiZudWxsPT09aS5rZXk7cyYmKGk9aS5wcm9wcy5jaGlsZHJlbik7dmFyIGM9Im9iamVjdCI9PT10eXBlb2YgaSYmbnVsbCE9PWk7aWYoYylzd2l0Y2goaS4kJHR5cGVvZil7Y2FzZSBlZTplOntmb3IoYz1pLmtleSxzPXI7bnVsbCE9PXM7KXtpZihzLmtleT09PWMpe3N3aXRjaChzLnRhZyl7Y2FzZSA3OmlmKGkudHlwZT09PW5lKXtuKGUscy5zaWJsaW5nKSwocj1vKHMsaS5wcm9wcy5jaGlsZHJlbikpLnJldHVybj1lLGU9cjticmVhayBlfWJyZWFrO2RlZmF1bHQ6aWYocy5lbGVtZW50VHlwZT09PWkudHlwZSl7bihlLHMuc2libGluZyksKHI9byhzLGkucHJvcHMpKS5yZWY9RWkoZSxzLGkpLHIucmV0dXJuPWUsZT1yO2JyZWFrIGV9fW4oZSxzKTticmVha310KGUscykscz1zLnNpYmxpbmd9aS50eXBlPT09bmU/KChyPVR1KGkucHJvcHMuY2hpbGRyZW4sZS5tb2RlLHUsaS5rZXkpKS5yZXR1cm49ZSxlPXIpOigodT1qdShpLnR5cGUsaS5rZXksaS5wcm9wcyxudWxsLGUubW9kZSx1KSkucmVmPUVpKGUscixpKSx1LnJldHVybj1lLGU9dSl9cmV0dXJuIGwoZSk7Y2FzZSB0ZTplOntmb3Iocz1pLmtleTtudWxs",
                    "IT09cjspe2lmKHIua2V5PT09cyl7aWYoND09PXIudGFnJiZyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09aS5jb250YWluZXJJbmZvJiZyLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWkuaW1wbGVtZW50YXRpb24pe24oZSxyLnNpYmxpbmcpLChyPW8ocixpLmNoaWxkcmVufHxbXSkpLnJldHVybj1lLGU9cjticmVhayBlfW4oZSxyKTticmVha310KGUscikscj1yLnNpYmxpbmd9KHI9UnUoaSxlLm1vZGUsdSkpLnJldHVybj1lLGU9cn1yZXR1cm4gbChlKX1pZigic3RyaW5nIj09PXR5cGVvZiBpfHwibnVtYmVyIj09PXR5cGVvZiBpKXJldHVybiBpPSIiK2ksbnVsbCE9PXImJjY9PT1yLnRhZz8obihlLHIuc2libGluZyksKHI9byhyLGkpKS5yZXR1cm49ZSxlPXIpOihuKGUsciksKHI9UHUoaSxlLm1vZGUsdSkpLnJldHVybj1lLGU9ciksbChlKTtpZih4aShpKSlyZXR1cm4gbShlLHIsaSx1KTtpZihtZShpKSlyZXR1cm4gdihlLHIsaSx1KTtpZihjJiZPaShlLGkpLCJ1bmRlZmluZWQiPT09dHlwZW9mIGkmJiFzKXN3aXRjaChlLnRhZyl7Y2FzZSAxOmNhc2UgMDp0aHJvdyBlPWUudHlwZSxFcnJvcihhKDE1MixlLmRpc3BsYXlOYW1lfHxlLm5hbWV8fCJDb21wb25lbnQiKSl9cmV0dXJuIG4oZSxyKX19dmFyIFNpPWtpKCEwKSxDaT1raSghMSksamk9e30sVGk9e2N1cnJlbnQ6aml9LFBpPXtjdXJyZW50OmppfSxSaT17Y3VycmVudDpqaX07ZnVuY3Rpb24gTmkoZSl7aWYoZT09PWppKXRocm93IEVycm9yKGEoMTc0",
                    "KSk7cmV0dXJuIGV9ZnVuY3Rpb24gTWkoZSx0KXtzd2l0Y2goc28oUmksdCksc28oUGksZSksc28oVGksamkpLGU9dC5ub2RlVHlwZSl7Y2FzZSA5OmNhc2UgMTE6dD0odD10LmRvY3VtZW50RWxlbWVudCk/dC5uYW1lc3BhY2VVUkk6emUobnVsbCwiIik7YnJlYWs7ZGVmYXVsdDp0PXplKHQ9KGU9OD09PWU/dC5wYXJlbnROb2RlOnQpLm5hbWVzcGFjZVVSSXx8bnVsbCxlPWUudGFnTmFtZSl9dW8oVGkpLHNvKFRpLHQpfWZ1bmN0aW9uIF9pKCl7dW8oVGkpLHVvKFBpKSx1byhSaSl9ZnVuY3Rpb24gQWkoZSl7TmkoUmkuY3VycmVudCk7dmFyIHQ9TmkoVGkuY3VycmVudCksbj16ZSh0LGUudHlwZSk7dCE9PW4mJihzbyhQaSxlKSxzbyhUaSxuKSl9ZnVuY3Rpb24gSWkoZSl7UGkuY3VycmVudD09PWUmJih1byhUaSksdW8oUGkpKX12YXIgRGk9e2N1cnJlbnQ6MH07ZnVuY3Rpb24gemkoZSl7Zm9yKHZhciB0PWU7bnVsbCE9PXQ7KXtpZigxMz09PXQudGFnKXt2YXIgbj10Lm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PW4mJihudWxsPT09KG49bi5kZWh5ZHJhdGVkKXx8IiQ/Ij09PW4uZGF0YXx8IiQhIj09PW4uZGF0YSkpcmV0dXJuIHR9ZWxzZSBpZigxOT09PXQudGFnJiZ2b2lkIDAhPT10Lm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIpe2lmKDAhPT0oNjQmdC5lZmZlY3RUYWcpKXJldHVybiB0fWVsc2UgaWYobnVsbCE9PXQuY2hpbGQpe3QuY2hpbGQucmV0dXJuPXQsdD10LmNoaWxkO2NvbnRpbnVlfWlmKHQ9PT1lKWJyZWFr",
                    "O2Zvcig7bnVsbD09PXQuc2libGluZzspe2lmKG51bGw9PT10LnJldHVybnx8dC5yZXR1cm49PT1lKXJldHVybiBudWxsO3Q9dC5yZXR1cm59dC5zaWJsaW5nLnJldHVybj10LnJldHVybix0PXQuc2libGluZ31yZXR1cm4gbnVsbH1mdW5jdGlvbiBMaShlLHQpe3JldHVybntyZXNwb25kZXI6ZSxwcm9wczp0fX12YXIgRmk9WC5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCRpPVguUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsV2k9MCxCaT1udWxsLEhpPW51bGwsVmk9bnVsbCxVaT0hMTtmdW5jdGlvbiBxaSgpe3Rocm93IEVycm9yKGEoMzIxKSl9ZnVuY3Rpb24gS2koZSx0KXtpZihudWxsPT09dClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoO24rKylpZighenIoZVtuXSx0W25dKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBZaShlLHQsbixyLG8saSl7aWYoV2k9aSxCaT10LHQubWVtb2l6ZWRTdGF0ZT1udWxsLHQudXBkYXRlUXVldWU9bnVsbCx0LmV4cGlyYXRpb25UaW1lPTAsRmkuY3VycmVudD1udWxsPT09ZXx8bnVsbD09PWUubWVtb2l6ZWRTdGF0ZT9iYTp5YSxlPW4ocixvKSx0LmV4cGlyYXRpb25UaW1lPT09V2kpe2k9MDtkb3tpZih0LmV4cGlyYXRpb25UaW1lPTAsISgyNT5pKSl0aHJvdyBFcnJvcihhKDMwMSkpO2krPTEsVmk9SGk9bnVsbCx0LnVwZGF0ZVF1ZXVlPW51bGwsRmkuY3VycmVudD1nYSxlPW4ocixvKX13aGlsZSh0LmV4cGlyYXRpb25UaW1lPT09V2kpfWlmKEZpLmN1",
                    "cnJlbnQ9dmEsdD1udWxsIT09SGkmJm51bGwhPT1IaS5uZXh0LFdpPTAsVmk9SGk9Qmk9bnVsbCxVaT0hMSx0KXRocm93IEVycm9yKGEoMzAwKSk7cmV0dXJuIGV9ZnVuY3Rpb24gUWkoKXt2YXIgZT17bWVtb2l6ZWRTdGF0ZTpudWxsLGJhc2VTdGF0ZTpudWxsLGJhc2VRdWV1ZTpudWxsLHF1ZXVlOm51bGwsbmV4dDpudWxsfTtyZXR1cm4gbnVsbD09PVZpP0JpLm1lbW9pemVkU3RhdGU9Vmk9ZTpWaT1WaS5uZXh0PWUsVml9ZnVuY3Rpb24gWGkoKXtpZihudWxsPT09SGkpe3ZhciBlPUJpLmFsdGVybmF0ZTtlPW51bGwhPT1lP2UubWVtb2l6ZWRTdGF0ZTpudWxsfWVsc2UgZT1IaS5uZXh0O3ZhciB0PW51bGw9PT1WaT9CaS5tZW1vaXplZFN0YXRlOlZpLm5leHQ7aWYobnVsbCE9PXQpVmk9dCxIaT1lO2Vsc2V7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoYSgzMTApKTtlPXttZW1vaXplZFN0YXRlOihIaT1lKS5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpIaS5iYXNlU3RhdGUsYmFzZVF1ZXVlOkhpLmJhc2VRdWV1ZSxxdWV1ZTpIaS5xdWV1ZSxuZXh0Om51bGx9LG51bGw9PT1WaT9CaS5tZW1vaXplZFN0YXRlPVZpPWU6Vmk9VmkubmV4dD1lfXJldHVybiBWaX1mdW5jdGlvbiBHaShlLHQpe3JldHVybiJmdW5jdGlvbiI9PT10eXBlb2YgdD90KGUpOnR9ZnVuY3Rpb24gSmkoZSl7dmFyIHQ9WGkoKSxuPXQucXVldWU7aWYobnVsbD09PW4pdGhyb3cgRXJyb3IoYSgzMTEpKTtuLmxhc3RSZW5kZXJlZFJlZHVjZXI9ZTt2YXIgcj1I",
                    "aSxvPXIuYmFzZVF1ZXVlLGk9bi5wZW5kaW5nO2lmKG51bGwhPT1pKXtpZihudWxsIT09byl7dmFyIGw9by5uZXh0O28ubmV4dD1pLm5leHQsaS5uZXh0PWx9ci5iYXNlUXVldWU9bz1pLG4ucGVuZGluZz1udWxsfWlmKG51bGwhPT1vKXtvPW8ubmV4dCxyPXIuYmFzZVN0YXRlO3ZhciB1PWw9aT1udWxsLHM9bztkb3t2YXIgYz1zLmV4cGlyYXRpb25UaW1lO2lmKGM8V2kpe3ZhciBkPXtleHBpcmF0aW9uVGltZTpzLmV4cGlyYXRpb25UaW1lLHN1c3BlbnNlQ29uZmlnOnMuc3VzcGVuc2VDb25maWcsYWN0aW9uOnMuYWN0aW9uLGVhZ2VyUmVkdWNlcjpzLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOnMuZWFnZXJTdGF0ZSxuZXh0Om51bGx9O251bGw9PT11PyhsPXU9ZCxpPXIpOnU9dS5uZXh0PWQsYz5CaS5leHBpcmF0aW9uVGltZSYmKEJpLmV4cGlyYXRpb25UaW1lPWMsYXUoYykpfWVsc2UgbnVsbCE9PXUmJih1PXUubmV4dD17ZXhwaXJhdGlvblRpbWU6MTA3Mzc0MTgyMyxzdXNwZW5zZUNvbmZpZzpzLnN1c3BlbnNlQ29uZmlnLGFjdGlvbjpzLmFjdGlvbixlYWdlclJlZHVjZXI6cy5lYWdlclJlZHVjZXIsZWFnZXJTdGF0ZTpzLmVhZ2VyU3RhdGUsbmV4dDpudWxsfSksaXUoYyxzLnN1c3BlbnNlQ29uZmlnKSxyPXMuZWFnZXJSZWR1Y2VyPT09ZT9zLmVhZ2VyU3RhdGU6ZShyLHMuYWN0aW9uKTtzPXMubmV4dH13aGlsZShudWxsIT09cyYmcyE9PW8pO251bGw9PT11P2k9cjp1Lm5leHQ9bCx6cihyLHQubWVtb2l6ZWRTdGF0",
                    "ZSl8fChSYT0hMCksdC5tZW1vaXplZFN0YXRlPXIsdC5iYXNlU3RhdGU9aSx0LmJhc2VRdWV1ZT11LG4ubGFzdFJlbmRlcmVkU3RhdGU9cn1yZXR1cm5bdC5tZW1vaXplZFN0YXRlLG4uZGlzcGF0Y2hdfWZ1bmN0aW9uIFppKGUpe3ZhciB0PVhpKCksbj10LnF1ZXVlO2lmKG51bGw9PT1uKXRocm93IEVycm9yKGEoMzExKSk7bi5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIHI9bi5kaXNwYXRjaCxvPW4ucGVuZGluZyxpPXQubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09byl7bi5wZW5kaW5nPW51bGw7dmFyIGw9bz1vLm5leHQ7ZG97aT1lKGksbC5hY3Rpb24pLGw9bC5uZXh0fXdoaWxlKGwhPT1vKTt6cihpLHQubWVtb2l6ZWRTdGF0ZSl8fChSYT0hMCksdC5tZW1vaXplZFN0YXRlPWksbnVsbD09PXQuYmFzZVF1ZXVlJiYodC5iYXNlU3RhdGU9aSksbi5sYXN0UmVuZGVyZWRTdGF0ZT1pfXJldHVybltpLHJdfWZ1bmN0aW9uIGVhKGUpe3ZhciB0PVFpKCk7cmV0dXJuImZ1bmN0aW9uIj09PXR5cGVvZiBlJiYoZT1lKCkpLHQubWVtb2l6ZWRTdGF0ZT10LmJhc2VTdGF0ZT1lLGU9KGU9dC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpHaSxsYXN0UmVuZGVyZWRTdGF0ZTplfSkuZGlzcGF0Y2g9bWEuYmluZChudWxsLEJpLGUpLFt0Lm1lbW9pemVkU3RhdGUsZV19ZnVuY3Rpb24gdGEoZSx0LG4scil7cmV0dXJuIGU9e3RhZzplLGNyZWF0ZTp0LGRlc3Ryb3k6bixkZXBzOnIsbmV4",
                    "dDpudWxsfSxudWxsPT09KHQ9QmkudXBkYXRlUXVldWUpPyh0PXtsYXN0RWZmZWN0Om51bGx9LEJpLnVwZGF0ZVF1ZXVlPXQsdC5sYXN0RWZmZWN0PWUubmV4dD1lKTpudWxsPT09KG49dC5sYXN0RWZmZWN0KT90Lmxhc3RFZmZlY3Q9ZS5uZXh0PWU6KHI9bi5uZXh0LG4ubmV4dD1lLGUubmV4dD1yLHQubGFzdEVmZmVjdD1lKSxlfWZ1bmN0aW9uIG5hKCl7cmV0dXJuIFhpKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiByYShlLHQsbixyKXt2YXIgbz1RaSgpO0JpLmVmZmVjdFRhZ3w9ZSxvLm1lbW9pemVkU3RhdGU9dGEoMXx0LG4sdm9pZCAwLHZvaWQgMD09PXI/bnVsbDpyKX1mdW5jdGlvbiBvYShlLHQsbixyKXt2YXIgbz1YaSgpO3I9dm9pZCAwPT09cj9udWxsOnI7dmFyIGk9dm9pZCAwO2lmKG51bGwhPT1IaSl7dmFyIGE9SGkubWVtb2l6ZWRTdGF0ZTtpZihpPWEuZGVzdHJveSxudWxsIT09ciYmS2kocixhLmRlcHMpKXJldHVybiB2b2lkIHRhKHQsbixpLHIpfUJpLmVmZmVjdFRhZ3w9ZSxvLm1lbW9pemVkU3RhdGU9dGEoMXx0LG4saSxyKX1mdW5jdGlvbiBpYShlLHQpe3JldHVybiByYSg1MTYsNCxlLHQpfWZ1bmN0aW9uIGFhKGUsdCl7cmV0dXJuIG9hKDUxNiw0LGUsdCl9ZnVuY3Rpb24gbGEoZSx0KXtyZXR1cm4gb2EoNCwyLGUsdCl9ZnVuY3Rpb24gdWEoZSx0KXtyZXR1cm4iZnVuY3Rpb24iPT09dHlwZW9mIHQ/KGU9ZSgpLHQoZSksZnVuY3Rpb24oKXt0KG51bGwpfSk6bnVsbCE9PXQmJnZvaWQgMCE9PXQ/KGU9",
                    "ZSgpLHQuY3VycmVudD1lLGZ1bmN0aW9uKCl7dC5jdXJyZW50PW51bGx9KTp2b2lkIDB9ZnVuY3Rpb24gc2EoZSx0LG4pe3JldHVybiBuPW51bGwhPT1uJiZ2b2lkIDAhPT1uP24uY29uY2F0KFtlXSk6bnVsbCxvYSg0LDIsdWEuYmluZChudWxsLHQsZSksbil9ZnVuY3Rpb24gY2EoKXt9ZnVuY3Rpb24gZGEoZSx0KXtyZXR1cm4gUWkoKS5tZW1vaXplZFN0YXRlPVtlLHZvaWQgMD09PXQ/bnVsbDp0XSxlfWZ1bmN0aW9uIGZhKGUsdCl7dmFyIG49WGkoKTt0PXZvaWQgMD09PXQ/bnVsbDp0O3ZhciByPW4ubWVtb2l6ZWRTdGF0ZTtyZXR1cm4gbnVsbCE9PXImJm51bGwhPT10JiZLaSh0LHJbMV0pP3JbMF06KG4ubWVtb2l6ZWRTdGF0ZT1bZSx0XSxlKX1mdW5jdGlvbiBwYShlLHQpe3ZhciBuPVhpKCk7dD12b2lkIDA9PT10P251bGw6dDt2YXIgcj1uLm1lbW9pemVkU3RhdGU7cmV0dXJuIG51bGwhPT1yJiZudWxsIT09dCYmS2kodCxyWzFdKT9yWzBdOihlPWUoKSxuLm1lbW9pemVkU3RhdGU9W2UsdF0sZSl9ZnVuY3Rpb24gaGEoZSx0LG4pe3ZhciByPVdvKCk7SG8oOTg+cj85ODpyLChmdW5jdGlvbigpe2UoITApfSkpLEhvKDk3PHI/OTc6ciwoZnVuY3Rpb24oKXt2YXIgcj0kaS5zdXNwZW5zZTskaS5zdXNwZW5zZT12b2lkIDA9PT10P251bGw6dDt0cnl7ZSghMSksbigpfWZpbmFsbHl7JGkuc3VzcGVuc2U9cn19KSl9ZnVuY3Rpb24gbWEoZSx0LG4pe3ZhciByPXFsKCksbz1waS5zdXNwZW5zZTtvPXtleHBpcmF0aW9uVGlt",
                    "ZTpyPUtsKHIsZSxvKSxzdXNwZW5zZUNvbmZpZzpvLGFjdGlvbjpuLGVhZ2VyUmVkdWNlcjpudWxsLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O3ZhciBpPXQucGVuZGluZztpZihudWxsPT09aT9vLm5leHQ9bzooby5uZXh0PWkubmV4dCxpLm5leHQ9byksdC5wZW5kaW5nPW8saT1lLmFsdGVybmF0ZSxlPT09Qml8fG51bGwhPT1pJiZpPT09QmkpVWk9ITAsby5leHBpcmF0aW9uVGltZT1XaSxCaS5leHBpcmF0aW9uVGltZT1XaTtlbHNle2lmKDA9PT1lLmV4cGlyYXRpb25UaW1lJiYobnVsbD09PWl8fDA9PT1pLmV4cGlyYXRpb25UaW1lKSYmbnVsbCE9PShpPXQubGFzdFJlbmRlcmVkUmVkdWNlcikpdHJ5e3ZhciBhPXQubGFzdFJlbmRlcmVkU3RhdGUsbD1pKGEsbik7aWYoby5lYWdlclJlZHVjZXI9aSxvLmVhZ2VyU3RhdGU9bCx6cihsLGEpKXJldHVybn1jYXRjaCh1KXt9WWwoZSxyKX19dmFyIHZhPXtyZWFkQ29udGV4dDpvaSx1c2VDYWxsYmFjazpxaSx1c2VDb250ZXh0OnFpLHVzZUVmZmVjdDpxaSx1c2VJbXBlcmF0aXZlSGFuZGxlOnFpLHVzZUxheW91dEVmZmVjdDpxaSx1c2VNZW1vOnFpLHVzZVJlZHVjZXI6cWksdXNlUmVmOnFpLHVzZVN0YXRlOnFpLHVzZURlYnVnVmFsdWU6cWksdXNlUmVzcG9uZGVyOnFpLHVzZURlZmVycmVkVmFsdWU6cWksdXNlVHJhbnNpdGlvbjpxaX0sYmE9e3JlYWRDb250ZXh0Om9pLHVzZUNhbGxiYWNrOmRhLHVzZUNvbnRleHQ6b2ksdXNlRWZmZWN0OmlhLHVzZUltcGVyYXRpdmVI",
                    "YW5kbGU6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBuPW51bGwhPT1uJiZ2b2lkIDAhPT1uP24uY29uY2F0KFtlXSk6bnVsbCxyYSg0LDIsdWEuYmluZChudWxsLHQsZSksbil9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihlLHQpe3JldHVybiByYSg0LDIsZSx0KX0sdXNlTWVtbzpmdW5jdGlvbihlLHQpe3ZhciBuPVFpKCk7cmV0dXJuIHQ9dm9pZCAwPT09dD9udWxsOnQsZT1lKCksbi5tZW1vaXplZFN0YXRlPVtlLHRdLGV9LHVzZVJlZHVjZXI6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVFpKCk7cmV0dXJuIHQ9dm9pZCAwIT09bj9uKHQpOnQsci5tZW1vaXplZFN0YXRlPXIuYmFzZVN0YXRlPXQsZT0oZT1yLnF1ZXVlPXtwZW5kaW5nOm51bGwsZGlzcGF0Y2g6bnVsbCxsYXN0UmVuZGVyZWRSZWR1Y2VyOmUsbGFzdFJlbmRlcmVkU3RhdGU6dH0pLmRpc3BhdGNoPW1hLmJpbmQobnVsbCxCaSxlKSxbci5tZW1vaXplZFN0YXRlLGVdfSx1c2VSZWY6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9e2N1cnJlbnQ6ZX0sUWkoKS5tZW1vaXplZFN0YXRlPWV9LHVzZVN0YXRlOmVhLHVzZURlYnVnVmFsdWU6Y2EsdXNlUmVzcG9uZGVyOkxpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lYShlKSxyPW5bMF0sbz1uWzFdO3JldHVybiBpYSgoZnVuY3Rpb24oKXt2YXIgbj0kaS5zdXNwZW5zZTskaS5zdXNwZW5zZT12b2lkIDA9PT10P251bGw6dDt0cnl7byhlKX1maW5hbGx5eyRpLnN1c3BlbnNlPW59fSksW2UsdF0pLHJ9LHVz",
                    "ZVRyYW5zaXRpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZWEoITEpLG49dFswXTtyZXR1cm4gdD10WzFdLFtkYShoYS5iaW5kKG51bGwsdCxlKSxbdCxlXSksbl19fSx5YT17cmVhZENvbnRleHQ6b2ksdXNlQ2FsbGJhY2s6ZmEsdXNlQ29udGV4dDpvaSx1c2VFZmZlY3Q6YWEsdXNlSW1wZXJhdGl2ZUhhbmRsZTpzYSx1c2VMYXlvdXRFZmZlY3Q6bGEsdXNlTWVtbzpwYSx1c2VSZWR1Y2VyOkppLHVzZVJlZjpuYSx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBKaShHaSl9LHVzZURlYnVnVmFsdWU6Y2EsdXNlUmVzcG9uZGVyOkxpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1KaShHaSkscj1uWzBdLG89blsxXTtyZXR1cm4gYWEoKGZ1bmN0aW9uKCl7dmFyIG49JGkuc3VzcGVuc2U7JGkuc3VzcGVuc2U9dm9pZCAwPT09dD9udWxsOnQ7dHJ5e28oZSl9ZmluYWxseXskaS5zdXNwZW5zZT1ufX0pLFtlLHRdKSxyfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKGUpe3ZhciB0PUppKEdpKSxuPXRbMF07cmV0dXJuIHQ9dFsxXSxbZmEoaGEuYmluZChudWxsLHQsZSksW3QsZV0pLG5dfX0sZ2E9e3JlYWRDb250ZXh0Om9pLHVzZUNhbGxiYWNrOmZhLHVzZUNvbnRleHQ6b2ksdXNlRWZmZWN0OmFhLHVzZUltcGVyYXRpdmVIYW5kbGU6c2EsdXNlTGF5b3V0RWZmZWN0OmxhLHVzZU1lbW86cGEsdXNlUmVkdWNlcjpaaSx1c2VSZWY6bmEsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gWmkoR2kpfSx1c2VEZWJ1Z1ZhbHVl",
                    "OmNhLHVzZVJlc3BvbmRlcjpMaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49WmkoR2kpLHI9blswXSxvPW5bMV07cmV0dXJuIGFhKChmdW5jdGlvbigpe3ZhciBuPSRpLnN1c3BlbnNlOyRpLnN1c3BlbnNlPXZvaWQgMD09PXQ/bnVsbDp0O3RyeXtvKGUpfWZpbmFsbHl7JGkuc3VzcGVuc2U9bn19KSxbZSx0XSkscn0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbihlKXt2YXIgdD1aaShHaSksbj10WzBdO3JldHVybiB0PXRbMV0sW2ZhKGhhLmJpbmQobnVsbCx0LGUpLFt0LGVdKSxuXX19LHdhPW51bGwseGE9bnVsbCxFYT0hMTtmdW5jdGlvbiBPYShlLHQpe3ZhciBuPWt1KDUsbnVsbCxudWxsLDApO24uZWxlbWVudFR5cGU9IkRFTEVURUQiLG4udHlwZT0iREVMRVRFRCIsbi5zdGF0ZU5vZGU9dCxuLnJldHVybj1lLG4uZWZmZWN0VGFnPTgsbnVsbCE9PWUubGFzdEVmZmVjdD8oZS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9bixlLmxhc3RFZmZlY3Q9bik6ZS5maXJzdEVmZmVjdD1lLmxhc3RFZmZlY3Q9bn1mdW5jdGlvbiBrYShlLHQpe3N3aXRjaChlLnRhZyl7Y2FzZSA1OnZhciBuPWUudHlwZTtyZXR1cm4gbnVsbCE9PSh0PTEhPT10Lm5vZGVUeXBlfHxuLnRvTG93ZXJDYXNlKCkhPT10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/bnVsbDp0KSYmKGUuc3RhdGVOb2RlPXQsITApO2Nhc2UgNjpyZXR1cm4gbnVsbCE9PSh0PSIiPT09ZS5wZW5kaW5nUHJvcHN8fDMhPT10Lm5vZGVUeXBlP251bGw6dCkmJihlLnN0",
                    "YXRlTm9kZT10LCEwKTtjYXNlIDEzOmRlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIFNhKGUpe2lmKEVhKXt2YXIgdD14YTtpZih0KXt2YXIgbj10O2lmKCFrYShlLHQpKXtpZighKHQ9eG4obi5uZXh0U2libGluZykpfHwha2EoZSx0KSlyZXR1cm4gZS5lZmZlY3RUYWc9LTEwMjUmZS5lZmZlY3RUYWd8MixFYT0hMSx2b2lkKHdhPWUpO09hKHdhLG4pfXdhPWUseGE9eG4odC5maXJzdENoaWxkKX1lbHNlIGUuZWZmZWN0VGFnPS0xMDI1JmUuZWZmZWN0VGFnfDIsRWE9ITEsd2E9ZX19ZnVuY3Rpb24gQ2EoZSl7Zm9yKGU9ZS5yZXR1cm47bnVsbCE9PWUmJjUhPT1lLnRhZyYmMyE9PWUudGFnJiYxMyE9PWUudGFnOyllPWUucmV0dXJuO3dhPWV9ZnVuY3Rpb24gamEoZSl7aWYoZSE9PXdhKXJldHVybiExO2lmKCFFYSlyZXR1cm4gQ2EoZSksRWE9ITAsITE7dmFyIHQ9ZS50eXBlO2lmKDUhPT1lLnRhZ3x8ImhlYWQiIT09dCYmImJvZHkiIT09dCYmIXluKHQsZS5tZW1vaXplZFByb3BzKSlmb3IodD14YTt0OylPYShlLHQpLHQ9eG4odC5uZXh0U2libGluZyk7aWYoQ2EoZSksMTM9PT1lLnRhZyl7aWYoIShlPW51bGwhPT0oZT1lLm1lbW9pemVkU3RhdGUpP2UuZGVoeWRyYXRlZDpudWxsKSl0aHJvdyBFcnJvcihhKDMxNykpO2U6e2ZvcihlPWUubmV4dFNpYmxpbmcsdD0wO2U7KXtpZig4PT09ZS5ub2RlVHlwZSl7dmFyIG49ZS5kYXRhO2lmKCIvJCI9PT1uKXtpZigwPT09dCl7eGE9eG4oZS5uZXh0U2libGluZyk7YnJlYWsgZX10",
                    "LS19ZWxzZSIkIiE9PW4mJiIkISIhPT1uJiYiJD8iIT09bnx8dCsrfWU9ZS5uZXh0U2libGluZ314YT1udWxsfX1lbHNlIHhhPXdhP3huKGUuc3RhdGVOb2RlLm5leHRTaWJsaW5nKTpudWxsO3JldHVybiEwfWZ1bmN0aW9uIFRhKCl7eGE9d2E9bnVsbCxFYT0hMX12YXIgUGE9WC5SZWFjdEN1cnJlbnRPd25lcixSYT0hMTtmdW5jdGlvbiBOYShlLHQsbixyKXt0LmNoaWxkPW51bGw9PT1lP0NpKHQsbnVsbCxuLHIpOlNpKHQsZS5jaGlsZCxuLHIpfWZ1bmN0aW9uIE1hKGUsdCxuLHIsbyl7bj1uLnJlbmRlcjt2YXIgaT10LnJlZjtyZXR1cm4gcmkodCxvKSxyPVlpKGUsdCxuLHIsaSxvKSxudWxsPT09ZXx8UmE/KHQuZWZmZWN0VGFnfD0xLE5hKGUsdCxyLG8pLHQuY2hpbGQpOih0LnVwZGF0ZVF1ZXVlPWUudXBkYXRlUXVldWUsdC5lZmZlY3RUYWcmPS01MTcsZS5leHBpcmF0aW9uVGltZTw9byYmKGUuZXhwaXJhdGlvblRpbWU9MCksWWEoZSx0LG8pKX1mdW5jdGlvbiBfYShlLHQsbixyLG8saSl7aWYobnVsbD09PWUpe3ZhciBhPW4udHlwZTtyZXR1cm4iZnVuY3Rpb24iIT09dHlwZW9mIGF8fFN1KGEpfHx2b2lkIDAhPT1hLmRlZmF1bHRQcm9wc3x8bnVsbCE9PW4uY29tcGFyZXx8dm9pZCAwIT09bi5kZWZhdWx0UHJvcHM/KChlPWp1KG4udHlwZSxudWxsLHIsbnVsbCx0Lm1vZGUsaSkpLnJlZj10LnJlZixlLnJldHVybj10LHQuY2hpbGQ9ZSk6KHQudGFnPTE1LHQudHlwZT1hLEFhKGUsdCxhLHIsbyxpKSl9cmV0dXJuIGE9",
                    "ZS5jaGlsZCxvPGkmJihvPWEubWVtb2l6ZWRQcm9wcywobj1udWxsIT09KG49bi5jb21wYXJlKT9uOkZyKShvLHIpJiZlLnJlZj09PXQucmVmKT9ZYShlLHQsaSk6KHQuZWZmZWN0VGFnfD0xLChlPUN1KGEscikpLnJlZj10LnJlZixlLnJldHVybj10LHQuY2hpbGQ9ZSl9ZnVuY3Rpb24gQWEoZSx0LG4scixvLGkpe3JldHVybiBudWxsIT09ZSYmRnIoZS5tZW1vaXplZFByb3BzLHIpJiZlLnJlZj09PXQucmVmJiYoUmE9ITEsbzxpKT8odC5leHBpcmF0aW9uVGltZT1lLmV4cGlyYXRpb25UaW1lLFlhKGUsdCxpKSk6RGEoZSx0LG4scixpKX1mdW5jdGlvbiBJYShlLHQpe3ZhciBuPXQucmVmOyhudWxsPT09ZSYmbnVsbCE9PW58fG51bGwhPT1lJiZlLnJlZiE9PW4pJiYodC5lZmZlY3RUYWd8PTEyOCl9ZnVuY3Rpb24gRGEoZSx0LG4scixvKXt2YXIgaT12byhuKT9obzpmby5jdXJyZW50O3JldHVybiBpPW1vKHQsaSkscmkodCxvKSxuPVlpKGUsdCxuLHIsaSxvKSxudWxsPT09ZXx8UmE/KHQuZWZmZWN0VGFnfD0xLE5hKGUsdCxuLG8pLHQuY2hpbGQpOih0LnVwZGF0ZVF1ZXVlPWUudXBkYXRlUXVldWUsdC5lZmZlY3RUYWcmPS01MTcsZS5leHBpcmF0aW9uVGltZTw9byYmKGUuZXhwaXJhdGlvblRpbWU9MCksWWEoZSx0LG8pKX1mdW5jdGlvbiB6YShlLHQsbixyLG8pe2lmKHZvKG4pKXt2YXIgaT0hMDt3byh0KX1lbHNlIGk9ITE7aWYocmkodCxvKSxudWxsPT09dC5zdGF0ZU5vZGUpbnVsbCE9PWUmJihlLmFsdGVybmF0ZT1u",
                    "dWxsLHQuYWx0ZXJuYXRlPW51bGwsdC5lZmZlY3RUYWd8PTIpLHlpKHQsbixyKSx3aSh0LG4scixvKSxyPSEwO2Vsc2UgaWYobnVsbD09PWUpe3ZhciBhPXQuc3RhdGVOb2RlLGw9dC5tZW1vaXplZFByb3BzO2EucHJvcHM9bDt2YXIgdT1hLmNvbnRleHQscz1uLmNvbnRleHRUeXBlOyJvYmplY3QiPT09dHlwZW9mIHMmJm51bGwhPT1zP3M9b2kocyk6cz1tbyh0LHM9dm8obik/aG86Zm8uY3VycmVudCk7dmFyIGM9bi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsZD0iZnVuY3Rpb24iPT09dHlwZW9mIGN8fCJmdW5jdGlvbiI9PT10eXBlb2YgYS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtkfHwiZnVuY3Rpb24iIT09dHlwZW9mIGEuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJiJmdW5jdGlvbiIhPT10eXBlb2YgYS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwobCE9PXJ8fHUhPT1zKSYmZ2kodCxhLHIscyksaWk9ITE7dmFyIGY9dC5tZW1vaXplZFN0YXRlO2Euc3RhdGU9ZixkaSh0LHIsYSxvKSx1PXQubWVtb2l6ZWRTdGF0ZSxsIT09cnx8ZiE9PXV8fHBvLmN1cnJlbnR8fGlpPygiZnVuY3Rpb24iPT09dHlwZW9mIGMmJihtaSh0LG4sYyxyKSx1PXQubWVtb2l6ZWRTdGF0ZSksKGw9aWl8fGJpKHQsbixsLHIsZix1LHMpKT8oZHx8ImZ1bmN0aW9uIiE9PXR5cGVvZiBhLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJiJmdW5jdGlvbiIhPT10eXBlb2YgYS5jb21wb25lbnRXaWxsTW91bnR8fCgiZnVuY3Rp",
                    "b24iPT09dHlwZW9mIGEuY29tcG9uZW50V2lsbE1vdW50JiZhLmNvbXBvbmVudFdpbGxNb3VudCgpLCJmdW5jdGlvbiI9PT10eXBlb2YgYS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZhLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksImZ1bmN0aW9uIj09PXR5cGVvZiBhLmNvbXBvbmVudERpZE1vdW50JiYodC5lZmZlY3RUYWd8PTQpKTooImZ1bmN0aW9uIj09PXR5cGVvZiBhLmNvbXBvbmVudERpZE1vdW50JiYodC5lZmZlY3RUYWd8PTQpLHQubWVtb2l6ZWRQcm9wcz1yLHQubWVtb2l6ZWRTdGF0ZT11KSxhLnByb3BzPXIsYS5zdGF0ZT11LGEuY29udGV4dD1zLHI9bCk6KCJmdW5jdGlvbiI9PT10eXBlb2YgYS5jb21wb25lbnREaWRNb3VudCYmKHQuZWZmZWN0VGFnfD00KSxyPSExKX1lbHNlIGE9dC5zdGF0ZU5vZGUsbGkoZSx0KSxsPXQubWVtb2l6ZWRQcm9wcyxhLnByb3BzPXQudHlwZT09PXQuZWxlbWVudFR5cGU/bDpRbyh0LnR5cGUsbCksdT1hLmNvbnRleHQsIm9iamVjdCI9PT10eXBlb2Yocz1uLmNvbnRleHRUeXBlKSYmbnVsbCE9PXM/cz1vaShzKTpzPW1vKHQscz12byhuKT9obzpmby5jdXJyZW50KSwoZD0iZnVuY3Rpb24iPT09dHlwZW9mKGM9bi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpfHwiZnVuY3Rpb24iPT09dHlwZW9mIGEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpfHwiZnVuY3Rpb24iIT09dHlwZW9mIGEuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJiJmdW5jdGlvbiIh",
                    "PT10eXBlb2YgYS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwobCE9PXJ8fHUhPT1zKSYmZ2kodCxhLHIscyksaWk9ITEsdT10Lm1lbW9pemVkU3RhdGUsYS5zdGF0ZT11LGRpKHQscixhLG8pLGY9dC5tZW1vaXplZFN0YXRlLGwhPT1yfHx1IT09Znx8cG8uY3VycmVudHx8aWk/KCJmdW5jdGlvbiI9PT10eXBlb2YgYyYmKG1pKHQsbixjLHIpLGY9dC5tZW1vaXplZFN0YXRlKSwoYz1paXx8YmkodCxuLGwscix1LGYscykpPyhkfHwiZnVuY3Rpb24iIT09dHlwZW9mIGEuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJiJmdW5jdGlvbiIhPT10eXBlb2YgYS5jb21wb25lbnRXaWxsVXBkYXRlfHwoImZ1bmN0aW9uIj09PXR5cGVvZiBhLmNvbXBvbmVudFdpbGxVcGRhdGUmJmEuY29tcG9uZW50V2lsbFVwZGF0ZShyLGYscyksImZ1bmN0aW9uIj09PXR5cGVvZiBhLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZhLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKHIsZixzKSksImZ1bmN0aW9uIj09PXR5cGVvZiBhLmNvbXBvbmVudERpZFVwZGF0ZSYmKHQuZWZmZWN0VGFnfD00KSwiZnVuY3Rpb24iPT09dHlwZW9mIGEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJih0LmVmZmVjdFRhZ3w9MjU2KSk6KCJmdW5jdGlvbiIhPT10eXBlb2YgYS5jb21wb25lbnREaWRVcGRhdGV8fGw9PT1lLm1lbW9pemVkUHJvcHMmJnU9PT1lLm1lbW9pemVkU3RhdGV8fCh0LmVmZmVjdFRhZ3w9NCksImZ1bmN0aW9uIiE9PXR5cGVvZiBhLmdl",
                    "dFNuYXBzaG90QmVmb3JlVXBkYXRlfHxsPT09ZS5tZW1vaXplZFByb3BzJiZ1PT09ZS5tZW1vaXplZFN0YXRlfHwodC5lZmZlY3RUYWd8PTI1NiksdC5tZW1vaXplZFByb3BzPXIsdC5tZW1vaXplZFN0YXRlPWYpLGEucHJvcHM9cixhLnN0YXRlPWYsYS5jb250ZXh0PXMscj1jKTooImZ1bmN0aW9uIiE9PXR5cGVvZiBhLmNvbXBvbmVudERpZFVwZGF0ZXx8bD09PWUubWVtb2l6ZWRQcm9wcyYmdT09PWUubWVtb2l6ZWRTdGF0ZXx8KHQuZWZmZWN0VGFnfD00KSwiZnVuY3Rpb24iIT09dHlwZW9mIGEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGw9PT1lLm1lbW9pemVkUHJvcHMmJnU9PT1lLm1lbW9pemVkU3RhdGV8fCh0LmVmZmVjdFRhZ3w9MjU2KSxyPSExKTtyZXR1cm4gTGEoZSx0LG4scixpLG8pfWZ1bmN0aW9uIExhKGUsdCxuLHIsbyxpKXtJYShlLHQpO3ZhciBhPTAhPT0oNjQmdC5lZmZlY3RUYWcpO2lmKCFyJiYhYSlyZXR1cm4gbyYmeG8odCxuLCExKSxZYShlLHQsaSk7cj10LnN0YXRlTm9kZSxQYS5jdXJyZW50PXQ7dmFyIGw9YSYmImZ1bmN0aW9uIiE9PXR5cGVvZiBuLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj9udWxsOnIucmVuZGVyKCk7cmV0dXJuIHQuZWZmZWN0VGFnfD0xLG51bGwhPT1lJiZhPyh0LmNoaWxkPVNpKHQsZS5jaGlsZCxudWxsLGkpLHQuY2hpbGQ9U2kodCxudWxsLGwsaSkpOk5hKGUsdCxsLGkpLHQubWVtb2l6ZWRTdGF0ZT1yLnN0YXRlLG8mJnhvKHQsbiwhMCksdC5jaGlsZH1mdW5jdGlv",
                    "biBGYShlKXt2YXIgdD1lLnN0YXRlTm9kZTt0LnBlbmRpbmdDb250ZXh0P3lvKDAsdC5wZW5kaW5nQ29udGV4dCx0LnBlbmRpbmdDb250ZXh0IT09dC5jb250ZXh0KTp0LmNvbnRleHQmJnlvKDAsdC5jb250ZXh0LCExKSxNaShlLHQuY29udGFpbmVySW5mbyl9dmFyICRhLFdhLEJhLEhhPXtkZWh5ZHJhdGVkOm51bGwscmV0cnlUaW1lOjB9O2Z1bmN0aW9uIFZhKGUsdCxuKXt2YXIgcixvPXQubW9kZSxpPXQucGVuZGluZ1Byb3BzLGE9RGkuY3VycmVudCxsPSExO2lmKChyPTAhPT0oNjQmdC5lZmZlY3RUYWcpKXx8KHI9MCE9PSgyJmEpJiYobnVsbD09PWV8fG51bGwhPT1lLm1lbW9pemVkU3RhdGUpKSxyPyhsPSEwLHQuZWZmZWN0VGFnJj0tNjUpOm51bGwhPT1lJiZudWxsPT09ZS5tZW1vaXplZFN0YXRlfHx2b2lkIDA9PT1pLmZhbGxiYWNrfHwhMD09PWkudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2t8fChhfD0xKSxzbyhEaSwxJmEpLG51bGw9PT1lKXtpZih2b2lkIDAhPT1pLmZhbGxiYWNrJiZTYSh0KSxsKXtpZihsPWkuZmFsbGJhY2ssKGk9VHUobnVsbCxvLDAsbnVsbCkpLnJldHVybj10LDA9PT0oMiZ0Lm1vZGUpKWZvcihlPW51bGwhPT10Lm1lbW9pemVkU3RhdGU/dC5jaGlsZC5jaGlsZDp0LmNoaWxkLGkuY2hpbGQ9ZTtudWxsIT09ZTspZS5yZXR1cm49aSxlPWUuc2libGluZztyZXR1cm4obj1UdShsLG8sbixudWxsKSkucmV0dXJuPXQsaS5zaWJsaW5nPW4sdC5tZW1vaXplZFN0YXRlPUhhLHQuY2hpbGQ9aSxu",
                    "fXJldHVybiBvPWkuY2hpbGRyZW4sdC5tZW1vaXplZFN0YXRlPW51bGwsdC5jaGlsZD1DaSh0LG51bGwsbyxuKX1pZihudWxsIT09ZS5tZW1vaXplZFN0YXRlKXtpZihvPShlPWUuY2hpbGQpLnNpYmxpbmcsbCl7aWYoaT1pLmZhbGxiYWNrLChuPUN1KGUsZS5wZW5kaW5nUHJvcHMpKS5yZXR1cm49dCwwPT09KDImdC5tb2RlKSYmKGw9bnVsbCE9PXQubWVtb2l6ZWRTdGF0ZT90LmNoaWxkLmNoaWxkOnQuY2hpbGQpIT09ZS5jaGlsZClmb3Iobi5jaGlsZD1sO251bGwhPT1sOylsLnJldHVybj1uLGw9bC5zaWJsaW5nO3JldHVybihvPUN1KG8saSkpLnJldHVybj10LG4uc2libGluZz1vLG4uY2hpbGRFeHBpcmF0aW9uVGltZT0wLHQubWVtb2l6ZWRTdGF0ZT1IYSx0LmNoaWxkPW4sb31yZXR1cm4gbj1TaSh0LGUuY2hpbGQsaS5jaGlsZHJlbixuKSx0Lm1lbW9pemVkU3RhdGU9bnVsbCx0LmNoaWxkPW59aWYoZT1lLmNoaWxkLGwpe2lmKGw9aS5mYWxsYmFjaywoaT1UdShudWxsLG8sMCxudWxsKSkucmV0dXJuPXQsaS5jaGlsZD1lLG51bGwhPT1lJiYoZS5yZXR1cm49aSksMD09PSgyJnQubW9kZSkpZm9yKGU9bnVsbCE9PXQubWVtb2l6ZWRTdGF0ZT90LmNoaWxkLmNoaWxkOnQuY2hpbGQsaS5jaGlsZD1lO251bGwhPT1lOyllLnJldHVybj1pLGU9ZS5zaWJsaW5nO3JldHVybihuPVR1KGwsbyxuLG51bGwpKS5yZXR1cm49dCxpLnNpYmxpbmc9bixuLmVmZmVjdFRhZ3w9MixpLmNoaWxkRXhwaXJhdGlvblRpbWU9MCx0Lm1lbW9p",
                    "emVkU3RhdGU9SGEsdC5jaGlsZD1pLG59cmV0dXJuIHQubWVtb2l6ZWRTdGF0ZT1udWxsLHQuY2hpbGQ9U2kodCxlLGkuY2hpbGRyZW4sbil9ZnVuY3Rpb24gVWEoZSx0KXtlLmV4cGlyYXRpb25UaW1lPHQmJihlLmV4cGlyYXRpb25UaW1lPXQpO3ZhciBuPWUuYWx0ZXJuYXRlO251bGwhPT1uJiZuLmV4cGlyYXRpb25UaW1lPHQmJihuLmV4cGlyYXRpb25UaW1lPXQpLG5pKGUucmV0dXJuLHQpfWZ1bmN0aW9uIHFhKGUsdCxuLHIsbyxpKXt2YXIgYT1lLm1lbW9pemVkU3RhdGU7bnVsbD09PWE/ZS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczp0LHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6cix0YWlsOm4sdGFpbEV4cGlyYXRpb246MCx0YWlsTW9kZTpvLGxhc3RFZmZlY3Q6aX06KGEuaXNCYWNrd2FyZHM9dCxhLnJlbmRlcmluZz1udWxsLGEucmVuZGVyaW5nU3RhcnRUaW1lPTAsYS5sYXN0PXIsYS50YWlsPW4sYS50YWlsRXhwaXJhdGlvbj0wLGEudGFpbE1vZGU9byxhLmxhc3RFZmZlY3Q9aSl9ZnVuY3Rpb24gS2EoZSx0LG4pe3ZhciByPXQucGVuZGluZ1Byb3BzLG89ci5yZXZlYWxPcmRlcixpPXIudGFpbDtpZihOYShlLHQsci5jaGlsZHJlbixuKSwwIT09KDImKHI9RGkuY3VycmVudCkpKXI9MSZyfDIsdC5lZmZlY3RUYWd8PTY0O2Vsc2V7aWYobnVsbCE9PWUmJjAhPT0oNjQmZS5lZmZlY3RUYWcpKWU6Zm9yKGU9dC5jaGlsZDtudWxsIT09ZTspe2lmKDEzPT09ZS50YWcpbnVsbCE9PWUu",
                    "bWVtb2l6ZWRTdGF0ZSYmVWEoZSxuKTtlbHNlIGlmKDE5PT09ZS50YWcpVWEoZSxuKTtlbHNlIGlmKG51bGwhPT1lLmNoaWxkKXtlLmNoaWxkLnJldHVybj1lLGU9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09dClicmVhayBlO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lLnJldHVybnx8ZS5yZXR1cm49PT10KWJyZWFrIGU7ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nfXImPTF9aWYoc28oRGksciksMD09PSgyJnQubW9kZSkpdC5tZW1vaXplZFN0YXRlPW51bGw7ZWxzZSBzd2l0Y2gobyl7Y2FzZSJmb3J3YXJkcyI6Zm9yKG49dC5jaGlsZCxvPW51bGw7bnVsbCE9PW47KW51bGwhPT0oZT1uLmFsdGVybmF0ZSkmJm51bGw9PT16aShlKSYmKG89biksbj1uLnNpYmxpbmc7bnVsbD09PShuPW8pPyhvPXQuY2hpbGQsdC5jaGlsZD1udWxsKToobz1uLnNpYmxpbmcsbi5zaWJsaW5nPW51bGwpLHFhKHQsITEsbyxuLGksdC5sYXN0RWZmZWN0KTticmVhaztjYXNlImJhY2t3YXJkcyI6Zm9yKG49bnVsbCxvPXQuY2hpbGQsdC5jaGlsZD1udWxsO251bGwhPT1vOyl7aWYobnVsbCE9PShlPW8uYWx0ZXJuYXRlKSYmbnVsbD09PXppKGUpKXt0LmNoaWxkPW87YnJlYWt9ZT1vLnNpYmxpbmcsby5zaWJsaW5nPW4sbj1vLG89ZX1xYSh0LCEwLG4sbnVsbCxpLHQubGFzdEVmZmVjdCk7YnJlYWs7Y2FzZSJ0b2dldGhlciI6cWEodCwhMSxudWxsLG51bGwsdm9pZCAwLHQubGFzdEVmZmVj",
                    "dCk7YnJlYWs7ZGVmYXVsdDp0Lm1lbW9pemVkU3RhdGU9bnVsbH1yZXR1cm4gdC5jaGlsZH1mdW5jdGlvbiBZYShlLHQsbil7bnVsbCE9PWUmJih0LmRlcGVuZGVuY2llcz1lLmRlcGVuZGVuY2llcyk7dmFyIHI9dC5leHBpcmF0aW9uVGltZTtpZigwIT09ciYmYXUociksdC5jaGlsZEV4cGlyYXRpb25UaW1lPG4pcmV0dXJuIG51bGw7aWYobnVsbCE9PWUmJnQuY2hpbGQhPT1lLmNoaWxkKXRocm93IEVycm9yKGEoMTUzKSk7aWYobnVsbCE9PXQuY2hpbGQpe2ZvcihuPUN1KGU9dC5jaGlsZCxlLnBlbmRpbmdQcm9wcyksdC5jaGlsZD1uLG4ucmV0dXJuPXQ7bnVsbCE9PWUuc2libGluZzspZT1lLnNpYmxpbmcsKG49bi5zaWJsaW5nPUN1KGUsZS5wZW5kaW5nUHJvcHMpKS5yZXR1cm49dDtuLnNpYmxpbmc9bnVsbH1yZXR1cm4gdC5jaGlsZH1mdW5jdGlvbiBRYShlLHQpe3N3aXRjaChlLnRhaWxNb2RlKXtjYXNlImhpZGRlbiI6dD1lLnRhaWw7Zm9yKHZhciBuPW51bGw7bnVsbCE9PXQ7KW51bGwhPT10LmFsdGVybmF0ZSYmKG49dCksdD10LnNpYmxpbmc7bnVsbD09PW4/ZS50YWlsPW51bGw6bi5zaWJsaW5nPW51bGw7YnJlYWs7Y2FzZSJjb2xsYXBzZWQiOm49ZS50YWlsO2Zvcih2YXIgcj1udWxsO251bGwhPT1uOyludWxsIT09bi5hbHRlcm5hdGUmJihyPW4pLG49bi5zaWJsaW5nO251bGw9PT1yP3R8fG51bGw9PT1lLnRhaWw/ZS50YWlsPW51bGw6ZS50YWlsLnNpYmxpbmc9bnVsbDpyLnNpYmxpbmc9bnVsbH19ZnVuY3Rp",
                    "b24gWGEoZSx0LG4pe3ZhciByPXQucGVuZGluZ1Byb3BzO3N3aXRjaCh0LnRhZyl7Y2FzZSAyOmNhc2UgMTY6Y2FzZSAxNTpjYXNlIDA6Y2FzZSAxMTpjYXNlIDc6Y2FzZSA4OmNhc2UgMTI6Y2FzZSA5OmNhc2UgMTQ6cmV0dXJuIG51bGw7Y2FzZSAxOnJldHVybiB2byh0LnR5cGUpJiZibygpLG51bGw7Y2FzZSAzOnJldHVybiBfaSgpLHVvKHBvKSx1byhmbyksKG49dC5zdGF0ZU5vZGUpLnBlbmRpbmdDb250ZXh0JiYobi5jb250ZXh0PW4ucGVuZGluZ0NvbnRleHQsbi5wZW5kaW5nQ29udGV4dD1udWxsKSxudWxsIT09ZSYmbnVsbCE9PWUuY2hpbGR8fCFqYSh0KXx8KHQuZWZmZWN0VGFnfD00KSxudWxsO2Nhc2UgNTpJaSh0KSxuPU5pKFJpLmN1cnJlbnQpO3ZhciBpPXQudHlwZTtpZihudWxsIT09ZSYmbnVsbCE9dC5zdGF0ZU5vZGUpV2EoZSx0LGkscixuKSxlLnJlZiE9PXQucmVmJiYodC5lZmZlY3RUYWd8PTEyOCk7ZWxzZXtpZighcil7aWYobnVsbD09PXQuc3RhdGVOb2RlKXRocm93IEVycm9yKGEoMTY2KSk7cmV0dXJuIG51bGx9aWYoZT1OaShUaS5jdXJyZW50KSxqYSh0KSl7cj10LnN0YXRlTm9kZSxpPXQudHlwZTt2YXIgbD10Lm1lbW9pemVkUHJvcHM7c3dpdGNoKHJba25dPXQscltTbl09bCxpKXtjYXNlImlmcmFtZSI6Y2FzZSJvYmplY3QiOmNhc2UiZW1iZWQiOkt0KCJsb2FkIixyKTticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3IoZT0wO2U8WGUubGVuZ3RoO2UrKylLdChYZVtlXSxyKTticmVh",
                    "aztjYXNlInNvdXJjZSI6S3QoImVycm9yIixyKTticmVhaztjYXNlImltZyI6Y2FzZSJpbWFnZSI6Y2FzZSJsaW5rIjpLdCgiZXJyb3IiLHIpLEt0KCJsb2FkIixyKTticmVhaztjYXNlImZvcm0iOkt0KCJyZXNldCIsciksS3QoInN1Ym1pdCIscik7YnJlYWs7Y2FzZSJkZXRhaWxzIjpLdCgidG9nZ2xlIixyKTticmVhaztjYXNlImlucHV0IjpPZShyLGwpLEt0KCJpbnZhbGlkIixyKSx1bihuLCJvbkNoYW5nZSIpO2JyZWFrO2Nhc2Uic2VsZWN0IjpyLl93cmFwcGVyU3RhdGU9e3dhc011bHRpcGxlOiEhbC5tdWx0aXBsZX0sS3QoImludmFsaWQiLHIpLHVuKG4sIm9uQ2hhbmdlIik7YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6TmUocixsKSxLdCgiaW52YWxpZCIsciksdW4obiwib25DaGFuZ2UiKX1mb3IodmFyIHUgaW4gb24oaSxsKSxlPW51bGwsbClpZihsLmhhc093blByb3BlcnR5KHUpKXt2YXIgcz1sW3VdOyJjaGlsZHJlbiI9PT11PyJzdHJpbmciPT09dHlwZW9mIHM/ci50ZXh0Q29udGVudCE9PXMmJihlPVsiY2hpbGRyZW4iLHNdKToibnVtYmVyIj09PXR5cGVvZiBzJiZyLnRleHRDb250ZW50IT09IiIrcyYmKGU9WyJjaGlsZHJlbiIsIiIrc10pOmsuaGFzT3duUHJvcGVydHkodSkmJm51bGwhPXMmJnVuKG4sdSl9c3dpdGNoKGkpe2Nhc2UiaW5wdXQiOndlKHIpLENlKHIsbCwhMCk7YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6d2UociksX2Uocik7YnJlYWs7Y2FzZSJzZWxlY3QiOmNhc2Uib3B0aW9uIjpicmVhaztkZWZhdWx0",
                    "OiJmdW5jdGlvbiI9PT10eXBlb2YgbC5vbkNsaWNrJiYoci5vbmNsaWNrPXNuKX1uPWUsdC51cGRhdGVRdWV1ZT1uLG51bGwhPT1uJiYodC5lZmZlY3RUYWd8PTQpfWVsc2V7c3dpdGNoKHU9OT09PW4ubm9kZVR5cGU/bjpuLm93bmVyRG9jdW1lbnQsZT09PWxuJiYoZT1EZShpKSksZT09PWxuPyJzY3JpcHQiPT09aT8oKGU9dS5jcmVhdGVFbGVtZW50KCJkaXYiKSkuaW5uZXJIVE1MPSI8c2NyaXB0PjxcL3NjcmlwdD4iLGU9ZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpKToic3RyaW5nIj09PXR5cGVvZiByLmlzP2U9dS5jcmVhdGVFbGVtZW50KGkse2lzOnIuaXN9KTooZT11LmNyZWF0ZUVsZW1lbnQoaSksInNlbGVjdCI9PT1pJiYodT1lLHIubXVsdGlwbGU/dS5tdWx0aXBsZT0hMDpyLnNpemUmJih1LnNpemU9ci5zaXplKSkpOmU9dS5jcmVhdGVFbGVtZW50TlMoZSxpKSxlW2tuXT10LGVbU25dPXIsJGEoZSx0KSx0LnN0YXRlTm9kZT1lLHU9YW4oaSxyKSxpKXtjYXNlImlmcmFtZSI6Y2FzZSJvYmplY3QiOmNhc2UiZW1iZWQiOkt0KCJsb2FkIixlKSxzPXI7YnJlYWs7Y2FzZSJ2aWRlbyI6Y2FzZSJhdWRpbyI6Zm9yKHM9MDtzPFhlLmxlbmd0aDtzKyspS3QoWGVbc10sZSk7cz1yO2JyZWFrO2Nhc2Uic291cmNlIjpLdCgiZXJyb3IiLGUpLHM9cjticmVhaztjYXNlImltZyI6Y2FzZSJpbWFnZSI6Y2FzZSJsaW5rIjpLdCgiZXJyb3IiLGUpLEt0KCJsb2FkIixlKSxzPXI7YnJlYWs7Y2FzZSJmb3JtIjpLdCgicmVzZXQi",
                    "LGUpLEt0KCJzdWJtaXQiLGUpLHM9cjticmVhaztjYXNlImRldGFpbHMiOkt0KCJ0b2dnbGUiLGUpLHM9cjticmVhaztjYXNlImlucHV0IjpPZShlLHIpLHM9RWUoZSxyKSxLdCgiaW52YWxpZCIsZSksdW4obiwib25DaGFuZ2UiKTticmVhaztjYXNlIm9wdGlvbiI6cz1UZShlLHIpO2JyZWFrO2Nhc2Uic2VsZWN0IjplLl93cmFwcGVyU3RhdGU9e3dhc011bHRpcGxlOiEhci5tdWx0aXBsZX0scz1vKHt9LHIse3ZhbHVlOnZvaWQgMH0pLEt0KCJpbnZhbGlkIixlKSx1bihuLCJvbkNoYW5nZSIpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOk5lKGUscikscz1SZShlLHIpLEt0KCJpbnZhbGlkIixlKSx1bihuLCJvbkNoYW5nZSIpO2JyZWFrO2RlZmF1bHQ6cz1yfW9uKGkscyk7dmFyIGM9cztmb3IobCBpbiBjKWlmKGMuaGFzT3duUHJvcGVydHkobCkpe3ZhciBkPWNbbF07InN0eWxlIj09PWw/bm4oZSxkKToiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09bD9udWxsIT0oZD1kP2QuX19odG1sOnZvaWQgMCkmJkZlKGUsZCk6ImNoaWxkcmVuIj09PWw/InN0cmluZyI9PT10eXBlb2YgZD8oInRleHRhcmVhIiE9PWl8fCIiIT09ZCkmJiRlKGUsZCk6Im51bWJlciI9PT10eXBlb2YgZCYmJGUoZSwiIitkKToic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiE9PWwmJiJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciIT09bCYmImF1dG9Gb2N1cyIhPT1sJiYoay5oYXNPd25Qcm9wZXJ0eShsKT9udWxsIT1kJiZ1bihuLGwpOm51bGwh",
                    "PWQmJkcoZSxsLGQsdSkpfXN3aXRjaChpKXtjYXNlImlucHV0Ijp3ZShlKSxDZShlLHIsITEpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOndlKGUpLF9lKGUpO2JyZWFrO2Nhc2Uib3B0aW9uIjpudWxsIT1yLnZhbHVlJiZlLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIiK3llKHIudmFsdWUpKTticmVhaztjYXNlInNlbGVjdCI6ZS5tdWx0aXBsZT0hIXIubXVsdGlwbGUsbnVsbCE9KG49ci52YWx1ZSk/UGUoZSwhIXIubXVsdGlwbGUsbiwhMSk6bnVsbCE9ci5kZWZhdWx0VmFsdWUmJlBlKGUsISFyLm11bHRpcGxlLHIuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OiJmdW5jdGlvbiI9PT10eXBlb2Ygcy5vbkNsaWNrJiYoZS5vbmNsaWNrPXNuKX1ibihpLHIpJiYodC5lZmZlY3RUYWd8PTQpfW51bGwhPT10LnJlZiYmKHQuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihlJiZudWxsIT10LnN0YXRlTm9kZSlCYSgwLHQsZS5tZW1vaXplZFByb3BzLHIpO2Vsc2V7aWYoInN0cmluZyIhPT10eXBlb2YgciYmbnVsbD09PXQuc3RhdGVOb2RlKXRocm93IEVycm9yKGEoMTY2KSk7bj1OaShSaS5jdXJyZW50KSxOaShUaS5jdXJyZW50KSxqYSh0KT8obj10LnN0YXRlTm9kZSxyPXQubWVtb2l6ZWRQcm9wcyxuW2tuXT10LG4ubm9kZVZhbHVlIT09ciYmKHQuZWZmZWN0VGFnfD00KSk6KChuPSg5PT09bi5ub2RlVHlwZT9uOm4ub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUocikpW2tuXT10LHQuc3RhdGVOb2Rl",
                    "PW4pfXJldHVybiBudWxsO2Nhc2UgMTM6cmV0dXJuIHVvKERpKSxyPXQubWVtb2l6ZWRTdGF0ZSwwIT09KDY0JnQuZWZmZWN0VGFnKT8odC5leHBpcmF0aW9uVGltZT1uLHQpOihuPW51bGwhPT1yLHI9ITEsbnVsbD09PWU/dm9pZCAwIT09dC5tZW1vaXplZFByb3BzLmZhbGxiYWNrJiZqYSh0KToocj1udWxsIT09KGk9ZS5tZW1vaXplZFN0YXRlKSxufHxudWxsPT09aXx8bnVsbCE9PShpPWUuY2hpbGQuc2libGluZykmJihudWxsIT09KGw9dC5maXJzdEVmZmVjdCk/KHQuZmlyc3RFZmZlY3Q9aSxpLm5leHRFZmZlY3Q9bCk6KHQuZmlyc3RFZmZlY3Q9dC5sYXN0RWZmZWN0PWksaS5uZXh0RWZmZWN0PW51bGwpLGkuZWZmZWN0VGFnPTgpKSxuJiYhciYmMCE9PSgyJnQubW9kZSkmJihudWxsPT09ZSYmITAhPT10Lm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2t8fDAhPT0oMSZEaS5jdXJyZW50KT9qbD09PXdsJiYoamw9eGwpOihqbCE9PXdsJiZqbCE9PXhsfHwoamw9RWwpLDAhPT1NbCYmbnVsbCE9PWtsJiYoX3Uoa2wsQ2wpLEF1KGtsLE1sKSkpKSwobnx8cikmJih0LmVmZmVjdFRhZ3w9NCksbnVsbCk7Y2FzZSA0OnJldHVybiBfaSgpLG51bGw7Y2FzZSAxMDpyZXR1cm4gdGkodCksbnVsbDtjYXNlIDE3OnJldHVybiB2byh0LnR5cGUpJiZibygpLG51bGw7Y2FzZSAxOTppZih1byhEaSksbnVsbD09PShyPXQubWVtb2l6ZWRTdGF0ZSkpcmV0dXJuIG51bGw7aWYoaT0wIT09KDY0JnQuZWZmZWN0VGFn",
                    "KSxudWxsPT09KGw9ci5yZW5kZXJpbmcpKXtpZihpKVFhKHIsITEpO2Vsc2UgaWYoamwhPT13bHx8bnVsbCE9PWUmJjAhPT0oNjQmZS5lZmZlY3RUYWcpKWZvcihsPXQuY2hpbGQ7bnVsbCE9PWw7KXtpZihudWxsIT09KGU9emkobCkpKXtmb3IodC5lZmZlY3RUYWd8PTY0LFFhKHIsITEpLG51bGwhPT0oaT1lLnVwZGF0ZVF1ZXVlKSYmKHQudXBkYXRlUXVldWU9aSx0LmVmZmVjdFRhZ3w9NCksbnVsbD09PXIubGFzdEVmZmVjdCYmKHQuZmlyc3RFZmZlY3Q9bnVsbCksdC5sYXN0RWZmZWN0PXIubGFzdEVmZmVjdCxyPXQuY2hpbGQ7bnVsbCE9PXI7KWw9biwoaT1yKS5lZmZlY3RUYWcmPTIsaS5uZXh0RWZmZWN0PW51bGwsaS5maXJzdEVmZmVjdD1udWxsLGkubGFzdEVmZmVjdD1udWxsLG51bGw9PT0oZT1pLmFsdGVybmF0ZSk/KGkuY2hpbGRFeHBpcmF0aW9uVGltZT0wLGkuZXhwaXJhdGlvblRpbWU9bCxpLmNoaWxkPW51bGwsaS5tZW1vaXplZFByb3BzPW51bGwsaS5tZW1vaXplZFN0YXRlPW51bGwsaS51cGRhdGVRdWV1ZT1udWxsLGkuZGVwZW5kZW5jaWVzPW51bGwpOihpLmNoaWxkRXhwaXJhdGlvblRpbWU9ZS5jaGlsZEV4cGlyYXRpb25UaW1lLGkuZXhwaXJhdGlvblRpbWU9ZS5leHBpcmF0aW9uVGltZSxpLmNoaWxkPWUuY2hpbGQsaS5tZW1vaXplZFByb3BzPWUubWVtb2l6ZWRQcm9wcyxpLm1lbW9pemVkU3RhdGU9ZS5tZW1vaXplZFN0YXRlLGkudXBkYXRlUXVldWU9ZS51cGRhdGVRdWV1ZSxsPWUuZGVwZW5kZW5j",
                    "aWVzLGkuZGVwZW5kZW5jaWVzPW51bGw9PT1sP251bGw6e2V4cGlyYXRpb25UaW1lOmwuZXhwaXJhdGlvblRpbWUsZmlyc3RDb250ZXh0OmwuZmlyc3RDb250ZXh0LHJlc3BvbmRlcnM6bC5yZXNwb25kZXJzfSkscj1yLnNpYmxpbmc7cmV0dXJuIHNvKERpLDEmRGkuY3VycmVudHwyKSx0LmNoaWxkfWw9bC5zaWJsaW5nfX1lbHNle2lmKCFpKWlmKG51bGwhPT0oZT16aShsKSkpe2lmKHQuZWZmZWN0VGFnfD02NCxpPSEwLG51bGwhPT0obj1lLnVwZGF0ZVF1ZXVlKSYmKHQudXBkYXRlUXVldWU9bix0LmVmZmVjdFRhZ3w9NCksUWEociwhMCksbnVsbD09PXIudGFpbCYmImhpZGRlbiI9PT1yLnRhaWxNb2RlJiYhbC5hbHRlcm5hdGUpcmV0dXJuIG51bGwhPT0odD10Lmxhc3RFZmZlY3Q9ci5sYXN0RWZmZWN0KSYmKHQubmV4dEVmZmVjdD1udWxsKSxudWxsfWVsc2UgMiokbygpLXIucmVuZGVyaW5nU3RhcnRUaW1lPnIudGFpbEV4cGlyYXRpb24mJjE8biYmKHQuZWZmZWN0VGFnfD02NCxpPSEwLFFhKHIsITEpLHQuZXhwaXJhdGlvblRpbWU9dC5jaGlsZEV4cGlyYXRpb25UaW1lPW4tMSk7ci5pc0JhY2t3YXJkcz8obC5zaWJsaW5nPXQuY2hpbGQsdC5jaGlsZD1sKToobnVsbCE9PShuPXIubGFzdCk/bi5zaWJsaW5nPWw6dC5jaGlsZD1sLHIubGFzdD1sKX1yZXR1cm4gbnVsbCE9PXIudGFpbD8oMD09PXIudGFpbEV4cGlyYXRpb24mJihyLnRhaWxFeHBpcmF0aW9uPSRvKCkrNTAwKSxuPXIudGFpbCxyLnJlbmRlcmluZz1uLHIu",
                    "dGFpbD1uLnNpYmxpbmcsci5sYXN0RWZmZWN0PXQubGFzdEVmZmVjdCxyLnJlbmRlcmluZ1N0YXJ0VGltZT0kbygpLG4uc2libGluZz1udWxsLHQ9RGkuY3VycmVudCxzbyhEaSxpPzEmdHwyOjEmdCksbik6bnVsbH10aHJvdyBFcnJvcihhKDE1Nix0LnRhZykpfWZ1bmN0aW9uIEdhKGUpe3N3aXRjaChlLnRhZyl7Y2FzZSAxOnZvKGUudHlwZSkmJmJvKCk7dmFyIHQ9ZS5lZmZlY3RUYWc7cmV0dXJuIDQwOTYmdD8oZS5lZmZlY3RUYWc9LTQwOTcmdHw2NCxlKTpudWxsO2Nhc2UgMzppZihfaSgpLHVvKHBvKSx1byhmbyksMCE9PSg2NCYodD1lLmVmZmVjdFRhZykpKXRocm93IEVycm9yKGEoMjg1KSk7cmV0dXJuIGUuZWZmZWN0VGFnPS00MDk3JnR8NjQsZTtjYXNlIDU6cmV0dXJuIElpKGUpLG51bGw7Y2FzZSAxMzpyZXR1cm4gdW8oRGkpLDQwOTYmKHQ9ZS5lZmZlY3RUYWcpPyhlLmVmZmVjdFRhZz0tNDA5NyZ0fDY0LGUpOm51bGw7Y2FzZSAxOTpyZXR1cm4gdW8oRGkpLG51bGw7Y2FzZSA0OnJldHVybiBfaSgpLG51bGw7Y2FzZSAxMDpyZXR1cm4gdGkoZSksbnVsbDtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBKYShlLHQpe3JldHVybnt2YWx1ZTplLHNvdXJjZTp0LHN0YWNrOmJlKHQpfX0kYT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10LmNoaWxkO251bGwhPT1uOyl7aWYoNT09PW4udGFnfHw2PT09bi50YWcpZS5hcHBlbmRDaGlsZChuLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09bi50YWcmJm51bGwhPT1uLmNo",
                    "aWxkKXtuLmNoaWxkLnJldHVybj1uLG49bi5jaGlsZDtjb250aW51ZX1pZihuPT09dClicmVhaztmb3IoO251bGw9PT1uLnNpYmxpbmc7KXtpZihudWxsPT09bi5yZXR1cm58fG4ucmV0dXJuPT09dClyZXR1cm47bj1uLnJldHVybn1uLnNpYmxpbmcucmV0dXJuPW4ucmV0dXJuLG49bi5zaWJsaW5nfX0sV2E9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgYT1lLm1lbW9pemVkUHJvcHM7aWYoYSE9PXIpe3ZhciBsLHUscz10LnN0YXRlTm9kZTtzd2l0Y2goTmkoVGkuY3VycmVudCksZT1udWxsLG4pe2Nhc2UiaW5wdXQiOmE9RWUocyxhKSxyPUVlKHMsciksZT1bXTticmVhaztjYXNlIm9wdGlvbiI6YT1UZShzLGEpLHI9VGUocyxyKSxlPVtdO2JyZWFrO2Nhc2Uic2VsZWN0IjphPW8oe30sYSx7dmFsdWU6dm9pZCAwfSkscj1vKHt9LHIse3ZhbHVlOnZvaWQgMH0pLGU9W107YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6YT1SZShzLGEpLHI9UmUocyxyKSxlPVtdO2JyZWFrO2RlZmF1bHQ6ImZ1bmN0aW9uIiE9PXR5cGVvZiBhLm9uQ2xpY2smJiJmdW5jdGlvbiI9PT10eXBlb2Ygci5vbkNsaWNrJiYocy5vbmNsaWNrPXNuKX1mb3IobCBpbiBvbihuLHIpLG49bnVsbCxhKWlmKCFyLmhhc093blByb3BlcnR5KGwpJiZhLmhhc093blByb3BlcnR5KGwpJiZudWxsIT1hW2xdKWlmKCJzdHlsZSI9PT1sKWZvcih1IGluIHM9YVtsXSlzLmhhc093blByb3BlcnR5KHUpJiYobnx8KG49e30pLG5bdV09IiIpO2Vsc2UiZGFuZ2Vyb3VzbHlTZXRJbm5l",
                    "ckhUTUwiIT09bCYmImNoaWxkcmVuIiE9PWwmJiJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciIT09bCYmInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIhPT1sJiYiYXV0b0ZvY3VzIiE9PWwmJihrLmhhc093blByb3BlcnR5KGwpP2V8fChlPVtdKTooZT1lfHxbXSkucHVzaChsLG51bGwpKTtmb3IobCBpbiByKXt2YXIgYz1yW2xdO2lmKHM9bnVsbCE9YT9hW2xdOnZvaWQgMCxyLmhhc093blByb3BlcnR5KGwpJiZjIT09cyYmKG51bGwhPWN8fG51bGwhPXMpKWlmKCJzdHlsZSI9PT1sKWlmKHMpe2Zvcih1IGluIHMpIXMuaGFzT3duUHJvcGVydHkodSl8fGMmJmMuaGFzT3duUHJvcGVydHkodSl8fChufHwobj17fSksblt1XT0iIik7Zm9yKHUgaW4gYyljLmhhc093blByb3BlcnR5KHUpJiZzW3VdIT09Y1t1XSYmKG58fChuPXt9KSxuW3VdPWNbdV0pfWVsc2Ugbnx8KGV8fChlPVtdKSxlLnB1c2gobCxuKSksbj1jO2Vsc2UiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09bD8oYz1jP2MuX19odG1sOnZvaWQgMCxzPXM/cy5fX2h0bWw6dm9pZCAwLG51bGwhPWMmJnMhPT1jJiYoZT1lfHxbXSkucHVzaChsLGMpKToiY2hpbGRyZW4iPT09bD9zPT09Y3x8InN0cmluZyIhPT10eXBlb2YgYyYmIm51bWJlciIhPT10eXBlb2YgY3x8KGU9ZXx8W10pLnB1c2gobCwiIitjKToic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiE9PWwmJiJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciIT09bCYmKGsuaGFzT3duUHJvcGVy",
                    "dHkobCk/KG51bGwhPWMmJnVuKGksbCksZXx8cz09PWN8fChlPVtdKSk6KGU9ZXx8W10pLnB1c2gobCxjKSl9biYmKGU9ZXx8W10pLnB1c2goInN0eWxlIixuKSxpPWUsKHQudXBkYXRlUXVldWU9aSkmJih0LmVmZmVjdFRhZ3w9NCl9fSxCYT1mdW5jdGlvbihlLHQsbixyKXtuIT09ciYmKHQuZWZmZWN0VGFnfD00KX07dmFyIFphPSJmdW5jdGlvbiI9PT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldDtmdW5jdGlvbiBlbChlLHQpe3ZhciBuPXQuc291cmNlLHI9dC5zdGFjaztudWxsPT09ciYmbnVsbCE9PW4mJihyPWJlKG4pKSxudWxsIT09biYmdmUobi50eXBlKSx0PXQudmFsdWUsbnVsbCE9PWUmJjE9PT1lLnRhZyYmdmUoZS50eXBlKTt0cnl7Y29uc29sZS5lcnJvcih0KX1jYXRjaChvKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Rocm93IG99KSl9fWZ1bmN0aW9uIHRsKGUpe3ZhciB0PWUucmVmO2lmKG51bGwhPT10KWlmKCJmdW5jdGlvbiI9PT10eXBlb2YgdCl0cnl7dChudWxsKX1jYXRjaChuKXt5dShlLG4pfWVsc2UgdC5jdXJyZW50PW51bGx9ZnVuY3Rpb24gbmwoZSx0KXtzd2l0Y2godC50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6Y2FzZSAyMjpyZXR1cm47Y2FzZSAxOmlmKDI1NiZ0LmVmZmVjdFRhZyYmbnVsbCE9PWUpe3ZhciBuPWUubWVtb2l6ZWRQcm9wcyxyPWUubWVtb2l6ZWRTdGF0ZTt0PShlPXQuc3RhdGVOb2RlKS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSh0LmVsZW1lbnRUeXBlPT09dC50eXBl",
                    "P246UW8odC50eXBlLG4pLHIpLGUuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9dH1yZXR1cm47Y2FzZSAzOmNhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKGEoMTYzKSl9ZnVuY3Rpb24gcmwoZSx0KXtpZihudWxsIT09KHQ9bnVsbCE9PSh0PXQudXBkYXRlUXVldWUpP3QubGFzdEVmZmVjdDpudWxsKSl7dmFyIG49dD10Lm5leHQ7ZG97aWYoKG4udGFnJmUpPT09ZSl7dmFyIHI9bi5kZXN0cm95O24uZGVzdHJveT12b2lkIDAsdm9pZCAwIT09ciYmcigpfW49bi5uZXh0fXdoaWxlKG4hPT10KX19ZnVuY3Rpb24gb2woZSx0KXtpZihudWxsIT09KHQ9bnVsbCE9PSh0PXQudXBkYXRlUXVldWUpP3QubGFzdEVmZmVjdDpudWxsKSl7dmFyIG49dD10Lm5leHQ7ZG97aWYoKG4udGFnJmUpPT09ZSl7dmFyIHI9bi5jcmVhdGU7bi5kZXN0cm95PXIoKX1uPW4ubmV4dH13aGlsZShuIT09dCl9fWZ1bmN0aW9uIGlsKGUsdCxuKXtzd2l0Y2gobi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6Y2FzZSAyMjpyZXR1cm4gdm9pZCBvbCgzLG4pO2Nhc2UgMTppZihlPW4uc3RhdGVOb2RlLDQmbi5lZmZlY3RUYWcpaWYobnVsbD09PXQpZS5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIHI9bi5lbGVtZW50VHlwZT09PW4udHlwZT90Lm1lbW9pemVkUHJvcHM6UW8obi50eXBlLHQubWVtb2l6ZWRQcm9wcyk7ZS5jb21wb25lbnREaWRVcGRhdGUocix0Lm1lbW9pemVkU3RhdGUsZS5f",
                    "X3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9cmV0dXJuIHZvaWQobnVsbCE9PSh0PW4udXBkYXRlUXVldWUpJiZmaShuLHQsZSkpO2Nhc2UgMzppZihudWxsIT09KHQ9bi51cGRhdGVRdWV1ZSkpe2lmKGU9bnVsbCxudWxsIT09bi5jaGlsZClzd2l0Y2gobi5jaGlsZC50YWcpe2Nhc2UgNTplPW4uY2hpbGQuc3RhdGVOb2RlO2JyZWFrO2Nhc2UgMTplPW4uY2hpbGQuc3RhdGVOb2RlfWZpKG4sdCxlKX1yZXR1cm47Y2FzZSA1OnJldHVybiBlPW4uc3RhdGVOb2RlLHZvaWQobnVsbD09PXQmJjQmbi5lZmZlY3RUYWcmJmJuKG4udHlwZSxuLm1lbW9pemVkUHJvcHMpJiZlLmZvY3VzKCkpO2Nhc2UgNjpjYXNlIDQ6Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpyZXR1cm4gdm9pZChudWxsPT09bi5tZW1vaXplZFN0YXRlJiYobj1uLmFsdGVybmF0ZSxudWxsIT09biYmKG49bi5tZW1vaXplZFN0YXRlLG51bGwhPT1uJiYobj1uLmRlaHlkcmF0ZWQsbnVsbCE9PW4mJkR0KG4pKSkpKTtjYXNlIDE5OmNhc2UgMTc6Y2FzZSAyMDpjYXNlIDIxOnJldHVybn10aHJvdyBFcnJvcihhKDE2MykpfWZ1bmN0aW9uIGFsKGUsdCxuKXtzd2l0Y2goImZ1bmN0aW9uIj09PXR5cGVvZiBFdSYmRXUodCksdC50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTpjYXNlIDIyOmlmKG51bGwhPT0oZT10LnVwZGF0ZVF1ZXVlKSYmbnVsbCE9PShlPWUubGFzdEVmZmVjdCkpe3ZhciByPWUubmV4dDtIbyg5NzxuPzk3Om4sKGZ1bmN0",
                    "aW9uKCl7dmFyIGU9cjtkb3t2YXIgbj1lLmRlc3Ryb3k7aWYodm9pZCAwIT09bil7dmFyIG89dDt0cnl7bigpfWNhdGNoKGkpe3l1KG8saSl9fWU9ZS5uZXh0fXdoaWxlKGUhPT1yKX0pKX1icmVhaztjYXNlIDE6dGwodCksImZ1bmN0aW9uIj09PXR5cGVvZihuPXQuc3RhdGVOb2RlKS5jb21wb25lbnRXaWxsVW5tb3VudCYmZnVuY3Rpb24oZSx0KXt0cnl7dC5wcm9wcz1lLm1lbW9pemVkUHJvcHMsdC5zdGF0ZT1lLm1lbW9pemVkU3RhdGUsdC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKG4pe3l1KGUsbil9fSh0LG4pO2JyZWFrO2Nhc2UgNTp0bCh0KTticmVhaztjYXNlIDQ6Y2woZSx0LG4pfX1mdW5jdGlvbiBsbChlKXt2YXIgdD1lLmFsdGVybmF0ZTtlLnJldHVybj1udWxsLGUuY2hpbGQ9bnVsbCxlLm1lbW9pemVkU3RhdGU9bnVsbCxlLnVwZGF0ZVF1ZXVlPW51bGwsZS5kZXBlbmRlbmNpZXM9bnVsbCxlLmFsdGVybmF0ZT1udWxsLGUuZmlyc3RFZmZlY3Q9bnVsbCxlLmxhc3RFZmZlY3Q9bnVsbCxlLnBlbmRpbmdQcm9wcz1udWxsLGUubWVtb2l6ZWRQcm9wcz1udWxsLGUuc3RhdGVOb2RlPW51bGwsbnVsbCE9PXQmJmxsKHQpfWZ1bmN0aW9uIHVsKGUpe3JldHVybiA1PT09ZS50YWd8fDM9PT1lLnRhZ3x8ND09PWUudGFnfWZ1bmN0aW9uIHNsKGUpe2U6e2Zvcih2YXIgdD1lLnJldHVybjtudWxsIT09dDspe2lmKHVsKHQpKXt2YXIgbj10O2JyZWFrIGV9dD10LnJldHVybn10aHJvdyBFcnJvcihhKDE2MCkpfXN3",
                    "aXRjaCh0PW4uc3RhdGVOb2RlLG4udGFnKXtjYXNlIDU6dmFyIHI9ITE7YnJlYWs7Y2FzZSAzOmNhc2UgNDp0PXQuY29udGFpbmVySW5mbyxyPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYSgxNjEpKX0xNiZuLmVmZmVjdFRhZyYmKCRlKHQsIiIpLG4uZWZmZWN0VGFnJj0tMTcpO2U6dDpmb3Iobj1lOzspe2Zvcig7bnVsbD09PW4uc2libGluZzspe2lmKG51bGw9PT1uLnJldHVybnx8dWwobi5yZXR1cm4pKXtuPW51bGw7YnJlYWsgZX1uPW4ucmV0dXJufWZvcihuLnNpYmxpbmcucmV0dXJuPW4ucmV0dXJuLG49bi5zaWJsaW5nOzUhPT1uLnRhZyYmNiE9PW4udGFnJiYxOCE9PW4udGFnOyl7aWYoMiZuLmVmZmVjdFRhZyljb250aW51ZSB0O2lmKG51bGw9PT1uLmNoaWxkfHw0PT09bi50YWcpY29udGludWUgdDtuLmNoaWxkLnJldHVybj1uLG49bi5jaGlsZH1pZighKDImbi5lZmZlY3RUYWcpKXtuPW4uc3RhdGVOb2RlO2JyZWFrIGV9fXI/ZnVuY3Rpb24gZSh0LG4scil7dmFyIG89dC50YWcsaT01PT09b3x8Nj09PW87aWYoaSl0PWk/dC5zdGF0ZU5vZGU6dC5zdGF0ZU5vZGUuaW5zdGFuY2Usbj84PT09ci5ub2RlVHlwZT9yLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsbik6ci5pbnNlcnRCZWZvcmUodCxuKTooOD09PXIubm9kZVR5cGU/KG49ci5wYXJlbnROb2RlKS5pbnNlcnRCZWZvcmUodCxyKToobj1yKS5hcHBlbmRDaGlsZCh0KSxudWxsIT09KHI9ci5fcmVhY3RSb290Q29udGFpbmVyKSYmdm9pZCAwIT09",
                    "cnx8bnVsbCE9PW4ub25jbGlja3x8KG4ub25jbGljaz1zbikpO2Vsc2UgaWYoNCE9PW8mJm51bGwhPT0odD10LmNoaWxkKSlmb3IoZSh0LG4sciksdD10LnNpYmxpbmc7bnVsbCE9PXQ7KWUodCxuLHIpLHQ9dC5zaWJsaW5nfShlLG4sdCk6ZnVuY3Rpb24gZSh0LG4scil7dmFyIG89dC50YWcsaT01PT09b3x8Nj09PW87aWYoaSl0PWk/dC5zdGF0ZU5vZGU6dC5zdGF0ZU5vZGUuaW5zdGFuY2Usbj9yLmluc2VydEJlZm9yZSh0LG4pOnIuYXBwZW5kQ2hpbGQodCk7ZWxzZSBpZig0IT09byYmbnVsbCE9PSh0PXQuY2hpbGQpKWZvcihlKHQsbixyKSx0PXQuc2libGluZztudWxsIT09dDspZSh0LG4sciksdD10LnNpYmxpbmd9KGUsbix0KX1mdW5jdGlvbiBjbChlLHQsbil7Zm9yKHZhciByLG8saT10LGw9ITE7Oyl7aWYoIWwpe2w9aS5yZXR1cm47ZTpmb3IoOzspe2lmKG51bGw9PT1sKXRocm93IEVycm9yKGEoMTYwKSk7c3dpdGNoKHI9bC5zdGF0ZU5vZGUsbC50YWcpe2Nhc2UgNTpvPSExO2JyZWFrIGU7Y2FzZSAzOmNhc2UgNDpyPXIuY29udGFpbmVySW5mbyxvPSEwO2JyZWFrIGV9bD1sLnJldHVybn1sPSEwfWlmKDU9PT1pLnRhZ3x8Nj09PWkudGFnKXtlOmZvcih2YXIgdT1lLHM9aSxjPW4sZD1zOzspaWYoYWwodSxkLGMpLG51bGwhPT1kLmNoaWxkJiY0IT09ZC50YWcpZC5jaGlsZC5yZXR1cm49ZCxkPWQuY2hpbGQ7ZWxzZXtpZihkPT09cylicmVhayBlO2Zvcig7bnVsbD09PWQuc2libGluZzspe2lmKG51bGw9PT1kLnJl",
                    "dHVybnx8ZC5yZXR1cm49PT1zKWJyZWFrIGU7ZD1kLnJldHVybn1kLnNpYmxpbmcucmV0dXJuPWQucmV0dXJuLGQ9ZC5zaWJsaW5nfW8/KHU9cixzPWkuc3RhdGVOb2RlLDg9PT11Lm5vZGVUeXBlP3UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKTp1LnJlbW92ZUNoaWxkKHMpKTpyLnJlbW92ZUNoaWxkKGkuc3RhdGVOb2RlKX1lbHNlIGlmKDQ9PT1pLnRhZyl7aWYobnVsbCE9PWkuY2hpbGQpe3I9aS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxvPSEwLGkuY2hpbGQucmV0dXJuPWksaT1pLmNoaWxkO2NvbnRpbnVlfX1lbHNlIGlmKGFsKGUsaSxuKSxudWxsIT09aS5jaGlsZCl7aS5jaGlsZC5yZXR1cm49aSxpPWkuY2hpbGQ7Y29udGludWV9aWYoaT09PXQpYnJlYWs7Zm9yKDtudWxsPT09aS5zaWJsaW5nOyl7aWYobnVsbD09PWkucmV0dXJufHxpLnJldHVybj09PXQpcmV0dXJuOzQ9PT0oaT1pLnJldHVybikudGFnJiYobD0hMSl9aS5zaWJsaW5nLnJldHVybj1pLnJldHVybixpPWkuc2libGluZ319ZnVuY3Rpb24gZGwoZSx0KXtzd2l0Y2godC50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTpjYXNlIDIyOnJldHVybiB2b2lkIHJsKDMsdCk7Y2FzZSAxOnJldHVybjtjYXNlIDU6dmFyIG49dC5zdGF0ZU5vZGU7aWYobnVsbCE9bil7dmFyIHI9dC5tZW1vaXplZFByb3BzLG89bnVsbCE9PWU/ZS5tZW1vaXplZFByb3BzOnI7ZT10LnR5cGU7dmFyIGk9dC51cGRhdGVRdWV1ZTtpZih0LnVwZGF0ZVF1ZXVlPW51",
                    "bGwsbnVsbCE9PWkpe2ZvcihuW1NuXT1yLCJpbnB1dCI9PT1lJiYicmFkaW8iPT09ci50eXBlJiZudWxsIT1yLm5hbWUmJmtlKG4sciksYW4oZSxvKSx0PWFuKGUsciksbz0wO288aS5sZW5ndGg7bys9Mil7dmFyIGw9aVtvXSx1PWlbbysxXTsic3R5bGUiPT09bD9ubihuLHUpOiJkYW5nZXJvdXNseVNldElubmVySFRNTCI9PT1sP0ZlKG4sdSk6ImNoaWxkcmVuIj09PWw/JGUobix1KTpHKG4sbCx1LHQpfXN3aXRjaChlKXtjYXNlImlucHV0IjpTZShuLHIpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOk1lKG4scik7YnJlYWs7Y2FzZSJzZWxlY3QiOnQ9bi5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlLG4uX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIXIubXVsdGlwbGUsbnVsbCE9KGU9ci52YWx1ZSk/UGUobiwhIXIubXVsdGlwbGUsZSwhMSk6dCE9PSEhci5tdWx0aXBsZSYmKG51bGwhPXIuZGVmYXVsdFZhbHVlP1BlKG4sISFyLm11bHRpcGxlLHIuZGVmYXVsdFZhbHVlLCEwKTpQZShuLCEhci5tdWx0aXBsZSxyLm11bHRpcGxlP1tdOiIiLCExKSl9fX1yZXR1cm47Y2FzZSA2OmlmKG51bGw9PT10LnN0YXRlTm9kZSl0aHJvdyBFcnJvcihhKDE2MikpO3JldHVybiB2b2lkKHQuc3RhdGVOb2RlLm5vZGVWYWx1ZT10Lm1lbW9pemVkUHJvcHMpO2Nhc2UgMzpyZXR1cm4gdm9pZCgodD10LnN0YXRlTm9kZSkuaHlkcmF0ZSYmKHQuaHlkcmF0ZT0hMSxEdCh0LmNvbnRhaW5lckluZm8pKSk7Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpp",
                    "ZihuPXQsbnVsbD09PXQubWVtb2l6ZWRTdGF0ZT9yPSExOihyPSEwLG49dC5jaGlsZCxBbD0kbygpKSxudWxsIT09billOmZvcihlPW47Oyl7aWYoNT09PWUudGFnKWk9ZS5zdGF0ZU5vZGUscj8iZnVuY3Rpb24iPT09dHlwZW9mKGk9aS5zdHlsZSkuc2V0UHJvcGVydHk/aS5zZXRQcm9wZXJ0eSgiZGlzcGxheSIsIm5vbmUiLCJpbXBvcnRhbnQiKTppLmRpc3BsYXk9Im5vbmUiOihpPWUuc3RhdGVOb2RlLG89dm9pZCAwIT09KG89ZS5tZW1vaXplZFByb3BzLnN0eWxlKSYmbnVsbCE9PW8mJm8uaGFzT3duUHJvcGVydHkoImRpc3BsYXkiKT9vLmRpc3BsYXk6bnVsbCxpLnN0eWxlLmRpc3BsYXk9dG4oImRpc3BsYXkiLG8pKTtlbHNlIGlmKDY9PT1lLnRhZyllLnN0YXRlTm9kZS5ub2RlVmFsdWU9cj8iIjplLm1lbW9pemVkUHJvcHM7ZWxzZXtpZigxMz09PWUudGFnJiZudWxsIT09ZS5tZW1vaXplZFN0YXRlJiZudWxsPT09ZS5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpeyhpPWUuY2hpbGQuc2libGluZykucmV0dXJuPWUsZT1pO2NvbnRpbnVlfWlmKG51bGwhPT1lLmNoaWxkKXtlLmNoaWxkLnJldHVybj1lLGU9ZS5jaGlsZDtjb250aW51ZX19aWYoZT09PW4pYnJlYWs7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWUucmV0dXJufHxlLnJldHVybj09PW4pYnJlYWsgZTtlPWUucmV0dXJufWUuc2libGluZy5yZXR1cm49ZS5yZXR1cm4sZT1lLnNpYmxpbmd9cmV0dXJuIHZvaWQgZmwodCk7Y2FzZSAxOTpyZXR1",
                    "cm4gdm9pZCBmbCh0KTtjYXNlIDE3OnJldHVybn10aHJvdyBFcnJvcihhKDE2MykpfWZ1bmN0aW9uIGZsKGUpe3ZhciB0PWUudXBkYXRlUXVldWU7aWYobnVsbCE9PXQpe2UudXBkYXRlUXVldWU9bnVsbDt2YXIgbj1lLnN0YXRlTm9kZTtudWxsPT09biYmKG49ZS5zdGF0ZU5vZGU9bmV3IFphKSx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXd1LmJpbmQobnVsbCxlLHQpO24uaGFzKHQpfHwobi5hZGQodCksdC50aGVuKHIscikpfSkpfX12YXIgcGw9ImZ1bmN0aW9uIj09PXR5cGVvZiBXZWFrTWFwP1dlYWtNYXA6TWFwO2Z1bmN0aW9uIGhsKGUsdCxuKXsobj11aShuLG51bGwpKS50YWc9MyxuLnBheWxvYWQ9e2VsZW1lbnQ6bnVsbH07dmFyIHI9dC52YWx1ZTtyZXR1cm4gbi5jYWxsYmFjaz1mdW5jdGlvbigpe0RsfHwoRGw9ITAsemw9ciksZWwoZSx0KX0sbn1mdW5jdGlvbiBtbChlLHQsbil7KG49dWkobixudWxsKSkudGFnPTM7dmFyIHI9ZS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZigiZnVuY3Rpb24iPT09dHlwZW9mIHIpe3ZhciBvPXQudmFsdWU7bi5wYXlsb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIGVsKGUsdCkscihvKX19dmFyIGk9ZS5zdGF0ZU5vZGU7cmV0dXJuIG51bGwhPT1pJiYiZnVuY3Rpb24iPT09dHlwZW9mIGkuY29tcG9uZW50RGlkQ2F0Y2gmJihuLmNhbGxiYWNrPWZ1bmN0aW9uKCl7ImZ1bmN0aW9uIiE9PXR5cGVvZiByJiYobnVsbD09PUxsP0xsPW5ldyBTZXQoW3RoaXNdKTpMbC5h",
                    "ZGQodGhpcyksZWwoZSx0KSk7dmFyIG49dC5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKHQudmFsdWUse2NvbXBvbmVudFN0YWNrOm51bGwhPT1uP246IiJ9KX0pLG59dmFyIHZsLGJsPU1hdGguY2VpbCx5bD1YLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZ2w9WC5SZWFjdEN1cnJlbnRPd25lcix3bD0wLHhsPTMsRWw9NCxPbD0wLGtsPW51bGwsU2w9bnVsbCxDbD0wLGpsPXdsLFRsPW51bGwsUGw9MTA3Mzc0MTgyMyxSbD0xMDczNzQxODIzLE5sPW51bGwsTWw9MCxfbD0hMSxBbD0wLElsPW51bGwsRGw9ITEsemw9bnVsbCxMbD1udWxsLEZsPSExLCRsPW51bGwsV2w9OTAsQmw9bnVsbCxIbD0wLFZsPW51bGwsVWw9MDtmdW5jdGlvbiBxbCgpe3JldHVybiAwIT09KDQ4Jk9sKT8xMDczNzQxODIxLSgkbygpLzEwfDApOjAhPT1VbD9VbDpVbD0xMDczNzQxODIxLSgkbygpLzEwfDApfWZ1bmN0aW9uIEtsKGUsdCxuKXtpZigwPT09KDImKHQ9dC5tb2RlKSkpcmV0dXJuIDEwNzM3NDE4MjM7dmFyIHI9V28oKTtpZigwPT09KDQmdCkpcmV0dXJuIDk5PT09cj8xMDczNzQxODIzOjEwNzM3NDE4MjI7aWYoMCE9PSgxNiZPbCkpcmV0dXJuIENsO2lmKG51bGwhPT1uKWU9WW8oZSwwfG4udGltZW91dE1zfHw1ZTMsMjUwKTtlbHNlIHN3aXRjaChyKXtjYXNlIDk5OmU9MTA3Mzc0MTgyMzticmVhaztjYXNlIDk4OmU9WW8oZSwxNTAsMTAwKTticmVhaztjYXNlIDk3OmNhc2UgOTY6ZT1ZbyhlLDVlMywyNTApO2JyZWFrO2Nhc2UgOTU6",
                    "ZT0yO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYSgzMjYpKX1yZXR1cm4gbnVsbCE9PWtsJiZlPT09Q2wmJi0tZSxlfWZ1bmN0aW9uIFlsKGUsdCl7aWYoNTA8SGwpdGhyb3cgSGw9MCxWbD1udWxsLEVycm9yKGEoMTg1KSk7aWYobnVsbCE9PShlPVFsKGUsdCkpKXt2YXIgbj1XbygpOzEwNzM3NDE4MjM9PT10PzAhPT0oOCZPbCkmJjA9PT0oNDgmT2wpP1psKGUpOihHbChlKSwwPT09T2wmJnFvKCkpOkdsKGUpLDA9PT0oNCZPbCl8fDk4IT09biYmOTkhPT1ufHwobnVsbD09PUJsP0JsPW5ldyBNYXAoW1tlLHRdXSk6KHZvaWQgMD09PShuPUJsLmdldChlKSl8fG4+dCkmJkJsLnNldChlLHQpKX19ZnVuY3Rpb24gUWwoZSx0KXtlLmV4cGlyYXRpb25UaW1lPHQmJihlLmV4cGlyYXRpb25UaW1lPXQpO3ZhciBuPWUuYWx0ZXJuYXRlO251bGwhPT1uJiZuLmV4cGlyYXRpb25UaW1lPHQmJihuLmV4cGlyYXRpb25UaW1lPXQpO3ZhciByPWUucmV0dXJuLG89bnVsbDtpZihudWxsPT09ciYmMz09PWUudGFnKW89ZS5zdGF0ZU5vZGU7ZWxzZSBmb3IoO251bGwhPT1yOyl7aWYobj1yLmFsdGVybmF0ZSxyLmNoaWxkRXhwaXJhdGlvblRpbWU8dCYmKHIuY2hpbGRFeHBpcmF0aW9uVGltZT10KSxudWxsIT09biYmbi5jaGlsZEV4cGlyYXRpb25UaW1lPHQmJihuLmNoaWxkRXhwaXJhdGlvblRpbWU9dCksbnVsbD09PXIucmV0dXJuJiYzPT09ci50YWcpe289ci5zdGF0ZU5vZGU7YnJlYWt9cj1yLnJldHVybn1yZXR1cm4gbnVsbCE9PW8m",
                    "JihrbD09PW8mJihhdSh0KSxqbD09PUVsJiZfdShvLENsKSksQXUobyx0KSksb31mdW5jdGlvbiBYbChlKXt2YXIgdD1lLmxhc3RFeHBpcmVkVGltZTtpZigwIT09dClyZXR1cm4gdDtpZighTXUoZSx0PWUuZmlyc3RQZW5kaW5nVGltZSkpcmV0dXJuIHQ7dmFyIG49ZS5sYXN0UGluZ2VkVGltZTtyZXR1cm4gMj49KGU9bj4oZT1lLm5leHRLbm93blBlbmRpbmdMZXZlbCk/bjplKSYmdCE9PWU/MDplfWZ1bmN0aW9uIEdsKGUpe2lmKDAhPT1lLmxhc3RFeHBpcmVkVGltZSllLmNhbGxiYWNrRXhwaXJhdGlvblRpbWU9MTA3Mzc0MTgyMyxlLmNhbGxiYWNrUHJpb3JpdHk9OTksZS5jYWxsYmFja05vZGU9VW8oWmwuYmluZChudWxsLGUpKTtlbHNle3ZhciB0PVhsKGUpLG49ZS5jYWxsYmFja05vZGU7aWYoMD09PXQpbnVsbCE9PW4mJihlLmNhbGxiYWNrTm9kZT1udWxsLGUuY2FsbGJhY2tFeHBpcmF0aW9uVGltZT0wLGUuY2FsbGJhY2tQcmlvcml0eT05MCk7ZWxzZXt2YXIgcj1xbCgpO2lmKDEwNzM3NDE4MjM9PT10P3I9OTk6MT09PXR8fDI9PT10P3I9OTU6cj0wPj0ocj0xMCooMTA3Mzc0MTgyMS10KS0xMCooMTA3Mzc0MTgyMS1yKSk/OTk6MjUwPj1yPzk4OjUyNTA+PXI/OTc6OTUsbnVsbCE9PW4pe3ZhciBvPWUuY2FsbGJhY2tQcmlvcml0eTtpZihlLmNhbGxiYWNrRXhwaXJhdGlvblRpbWU9PT10JiZvPj1yKXJldHVybjtuIT09X28mJmtvKG4pfWUuY2FsbGJhY2tFeHBpcmF0aW9uVGltZT10LGUuY2FsbGJhY2tQcmlvcml0",
                    "eT1yLHQ9MTA3Mzc0MTgyMz09PXQ/VW8oWmwuYmluZChudWxsLGUpKTpWbyhyLEpsLmJpbmQobnVsbCxlKSx7dGltZW91dDoxMCooMTA3Mzc0MTgyMS10KS0kbygpfSksZS5jYWxsYmFja05vZGU9dH19fWZ1bmN0aW9uIEpsKGUsdCl7aWYoVWw9MCx0KXJldHVybiBJdShlLHQ9cWwoKSksR2woZSksbnVsbDt2YXIgbj1YbChlKTtpZigwIT09bil7aWYodD1lLmNhbGxiYWNrTm9kZSwwIT09KDQ4Jk9sKSl0aHJvdyBFcnJvcihhKDMyNykpO2lmKG11KCksZT09PWtsJiZuPT09Q2x8fG51KGUsbiksbnVsbCE9PVNsKXt2YXIgcj1PbDtPbHw9MTY7Zm9yKHZhciBvPW91KCk7Oyl0cnl7dXUoKTticmVha31jYXRjaCh1KXtydShlLHUpfWlmKGVpKCksT2w9cix5bC5jdXJyZW50PW8sMT09PWpsKXRocm93IHQ9VGwsbnUoZSxuKSxfdShlLG4pLEdsKGUpLHQ7aWYobnVsbD09PVNsKXN3aXRjaChvPWUuZmluaXNoZWRXb3JrPWUuY3VycmVudC5hbHRlcm5hdGUsZS5maW5pc2hlZEV4cGlyYXRpb25UaW1lPW4scj1qbCxrbD1udWxsLHIpe2Nhc2Ugd2w6Y2FzZSAxOnRocm93IEVycm9yKGEoMzQ1KSk7Y2FzZSAyOkl1KGUsMjxuPzI6bik7YnJlYWs7Y2FzZSB4bDppZihfdShlLG4pLG49PT0ocj1lLmxhc3RTdXNwZW5kZWRUaW1lKSYmKGUubmV4dEtub3duUGVuZGluZ0xldmVsPWR1KG8pKSwxMDczNzQxODIzPT09UGwmJjEwPChvPUFsKzUwMC0kbygpKSl7aWYoX2wpe3ZhciBpPWUubGFzdFBpbmdlZFRpbWU7aWYoMD09PWl8fGk+PW4pe2Uu",
                    "bGFzdFBpbmdlZFRpbWU9bixudShlLG4pO2JyZWFrfX1pZigwIT09KGk9WGwoZSkpJiZpIT09bilicmVhaztpZigwIT09ciYmciE9PW4pe2UubGFzdFBpbmdlZFRpbWU9cjticmVha31lLnRpbWVvdXRIYW5kbGU9Z24oZnUuYmluZChudWxsLGUpLG8pO2JyZWFrfWZ1KGUpO2JyZWFrO2Nhc2UgRWw6aWYoX3UoZSxuKSxuPT09KHI9ZS5sYXN0U3VzcGVuZGVkVGltZSkmJihlLm5leHRLbm93blBlbmRpbmdMZXZlbD1kdShvKSksX2wmJigwPT09KG89ZS5sYXN0UGluZ2VkVGltZSl8fG8+PW4pKXtlLmxhc3RQaW5nZWRUaW1lPW4sbnUoZSxuKTticmVha31pZigwIT09KG89WGwoZSkpJiZvIT09bilicmVhaztpZigwIT09ciYmciE9PW4pe2UubGFzdFBpbmdlZFRpbWU9cjticmVha31pZigxMDczNzQxODIzIT09Umw/cj0xMCooMTA3Mzc0MTgyMS1SbCktJG8oKToxMDczNzQxODIzPT09UGw/cj0wOihyPTEwKigxMDczNzQxODIxLVBsKS01ZTMsMD4ocj0obz0kbygpKS1yKSYmKHI9MCksKG49MTAqKDEwNzM3NDE4MjEtbiktbyk8KHI9KDEyMD5yPzEyMDo0ODA+cj80ODA6MTA4MD5yPzEwODA6MTkyMD5yPzE5MjA6M2UzPnI/M2UzOjQzMjA+cj80MzIwOjE5NjAqYmwoci8xOTYwKSktcikmJihyPW4pKSwxMDxyKXtlLnRpbWVvdXRIYW5kbGU9Z24oZnUuYmluZChudWxsLGUpLHIpO2JyZWFrfWZ1KGUpO2JyZWFrO2Nhc2UgNTppZigxMDczNzQxODIzIT09UGwmJm51bGwhPT1ObCl7aT1QbDt2YXIgbD1ObDtpZigwPj0ocj0wfGwuYnVz",
                    "eU1pbkR1cmF0aW9uTXMpP3I9MDoobz0wfGwuYnVzeURlbGF5TXMscj0oaT0kbygpLSgxMCooMTA3Mzc0MTgyMS1pKS0oMHxsLnRpbWVvdXRNc3x8NWUzKSkpPD1vPzA6bytyLWkpLDEwPHIpe191KGUsbiksZS50aW1lb3V0SGFuZGxlPWduKGZ1LmJpbmQobnVsbCxlKSxyKTticmVha319ZnUoZSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihhKDMyOSkpfWlmKEdsKGUpLGUuY2FsbGJhY2tOb2RlPT09dClyZXR1cm4gSmwuYmluZChudWxsLGUpfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBabChlKXt2YXIgdD1lLmxhc3RFeHBpcmVkVGltZTtpZih0PTAhPT10P3Q6MTA3Mzc0MTgyMywwIT09KDQ4Jk9sKSl0aHJvdyBFcnJvcihhKDMyNykpO2lmKG11KCksZT09PWtsJiZ0PT09Q2x8fG51KGUsdCksbnVsbCE9PVNsKXt2YXIgbj1PbDtPbHw9MTY7Zm9yKHZhciByPW91KCk7Oyl0cnl7bHUoKTticmVha31jYXRjaChvKXtydShlLG8pfWlmKGVpKCksT2w9bix5bC5jdXJyZW50PXIsMT09PWpsKXRocm93IG49VGwsbnUoZSx0KSxfdShlLHQpLEdsKGUpLG47aWYobnVsbCE9PVNsKXRocm93IEVycm9yKGEoMjYxKSk7ZS5maW5pc2hlZFdvcms9ZS5jdXJyZW50LmFsdGVybmF0ZSxlLmZpbmlzaGVkRXhwaXJhdGlvblRpbWU9dCxrbD1udWxsLGZ1KGUpLEdsKGUpfXJldHVybiBudWxsfWZ1bmN0aW9uIGV1KGUsdCl7dmFyIG49T2w7T2x8PTE7dHJ5e3JldHVybiBlKHQpfWZpbmFsbHl7MD09PShPbD1uKSYmcW8oKX19ZnVuY3Rpb24gdHUo",
                    "ZSx0KXt2YXIgbj1PbDtPbCY9LTIsT2x8PTg7dHJ5e3JldHVybiBlKHQpfWZpbmFsbHl7MD09PShPbD1uKSYmcW8oKX19ZnVuY3Rpb24gbnUoZSx0KXtlLmZpbmlzaGVkV29yaz1udWxsLGUuZmluaXNoZWRFeHBpcmF0aW9uVGltZT0wO3ZhciBuPWUudGltZW91dEhhbmRsZTtpZigtMSE9PW4mJihlLnRpbWVvdXRIYW5kbGU9LTEsd24obikpLG51bGwhPT1TbClmb3Iobj1TbC5yZXR1cm47bnVsbCE9PW47KXt2YXIgcj1uO3N3aXRjaChyLnRhZyl7Y2FzZSAxOm51bGwhPT0ocj1yLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMpJiZ2b2lkIDAhPT1yJiZibygpO2JyZWFrO2Nhc2UgMzpfaSgpLHVvKHBvKSx1byhmbyk7YnJlYWs7Y2FzZSA1OklpKHIpO2JyZWFrO2Nhc2UgNDpfaSgpO2JyZWFrO2Nhc2UgMTM6Y2FzZSAxOTp1byhEaSk7YnJlYWs7Y2FzZSAxMDp0aShyKX1uPW4ucmV0dXJufWtsPWUsU2w9Q3UoZS5jdXJyZW50LG51bGwpLENsPXQsamw9d2wsVGw9bnVsbCxSbD1QbD0xMDczNzQxODIzLE5sPW51bGwsTWw9MCxfbD0hMX1mdW5jdGlvbiBydShlLHQpe2Zvcig7Oyl7dHJ5e2lmKGVpKCksRmkuY3VycmVudD12YSxVaSlmb3IodmFyIG49QmkubWVtb2l6ZWRTdGF0ZTtudWxsIT09bjspe3ZhciByPW4ucXVldWU7bnVsbCE9PXImJihyLnBlbmRpbmc9bnVsbCksbj1uLm5leHR9aWYoV2k9MCxWaT1IaT1CaT1udWxsLFVpPSExLG51bGw9PT1TbHx8bnVsbD09PVNsLnJldHVybilyZXR1cm4gamw9MSxUbD10LFNsPW51bGw7ZTp7",
                    "dmFyIG89ZSxpPVNsLnJldHVybixhPVNsLGw9dDtpZih0PUNsLGEuZWZmZWN0VGFnfD0yMDQ4LGEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PW51bGwsbnVsbCE9PWwmJiJvYmplY3QiPT09dHlwZW9mIGwmJiJmdW5jdGlvbiI9PT10eXBlb2YgbC50aGVuKXt2YXIgdT1sO2lmKDA9PT0oMiZhLm1vZGUpKXt2YXIgcz1hLmFsdGVybmF0ZTtzPyhhLnVwZGF0ZVF1ZXVlPXMudXBkYXRlUXVldWUsYS5tZW1vaXplZFN0YXRlPXMubWVtb2l6ZWRTdGF0ZSxhLmV4cGlyYXRpb25UaW1lPXMuZXhwaXJhdGlvblRpbWUpOihhLnVwZGF0ZVF1ZXVlPW51bGwsYS5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBjPTAhPT0oMSZEaS5jdXJyZW50KSxkPWk7ZG97dmFyIGY7aWYoZj0xMz09PWQudGFnKXt2YXIgcD1kLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PXApZj1udWxsIT09cC5kZWh5ZHJhdGVkO2Vsc2V7dmFyIGg9ZC5tZW1vaXplZFByb3BzO2Y9dm9pZCAwIT09aC5mYWxsYmFjayYmKCEwIT09aC51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8IWMpfX1pZihmKXt2YXIgbT1kLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT1tKXt2YXIgdj1uZXcgU2V0O3YuYWRkKHUpLGQudXBkYXRlUXVldWU9dn1lbHNlIG0uYWRkKHUpO2lmKDA9PT0oMiZkLm1vZGUpKXtpZihkLmVmZmVjdFRhZ3w9NjQsYS5lZmZlY3RUYWcmPS0yOTgxLDE9PT1hLnRhZylpZihudWxsPT09YS5hbHRlcm5hdGUpYS50YWc9MTc7ZWxzZXt2YXIgYj11aSgxMDczNzQxODIzLG51",
                    "bGwpO2IudGFnPTIsc2koYSxiKX1hLmV4cGlyYXRpb25UaW1lPTEwNzM3NDE4MjM7YnJlYWsgZX1sPXZvaWQgMCxhPXQ7dmFyIHk9by5waW5nQ2FjaGU7aWYobnVsbD09PXk/KHk9by5waW5nQ2FjaGU9bmV3IHBsLGw9bmV3IFNldCx5LnNldCh1LGwpKTp2b2lkIDA9PT0obD15LmdldCh1KSkmJihsPW5ldyBTZXQseS5zZXQodSxsKSksIWwuaGFzKGEpKXtsLmFkZChhKTt2YXIgZz1ndS5iaW5kKG51bGwsbyx1LGEpO3UudGhlbihnLGcpfWQuZWZmZWN0VGFnfD00MDk2LGQuZXhwaXJhdGlvblRpbWU9dDticmVhayBlfWQ9ZC5yZXR1cm59d2hpbGUobnVsbCE9PWQpO2w9RXJyb3IoKHZlKGEudHlwZSl8fCJBIFJlYWN0IGNvbXBvbmVudCIpKyIgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXG5cbkFkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gcHJvdmlkZSBhIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkuIitiZShhKSl9NSE9PWpsJiYoamw9MiksbD1KYShsLGEpLGQ9aTtkb3tzd2l0Y2goZC50YWcpe2Nhc2UgMzp1PWwsZC5lZmZlY3RUYWd8PTQwOTYsZC5leHBpcmF0aW9uVGltZT10LGNpKGQsaGwoZCx1LHQpKTticmVhayBlO2Nhc2UgMTp1PWw7dmFyIHc9ZC50eXBlLHg9ZC5zdGF0ZU5vZGU7aWYoMD09PSg2NCZkLmVmZmVjdFRhZykmJigiZnVuY3Rpb24iPT09dHlw",
                    "ZW9mIHcuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09eCYmImZ1bmN0aW9uIj09PXR5cGVvZiB4LmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PUxsfHwhTGwuaGFzKHgpKSkpe2QuZWZmZWN0VGFnfD00MDk2LGQuZXhwaXJhdGlvblRpbWU9dCxjaShkLG1sKGQsdSx0KSk7YnJlYWsgZX19ZD1kLnJldHVybn13aGlsZShudWxsIT09ZCl9U2w9Y3UoU2wpfWNhdGNoKEUpe3Q9RTtjb250aW51ZX1icmVha319ZnVuY3Rpb24gb3UoKXt2YXIgZT15bC5jdXJyZW50O3JldHVybiB5bC5jdXJyZW50PXZhLG51bGw9PT1lP3ZhOmV9ZnVuY3Rpb24gaXUoZSx0KXtlPFBsJiYyPGUmJihQbD1lKSxudWxsIT09dCYmZTxSbCYmMjxlJiYoUmw9ZSxObD10KX1mdW5jdGlvbiBhdShlKXtlPk1sJiYoTWw9ZSl9ZnVuY3Rpb24gbHUoKXtmb3IoO251bGwhPT1TbDspU2w9c3UoU2wpfWZ1bmN0aW9uIHV1KCl7Zm9yKDtudWxsIT09U2wmJiFBbygpOylTbD1zdShTbCl9ZnVuY3Rpb24gc3UoZSl7dmFyIHQ9dmwoZS5hbHRlcm5hdGUsZSxDbCk7cmV0dXJuIGUubWVtb2l6ZWRQcm9wcz1lLnBlbmRpbmdQcm9wcyxudWxsPT09dCYmKHQ9Y3UoZSkpLGdsLmN1cnJlbnQ9bnVsbCx0fWZ1bmN0aW9uIGN1KGUpe1NsPWU7ZG97dmFyIHQ9U2wuYWx0ZXJuYXRlO2lmKGU9U2wucmV0dXJuLDA9PT0oMjA0OCZTbC5lZmZlY3RUYWcpKXtpZih0PVhhKHQsU2wsQ2wpLDE9PT1DbHx8MSE9PVNsLmNoaWxkRXhwaXJhdGlvblRpbWUpe2Zvcih2YXIgbj0w",
                    "LHI9U2wuY2hpbGQ7bnVsbCE9PXI7KXt2YXIgbz1yLmV4cGlyYXRpb25UaW1lLGk9ci5jaGlsZEV4cGlyYXRpb25UaW1lO28+biYmKG49byksaT5uJiYobj1pKSxyPXIuc2libGluZ31TbC5jaGlsZEV4cGlyYXRpb25UaW1lPW59aWYobnVsbCE9PXQpcmV0dXJuIHQ7bnVsbCE9PWUmJjA9PT0oMjA0OCZlLmVmZmVjdFRhZykmJihudWxsPT09ZS5maXJzdEVmZmVjdCYmKGUuZmlyc3RFZmZlY3Q9U2wuZmlyc3RFZmZlY3QpLG51bGwhPT1TbC5sYXN0RWZmZWN0JiYobnVsbCE9PWUubGFzdEVmZmVjdCYmKGUubGFzdEVmZmVjdC5uZXh0RWZmZWN0PVNsLmZpcnN0RWZmZWN0KSxlLmxhc3RFZmZlY3Q9U2wubGFzdEVmZmVjdCksMTxTbC5lZmZlY3RUYWcmJihudWxsIT09ZS5sYXN0RWZmZWN0P2UubGFzdEVmZmVjdC5uZXh0RWZmZWN0PVNsOmUuZmlyc3RFZmZlY3Q9U2wsZS5sYXN0RWZmZWN0PVNsKSl9ZWxzZXtpZihudWxsIT09KHQ9R2EoU2wpKSlyZXR1cm4gdC5lZmZlY3RUYWcmPTIwNDcsdDtudWxsIT09ZSYmKGUuZmlyc3RFZmZlY3Q9ZS5sYXN0RWZmZWN0PW51bGwsZS5lZmZlY3RUYWd8PTIwNDgpfWlmKG51bGwhPT0odD1TbC5zaWJsaW5nKSlyZXR1cm4gdDtTbD1lfXdoaWxlKG51bGwhPT1TbCk7cmV0dXJuIGpsPT09d2wmJihqbD01KSxudWxsfWZ1bmN0aW9uIGR1KGUpe3ZhciB0PWUuZXhwaXJhdGlvblRpbWU7cmV0dXJuIHQ+KGU9ZS5jaGlsZEV4cGlyYXRpb25UaW1lKT90OmV9ZnVuY3Rpb24gZnUoZSl7dmFyIHQ9V28o",
                    "KTtyZXR1cm4gSG8oOTkscHUuYmluZChudWxsLGUsdCkpLG51bGx9ZnVuY3Rpb24gcHUoZSx0KXtkb3ttdSgpfXdoaWxlKG51bGwhPT0kbCk7aWYoMCE9PSg0OCZPbCkpdGhyb3cgRXJyb3IoYSgzMjcpKTt2YXIgbj1lLmZpbmlzaGVkV29yayxyPWUuZmluaXNoZWRFeHBpcmF0aW9uVGltZTtpZihudWxsPT09bilyZXR1cm4gbnVsbDtpZihlLmZpbmlzaGVkV29yaz1udWxsLGUuZmluaXNoZWRFeHBpcmF0aW9uVGltZT0wLG49PT1lLmN1cnJlbnQpdGhyb3cgRXJyb3IoYSgxNzcpKTtlLmNhbGxiYWNrTm9kZT1udWxsLGUuY2FsbGJhY2tFeHBpcmF0aW9uVGltZT0wLGUuY2FsbGJhY2tQcmlvcml0eT05MCxlLm5leHRLbm93blBlbmRpbmdMZXZlbD0wO3ZhciBvPWR1KG4pO2lmKGUuZmlyc3RQZW5kaW5nVGltZT1vLHI8PWUubGFzdFN1c3BlbmRlZFRpbWU/ZS5maXJzdFN1c3BlbmRlZFRpbWU9ZS5sYXN0U3VzcGVuZGVkVGltZT1lLm5leHRLbm93blBlbmRpbmdMZXZlbD0wOnI8PWUuZmlyc3RTdXNwZW5kZWRUaW1lJiYoZS5maXJzdFN1c3BlbmRlZFRpbWU9ci0xKSxyPD1lLmxhc3RQaW5nZWRUaW1lJiYoZS5sYXN0UGluZ2VkVGltZT0wKSxyPD1lLmxhc3RFeHBpcmVkVGltZSYmKGUubGFzdEV4cGlyZWRUaW1lPTApLGU9PT1rbCYmKFNsPWtsPW51bGwsQ2w9MCksMTxuLmVmZmVjdFRhZz9udWxsIT09bi5sYXN0RWZmZWN0PyhuLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1uLG89bi5maXJzdEVmZmVjdCk6bz1uOm89bi5maXJzdEVm",
                    "ZmVjdCxudWxsIT09byl7dmFyIGk9T2w7T2x8PTMyLGdsLmN1cnJlbnQ9bnVsbCxtbj1xdDt2YXIgbD1wbigpO2lmKGhuKGwpKXtpZigic2VsZWN0aW9uU3RhcnQiaW4gbCl2YXIgdT17c3RhcnQ6bC5zZWxlY3Rpb25TdGFydCxlbmQ6bC5zZWxlY3Rpb25FbmR9O2Vsc2UgZTp7dmFyIHM9KHU9KHU9bC5vd25lckRvY3VtZW50KSYmdS5kZWZhdWx0Vmlld3x8d2luZG93KS5nZXRTZWxlY3Rpb24mJnUuZ2V0U2VsZWN0aW9uKCk7aWYocyYmMCE9PXMucmFuZ2VDb3VudCl7dT1zLmFuY2hvck5vZGU7dmFyIGM9cy5hbmNob3JPZmZzZXQsZD1zLmZvY3VzTm9kZTtzPXMuZm9jdXNPZmZzZXQ7dHJ5e3Uubm9kZVR5cGUsZC5ub2RlVHlwZX1jYXRjaChDKXt1PW51bGw7YnJlYWsgZX12YXIgZj0wLHA9LTEsaD0tMSxtPTAsdj0wLGI9bCx5PW51bGw7dDpmb3IoOzspe2Zvcih2YXIgZztiIT09dXx8MCE9PWMmJjMhPT1iLm5vZGVUeXBlfHwocD1mK2MpLGIhPT1kfHwwIT09cyYmMyE9PWIubm9kZVR5cGV8fChoPWYrcyksMz09PWIubm9kZVR5cGUmJihmKz1iLm5vZGVWYWx1ZS5sZW5ndGgpLG51bGwhPT0oZz1iLmZpcnN0Q2hpbGQpOyl5PWIsYj1nO2Zvcig7Oyl7aWYoYj09PWwpYnJlYWsgdDtpZih5PT09dSYmKyttPT09YyYmKHA9ZikseT09PWQmJisrdj09PXMmJihoPWYpLG51bGwhPT0oZz1iLm5leHRTaWJsaW5nKSlicmVhazt5PShiPXkpLnBhcmVudE5vZGV9Yj1nfXU9LTE9PT1wfHwtMT09PWg/bnVsbDp7c3RhcnQ6cCxlbmQ6aH19",
                    "ZWxzZSB1PW51bGx9dT11fHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSB1PW51bGw7dm49e2FjdGl2ZUVsZW1lbnREZXRhY2hlZDpudWxsLGZvY3VzZWRFbGVtOmwsc2VsZWN0aW9uUmFuZ2U6dX0scXQ9ITEsSWw9bztkb3t0cnl7aHUoKX1jYXRjaChDKXtpZihudWxsPT09SWwpdGhyb3cgRXJyb3IoYSgzMzApKTt5dShJbCxDKSxJbD1JbC5uZXh0RWZmZWN0fX13aGlsZShudWxsIT09SWwpO0lsPW87ZG97dHJ5e2ZvcihsPWUsdT10O251bGwhPT1JbDspe3ZhciB3PUlsLmVmZmVjdFRhZztpZigxNiZ3JiYkZShJbC5zdGF0ZU5vZGUsIiIpLDEyOCZ3KXt2YXIgeD1JbC5hbHRlcm5hdGU7aWYobnVsbCE9PXgpe3ZhciBFPXgucmVmO251bGwhPT1FJiYoImZ1bmN0aW9uIj09PXR5cGVvZiBFP0UobnVsbCk6RS5jdXJyZW50PW51bGwpfX1zd2l0Y2goMTAzOCZ3KXtjYXNlIDI6c2woSWwpLElsLmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2OnNsKElsKSxJbC5lZmZlY3RUYWcmPS0zLGRsKElsLmFsdGVybmF0ZSxJbCk7YnJlYWs7Y2FzZSAxMDI0OklsLmVmZmVjdFRhZyY9LTEwMjU7YnJlYWs7Y2FzZSAxMDI4OklsLmVmZmVjdFRhZyY9LTEwMjUsZGwoSWwuYWx0ZXJuYXRlLElsKTticmVhaztjYXNlIDQ6ZGwoSWwuYWx0ZXJuYXRlLElsKTticmVhaztjYXNlIDg6Y2wobCxjPUlsLHUpLGxsKGMpfUlsPUlsLm5leHRFZmZlY3R9fWNhdGNoKEMpe2lmKG51bGw9PT1JbCl0aHJvdyBFcnJvcihhKDMzMCkpO3l1KElsLEMpLElsPUlsLm5leHRF",
                    "ZmZlY3R9fXdoaWxlKG51bGwhPT1JbCk7aWYoRT12bix4PXBuKCksdz1FLmZvY3VzZWRFbGVtLHU9RS5zZWxlY3Rpb25SYW5nZSx4IT09dyYmdyYmdy5vd25lckRvY3VtZW50JiZmdW5jdGlvbiBlKHQsbil7cmV0dXJuISghdHx8IW4pJiYodD09PW58fCghdHx8MyE9PXQubm9kZVR5cGUpJiYobiYmMz09PW4ubm9kZVR5cGU/ZSh0LG4ucGFyZW50Tm9kZSk6ImNvbnRhaW5zImluIHQ/dC5jb250YWlucyhuKTohIXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJiEhKDE2JnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obikpKSl9KHcub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdykpe251bGwhPT11JiZobih3KSYmKHg9dS5zdGFydCx2b2lkIDA9PT0oRT11LmVuZCkmJihFPXgpLCJzZWxlY3Rpb25TdGFydCJpbiB3Pyh3LnNlbGVjdGlvblN0YXJ0PXgsdy5zZWxlY3Rpb25FbmQ9TWF0aC5taW4oRSx3LnZhbHVlLmxlbmd0aCkpOihFPSh4PXcub3duZXJEb2N1bWVudHx8ZG9jdW1lbnQpJiZ4LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbiYmKEU9RS5nZXRTZWxlY3Rpb24oKSxjPXcudGV4dENvbnRlbnQubGVuZ3RoLGw9TWF0aC5taW4odS5zdGFydCxjKSx1PXZvaWQgMD09PXUuZW5kP2w6TWF0aC5taW4odS5lbmQsYyksIUUuZXh0ZW5kJiZsPnUmJihjPXUsdT1sLGw9YyksYz1mbih3LGwpLGQ9Zm4odyx1KSxjJiZkJiYoMSE9PUUucmFuZ2VDb3VudHx8RS5hbmNob3JOb2RlIT09Yy5ub2RlfHxFLmFuY2hv",
                    "ck9mZnNldCE9PWMub2Zmc2V0fHxFLmZvY3VzTm9kZSE9PWQubm9kZXx8RS5mb2N1c09mZnNldCE9PWQub2Zmc2V0KSYmKCh4PXguY3JlYXRlUmFuZ2UoKSkuc2V0U3RhcnQoYy5ub2RlLGMub2Zmc2V0KSxFLnJlbW92ZUFsbFJhbmdlcygpLGw+dT8oRS5hZGRSYW5nZSh4KSxFLmV4dGVuZChkLm5vZGUsZC5vZmZzZXQpKTooeC5zZXRFbmQoZC5ub2RlLGQub2Zmc2V0KSxFLmFkZFJhbmdlKHgpKSkpKSx4PVtdO2ZvcihFPXc7RT1FLnBhcmVudE5vZGU7KTE9PT1FLm5vZGVUeXBlJiZ4LnB1c2goe2VsZW1lbnQ6RSxsZWZ0OkUuc2Nyb2xsTGVmdCx0b3A6RS5zY3JvbGxUb3B9KTtmb3IoImZ1bmN0aW9uIj09PXR5cGVvZiB3LmZvY3VzJiZ3LmZvY3VzKCksdz0wO3c8eC5sZW5ndGg7dysrKShFPXhbd10pLmVsZW1lbnQuc2Nyb2xsTGVmdD1FLmxlZnQsRS5lbGVtZW50LnNjcm9sbFRvcD1FLnRvcH1xdD0hIW1uLHZuPW1uPW51bGwsZS5jdXJyZW50PW4sSWw9bztkb3t0cnl7Zm9yKHc9ZTtudWxsIT09SWw7KXt2YXIgTz1JbC5lZmZlY3RUYWc7aWYoMzYmTyYmaWwodyxJbC5hbHRlcm5hdGUsSWwpLDEyOCZPKXt4PXZvaWQgMDt2YXIgaz1JbC5yZWY7aWYobnVsbCE9PWspe3ZhciBTPUlsLnN0YXRlTm9kZTtzd2l0Y2goSWwudGFnKXtjYXNlIDU6eD1TO2JyZWFrO2RlZmF1bHQ6eD1TfSJmdW5jdGlvbiI9PT10eXBlb2Ygaz9rKHgpOmsuY3VycmVudD14fX1JbD1JbC5uZXh0RWZmZWN0fX1jYXRjaChDKXtpZihudWxsPT09SWwpdGhy",
                    "b3cgRXJyb3IoYSgzMzApKTt5dShJbCxDKSxJbD1JbC5uZXh0RWZmZWN0fX13aGlsZShudWxsIT09SWwpO0lsPW51bGwsSW8oKSxPbD1pfWVsc2UgZS5jdXJyZW50PW47aWYoRmwpRmw9ITEsJGw9ZSxXbD10O2Vsc2UgZm9yKElsPW87bnVsbCE9PUlsOyl0PUlsLm5leHRFZmZlY3QsSWwubmV4dEVmZmVjdD1udWxsLElsPXQ7aWYoMD09PSh0PWUuZmlyc3RQZW5kaW5nVGltZSkmJihMbD1udWxsKSwxMDczNzQxODIzPT09dD9lPT09Vmw/SGwrKzooSGw9MCxWbD1lKTpIbD0wLCJmdW5jdGlvbiI9PT10eXBlb2YgeHUmJnh1KG4uc3RhdGVOb2RlLHIpLEdsKGUpLERsKXRocm93IERsPSExLGU9emwsemw9bnVsbCxlO3JldHVybiAwIT09KDgmT2wpfHxxbygpLG51bGx9ZnVuY3Rpb24gaHUoKXtmb3IoO251bGwhPT1JbDspe3ZhciBlPUlsLmVmZmVjdFRhZzswIT09KDI1NiZlKSYmbmwoSWwuYWx0ZXJuYXRlLElsKSwwPT09KDUxMiZlKXx8Rmx8fChGbD0hMCxWbyg5NywoZnVuY3Rpb24oKXtyZXR1cm4gbXUoKSxudWxsfSkpKSxJbD1JbC5uZXh0RWZmZWN0fX1mdW5jdGlvbiBtdSgpe2lmKDkwIT09V2wpe3ZhciBlPTk3PFdsPzk3OldsO3JldHVybiBXbD05MCxIbyhlLHZ1KX19ZnVuY3Rpb24gdnUoKXtpZihudWxsPT09JGwpcmV0dXJuITE7dmFyIGU9JGw7aWYoJGw9bnVsbCwwIT09KDQ4Jk9sKSl0aHJvdyBFcnJvcihhKDMzMSkpO3ZhciB0PU9sO2ZvcihPbHw9MzIsZT1lLmN1cnJlbnQuZmlyc3RFZmZlY3Q7bnVsbCE9PWU7KXt0",
                    "cnl7dmFyIG49ZTtpZigwIT09KDUxMiZuLmVmZmVjdFRhZykpc3dpdGNoKG4udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmNhc2UgMjI6cmwoNSxuKSxvbCg1LG4pfX1jYXRjaChyKXtpZihudWxsPT09ZSl0aHJvdyBFcnJvcihhKDMzMCkpO3l1KGUscil9bj1lLm5leHRFZmZlY3QsZS5uZXh0RWZmZWN0PW51bGwsZT1ufXJldHVybiBPbD10LHFvKCksITB9ZnVuY3Rpb24gYnUoZSx0LG4pe3NpKGUsdD1obChlLHQ9SmEobix0KSwxMDczNzQxODIzKSksbnVsbCE9PShlPVFsKGUsMTA3Mzc0MTgyMykpJiZHbChlKX1mdW5jdGlvbiB5dShlLHQpe2lmKDM9PT1lLnRhZylidShlLGUsdCk7ZWxzZSBmb3IodmFyIG49ZS5yZXR1cm47bnVsbCE9PW47KXtpZigzPT09bi50YWcpe2J1KG4sZSx0KTticmVha31pZigxPT09bi50YWcpe3ZhciByPW4uc3RhdGVOb2RlO2lmKCJmdW5jdGlvbiI9PT10eXBlb2Ygbi50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8ImZ1bmN0aW9uIj09PXR5cGVvZiByLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PUxsfHwhTGwuaGFzKHIpKSl7c2kobixlPW1sKG4sZT1KYSh0LGUpLDEwNzM3NDE4MjMpKSxudWxsIT09KG49UWwobiwxMDczNzQxODIzKSkmJkdsKG4pO2JyZWFrfX1uPW4ucmV0dXJufX1mdW5jdGlvbiBndShlLHQsbil7dmFyIHI9ZS5waW5nQ2FjaGU7bnVsbCE9PXImJnIuZGVsZXRlKHQpLGtsPT09ZSYmQ2w9PT1uP2psPT09RWx8fGpsPT09eGwmJjEwNzM3NDE4MjM9PT1QbCYm",
                    "JG8oKS1BbDw1MDA/bnUoZSxDbCk6X2w9ITA6TXUoZSxuKSYmKDAhPT0odD1lLmxhc3RQaW5nZWRUaW1lKSYmdDxufHwoZS5sYXN0UGluZ2VkVGltZT1uLEdsKGUpKSl9ZnVuY3Rpb24gd3UoZSx0KXt2YXIgbj1lLnN0YXRlTm9kZTtudWxsIT09biYmbi5kZWxldGUodCksMD09PSh0PTApJiYodD1LbCh0PXFsKCksZSxudWxsKSksbnVsbCE9PShlPVFsKGUsdCkpJiZHbChlKX12bD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dC5leHBpcmF0aW9uVGltZTtpZihudWxsIT09ZSl7dmFyIG89dC5wZW5kaW5nUHJvcHM7aWYoZS5tZW1vaXplZFByb3BzIT09b3x8cG8uY3VycmVudClSYT0hMDtlbHNle2lmKHI8bil7c3dpdGNoKFJhPSExLHQudGFnKXtjYXNlIDM6RmEodCksVGEoKTticmVhaztjYXNlIDU6aWYoQWkodCksNCZ0Lm1vZGUmJjEhPT1uJiZvLmhpZGRlbilyZXR1cm4gdC5leHBpcmF0aW9uVGltZT10LmNoaWxkRXhwaXJhdGlvblRpbWU9MSxudWxsO2JyZWFrO2Nhc2UgMTp2byh0LnR5cGUpJiZ3byh0KTticmVhaztjYXNlIDQ6TWkodCx0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOnI9dC5tZW1vaXplZFByb3BzLnZhbHVlLG89dC50eXBlLl9jb250ZXh0LHNvKFhvLG8uX2N1cnJlbnRWYWx1ZSksby5fY3VycmVudFZhbHVlPXI7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09dC5tZW1vaXplZFN0YXRlKXJldHVybiAwIT09KHI9dC5jaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lKSYmcj49bj9WYShlLHQs",
                    "bik6KHNvKERpLDEmRGkuY3VycmVudCksbnVsbCE9PSh0PVlhKGUsdCxuKSk/dC5zaWJsaW5nOm51bGwpO3NvKERpLDEmRGkuY3VycmVudCk7YnJlYWs7Y2FzZSAxOTppZihyPXQuY2hpbGRFeHBpcmF0aW9uVGltZT49biwwIT09KDY0JmUuZWZmZWN0VGFnKSl7aWYocilyZXR1cm4gS2EoZSx0LG4pO3QuZWZmZWN0VGFnfD02NH1pZihudWxsIT09KG89dC5tZW1vaXplZFN0YXRlKSYmKG8ucmVuZGVyaW5nPW51bGwsby50YWlsPW51bGwpLHNvKERpLERpLmN1cnJlbnQpLCFyKXJldHVybiBudWxsfXJldHVybiBZYShlLHQsbil9UmE9ITF9fWVsc2UgUmE9ITE7c3dpdGNoKHQuZXhwaXJhdGlvblRpbWU9MCx0LnRhZyl7Y2FzZSAyOmlmKHI9dC50eXBlLG51bGwhPT1lJiYoZS5hbHRlcm5hdGU9bnVsbCx0LmFsdGVybmF0ZT1udWxsLHQuZWZmZWN0VGFnfD0yKSxlPXQucGVuZGluZ1Byb3BzLG89bW8odCxmby5jdXJyZW50KSxyaSh0LG4pLG89WWkobnVsbCx0LHIsZSxvLG4pLHQuZWZmZWN0VGFnfD0xLCJvYmplY3QiPT09dHlwZW9mIG8mJm51bGwhPT1vJiYiZnVuY3Rpb24iPT09dHlwZW9mIG8ucmVuZGVyJiZ2b2lkIDA9PT1vLiQkdHlwZW9mKXtpZih0LnRhZz0xLHQubWVtb2l6ZWRTdGF0ZT1udWxsLHQudXBkYXRlUXVldWU9bnVsbCx2byhyKSl7dmFyIGk9ITA7d28odCl9ZWxzZSBpPSExO3QubWVtb2l6ZWRTdGF0ZT1udWxsIT09by5zdGF0ZSYmdm9pZCAwIT09by5zdGF0ZT9vLnN0YXRlOm51bGwsYWkodCk7dmFyIGw9ci5n",
                    "ZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7ImZ1bmN0aW9uIj09PXR5cGVvZiBsJiZtaSh0LHIsbCxlKSxvLnVwZGF0ZXI9dmksdC5zdGF0ZU5vZGU9byxvLl9yZWFjdEludGVybmFsRmliZXI9dCx3aSh0LHIsZSxuKSx0PUxhKG51bGwsdCxyLCEwLGksbil9ZWxzZSB0LnRhZz0wLE5hKG51bGwsdCxvLG4pLHQ9dC5jaGlsZDtyZXR1cm4gdDtjYXNlIDE2OmU6e2lmKG89dC5lbGVtZW50VHlwZSxudWxsIT09ZSYmKGUuYWx0ZXJuYXRlPW51bGwsdC5hbHRlcm5hdGU9bnVsbCx0LmVmZmVjdFRhZ3w9MiksZT10LnBlbmRpbmdQcm9wcyxmdW5jdGlvbihlKXtpZigtMT09PWUuX3N0YXR1cyl7ZS5fc3RhdHVzPTA7dmFyIHQ9ZS5fY3Rvcjt0PXQoKSxlLl9yZXN1bHQ9dCx0LnRoZW4oKGZ1bmN0aW9uKHQpezA9PT1lLl9zdGF0dXMmJih0PXQuZGVmYXVsdCxlLl9zdGF0dXM9MSxlLl9yZXN1bHQ9dCl9KSwoZnVuY3Rpb24odCl7MD09PWUuX3N0YXR1cyYmKGUuX3N0YXR1cz0yLGUuX3Jlc3VsdD10KX0pKX19KG8pLDEhPT1vLl9zdGF0dXMpdGhyb3cgby5fcmVzdWx0O3N3aXRjaChvPW8uX3Jlc3VsdCx0LnR5cGU9byxpPXQudGFnPWZ1bmN0aW9uKGUpe2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgZSlyZXR1cm4gU3UoZSk/MTowO2lmKHZvaWQgMCE9PWUmJm51bGwhPT1lKXtpZigoZT1lLiQkdHlwZW9mKT09PXVlKXJldHVybiAxMTtpZihlPT09ZGUpcmV0dXJuIDE0fXJldHVybiAyfShvKSxlPVFvKG8sZSksaSl7Y2FzZSAwOnQ9RGEobnVs",
                    "bCx0LG8sZSxuKTticmVhayBlO2Nhc2UgMTp0PXphKG51bGwsdCxvLGUsbik7YnJlYWsgZTtjYXNlIDExOnQ9TWEobnVsbCx0LG8sZSxuKTticmVhayBlO2Nhc2UgMTQ6dD1fYShudWxsLHQsbyxRbyhvLnR5cGUsZSkscixuKTticmVhayBlfXRocm93IEVycm9yKGEoMzA2LG8sIiIpKX1yZXR1cm4gdDtjYXNlIDA6cmV0dXJuIHI9dC50eXBlLG89dC5wZW5kaW5nUHJvcHMsRGEoZSx0LHIsbz10LmVsZW1lbnRUeXBlPT09cj9vOlFvKHIsbyksbik7Y2FzZSAxOnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLHphKGUsdCxyLG89dC5lbGVtZW50VHlwZT09PXI/bzpRbyhyLG8pLG4pO2Nhc2UgMzppZihGYSh0KSxyPXQudXBkYXRlUXVldWUsbnVsbD09PWV8fG51bGw9PT1yKXRocm93IEVycm9yKGEoMjgyKSk7aWYocj10LnBlbmRpbmdQcm9wcyxvPW51bGwhPT0obz10Lm1lbW9pemVkU3RhdGUpP28uZWxlbWVudDpudWxsLGxpKGUsdCksZGkodCxyLG51bGwsbiksKHI9dC5tZW1vaXplZFN0YXRlLmVsZW1lbnQpPT09bylUYSgpLHQ9WWEoZSx0LG4pO2Vsc2V7aWYoKG89dC5zdGF0ZU5vZGUuaHlkcmF0ZSkmJih4YT14bih0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvLmZpcnN0Q2hpbGQpLHdhPXQsbz1FYT0hMCksbylmb3Iobj1DaSh0LG51bGwscixuKSx0LmNoaWxkPW47bjspbi5lZmZlY3RUYWc9LTMmbi5lZmZlY3RUYWd8MTAyNCxuPW4uc2libGluZztlbHNlIE5hKGUsdCxyLG4pLFRhKCk7dD10LmNoaWxkfXJldHVy",
                    "biB0O2Nhc2UgNTpyZXR1cm4gQWkodCksbnVsbD09PWUmJlNhKHQpLHI9dC50eXBlLG89dC5wZW5kaW5nUHJvcHMsaT1udWxsIT09ZT9lLm1lbW9pemVkUHJvcHM6bnVsbCxsPW8uY2hpbGRyZW4seW4ocixvKT9sPW51bGw6bnVsbCE9PWkmJnluKHIsaSkmJih0LmVmZmVjdFRhZ3w9MTYpLElhKGUsdCksNCZ0Lm1vZGUmJjEhPT1uJiZvLmhpZGRlbj8odC5leHBpcmF0aW9uVGltZT10LmNoaWxkRXhwaXJhdGlvblRpbWU9MSx0PW51bGwpOihOYShlLHQsbCxuKSx0PXQuY2hpbGQpLHQ7Y2FzZSA2OnJldHVybiBudWxsPT09ZSYmU2EodCksbnVsbDtjYXNlIDEzOnJldHVybiBWYShlLHQsbik7Y2FzZSA0OnJldHVybiBNaSh0LHQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLHI9dC5wZW5kaW5nUHJvcHMsbnVsbD09PWU/dC5jaGlsZD1TaSh0LG51bGwscixuKTpOYShlLHQscixuKSx0LmNoaWxkO2Nhc2UgMTE6cmV0dXJuIHI9dC50eXBlLG89dC5wZW5kaW5nUHJvcHMsTWEoZSx0LHIsbz10LmVsZW1lbnRUeXBlPT09cj9vOlFvKHIsbyksbik7Y2FzZSA3OnJldHVybiBOYShlLHQsdC5wZW5kaW5nUHJvcHMsbiksdC5jaGlsZDtjYXNlIDg6Y2FzZSAxMjpyZXR1cm4gTmEoZSx0LHQucGVuZGluZ1Byb3BzLmNoaWxkcmVuLG4pLHQuY2hpbGQ7Y2FzZSAxMDplOntyPXQudHlwZS5fY29udGV4dCxvPXQucGVuZGluZ1Byb3BzLGw9dC5tZW1vaXplZFByb3BzLGk9by52YWx1ZTt2YXIgdT10LnR5cGUuX2NvbnRleHQ7aWYoc28oWG8sdS5f",
                    "Y3VycmVudFZhbHVlKSx1Ll9jdXJyZW50VmFsdWU9aSxudWxsIT09bClpZih1PWwudmFsdWUsMD09PShpPXpyKHUsaSk/MDowfCgiZnVuY3Rpb24iPT09dHlwZW9mIHIuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzP3IuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzKHUsaSk6MTA3Mzc0MTgyMykpKXtpZihsLmNoaWxkcmVuPT09by5jaGlsZHJlbiYmIXBvLmN1cnJlbnQpe3Q9WWEoZSx0LG4pO2JyZWFrIGV9fWVsc2UgZm9yKG51bGwhPT0odT10LmNoaWxkKSYmKHUucmV0dXJuPXQpO251bGwhPT11Oyl7dmFyIHM9dS5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PXMpe2w9dS5jaGlsZDtmb3IodmFyIGM9cy5maXJzdENvbnRleHQ7bnVsbCE9PWM7KXtpZihjLmNvbnRleHQ9PT1yJiYwIT09KGMub2JzZXJ2ZWRCaXRzJmkpKXsxPT09dS50YWcmJigoYz11aShuLG51bGwpKS50YWc9MixzaSh1LGMpKSx1LmV4cGlyYXRpb25UaW1lPG4mJih1LmV4cGlyYXRpb25UaW1lPW4pLG51bGwhPT0oYz11LmFsdGVybmF0ZSkmJmMuZXhwaXJhdGlvblRpbWU8biYmKGMuZXhwaXJhdGlvblRpbWU9biksbmkodS5yZXR1cm4sbikscy5leHBpcmF0aW9uVGltZTxuJiYocy5leHBpcmF0aW9uVGltZT1uKTticmVha31jPWMubmV4dH19ZWxzZSBsPTEwPT09dS50YWcmJnUudHlwZT09PXQudHlwZT9udWxsOnUuY2hpbGQ7aWYobnVsbCE9PWwpbC5yZXR1cm49dTtlbHNlIGZvcihsPXU7bnVsbCE9PWw7KXtpZihsPT09dCl7bD1udWxsO2JyZWFrfWlmKG51bGwhPT0odT1s",
                    "LnNpYmxpbmcpKXt1LnJldHVybj1sLnJldHVybixsPXU7YnJlYWt9bD1sLnJldHVybn11PWx9TmEoZSx0LG8uY2hpbGRyZW4sbiksdD10LmNoaWxkfXJldHVybiB0O2Nhc2UgOTpyZXR1cm4gbz10LnR5cGUscj0oaT10LnBlbmRpbmdQcm9wcykuY2hpbGRyZW4scmkodCxuKSxyPXIobz1vaShvLGkudW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSksdC5lZmZlY3RUYWd8PTEsTmEoZSx0LHIsbiksdC5jaGlsZDtjYXNlIDE0OnJldHVybiBpPVFvKG89dC50eXBlLHQucGVuZGluZ1Byb3BzKSxfYShlLHQsbyxpPVFvKG8udHlwZSxpKSxyLG4pO2Nhc2UgMTU6cmV0dXJuIEFhKGUsdCx0LnR5cGUsdC5wZW5kaW5nUHJvcHMscixuKTtjYXNlIDE3OnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLG89dC5lbGVtZW50VHlwZT09PXI/bzpRbyhyLG8pLG51bGwhPT1lJiYoZS5hbHRlcm5hdGU9bnVsbCx0LmFsdGVybmF0ZT1udWxsLHQuZWZmZWN0VGFnfD0yKSx0LnRhZz0xLHZvKHIpPyhlPSEwLHdvKHQpKTplPSExLHJpKHQsbikseWkodCxyLG8pLHdpKHQscixvLG4pLExhKG51bGwsdCxyLCEwLGUsbik7Y2FzZSAxOTpyZXR1cm4gS2EoZSx0LG4pfXRocm93IEVycm9yKGEoMTU2LHQudGFnKSl9O3ZhciB4dT1udWxsLEV1PW51bGw7ZnVuY3Rpb24gT3UoZSx0LG4scil7dGhpcy50YWc9ZSx0aGlzLmtleT1uLHRoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXMucmV0dXJuPXRoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT10aGlzLmVsZW1l",
                    "bnRUeXBlPW51bGwsdGhpcy5pbmRleD0wLHRoaXMucmVmPW51bGwsdGhpcy5wZW5kaW5nUHJvcHM9dCx0aGlzLmRlcGVuZGVuY2llcz10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbCx0aGlzLm1vZGU9cix0aGlzLmVmZmVjdFRhZz0wLHRoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsLHRoaXMuY2hpbGRFeHBpcmF0aW9uVGltZT10aGlzLmV4cGlyYXRpb25UaW1lPTAsdGhpcy5hbHRlcm5hdGU9bnVsbH1mdW5jdGlvbiBrdShlLHQsbixyKXtyZXR1cm4gbmV3IE91KGUsdCxuLHIpfWZ1bmN0aW9uIFN1KGUpe3JldHVybiEoIShlPWUucHJvdG90eXBlKXx8IWUuaXNSZWFjdENvbXBvbmVudCl9ZnVuY3Rpb24gQ3UoZSx0KXt2YXIgbj1lLmFsdGVybmF0ZTtyZXR1cm4gbnVsbD09PW4/KChuPWt1KGUudGFnLHQsZS5rZXksZS5tb2RlKSkuZWxlbWVudFR5cGU9ZS5lbGVtZW50VHlwZSxuLnR5cGU9ZS50eXBlLG4uc3RhdGVOb2RlPWUuc3RhdGVOb2RlLG4uYWx0ZXJuYXRlPWUsZS5hbHRlcm5hdGU9bik6KG4ucGVuZGluZ1Byb3BzPXQsbi5lZmZlY3RUYWc9MCxuLm5leHRFZmZlY3Q9bnVsbCxuLmZpcnN0RWZmZWN0PW51bGwsbi5sYXN0RWZmZWN0PW51bGwpLG4uY2hpbGRFeHBpcmF0aW9uVGltZT1lLmNoaWxkRXhwaXJhdGlvblRpbWUsbi5leHBpcmF0aW9uVGltZT1lLmV4cGlyYXRpb25UaW1lLG4uY2hpbGQ9ZS5jaGlsZCxu",
                    "Lm1lbW9pemVkUHJvcHM9ZS5tZW1vaXplZFByb3BzLG4ubWVtb2l6ZWRTdGF0ZT1lLm1lbW9pemVkU3RhdGUsbi51cGRhdGVRdWV1ZT1lLnVwZGF0ZVF1ZXVlLHQ9ZS5kZXBlbmRlbmNpZXMsbi5kZXBlbmRlbmNpZXM9bnVsbD09PXQ/bnVsbDp7ZXhwaXJhdGlvblRpbWU6dC5leHBpcmF0aW9uVGltZSxmaXJzdENvbnRleHQ6dC5maXJzdENvbnRleHQscmVzcG9uZGVyczp0LnJlc3BvbmRlcnN9LG4uc2libGluZz1lLnNpYmxpbmcsbi5pbmRleD1lLmluZGV4LG4ucmVmPWUucmVmLG59ZnVuY3Rpb24ganUoZSx0LG4scixvLGkpe3ZhciBsPTI7aWYocj1lLCJmdW5jdGlvbiI9PT10eXBlb2YgZSlTdShlKSYmKGw9MSk7ZWxzZSBpZigic3RyaW5nIj09PXR5cGVvZiBlKWw9NTtlbHNlIGU6c3dpdGNoKGUpe2Nhc2UgbmU6cmV0dXJuIFR1KG4uY2hpbGRyZW4sbyxpLHQpO2Nhc2UgbGU6bD04LG98PTc7YnJlYWs7Y2FzZSByZTpsPTgsb3w9MTticmVhaztjYXNlIG9lOnJldHVybihlPWt1KDEyLG4sdCw4fG8pKS5lbGVtZW50VHlwZT1vZSxlLnR5cGU9b2UsZS5leHBpcmF0aW9uVGltZT1pLGU7Y2FzZSBzZTpyZXR1cm4oZT1rdSgxMyxuLHQsbykpLnR5cGU9c2UsZS5lbGVtZW50VHlwZT1zZSxlLmV4cGlyYXRpb25UaW1lPWksZTtjYXNlIGNlOnJldHVybihlPWt1KDE5LG4sdCxvKSkuZWxlbWVudFR5cGU9Y2UsZS5leHBpcmF0aW9uVGltZT1pLGU7ZGVmYXVsdDppZigib2JqZWN0Ij09PXR5cGVvZiBlJiZudWxsIT09ZSlzd2l0Y2go",
                    "ZS4kJHR5cGVvZil7Y2FzZSBpZTpsPTEwO2JyZWFrIGU7Y2FzZSBhZTpsPTk7YnJlYWsgZTtjYXNlIHVlOmw9MTE7YnJlYWsgZTtjYXNlIGRlOmw9MTQ7YnJlYWsgZTtjYXNlIGZlOmw9MTYscj1udWxsO2JyZWFrIGU7Y2FzZSBwZTpsPTIyO2JyZWFrIGV9dGhyb3cgRXJyb3IoYSgxMzAsbnVsbD09ZT9lOnR5cGVvZiBlLCIiKSl9cmV0dXJuKHQ9a3UobCxuLHQsbykpLmVsZW1lbnRUeXBlPWUsdC50eXBlPXIsdC5leHBpcmF0aW9uVGltZT1pLHR9ZnVuY3Rpb24gVHUoZSx0LG4scil7cmV0dXJuKGU9a3UoNyxlLHIsdCkpLmV4cGlyYXRpb25UaW1lPW4sZX1mdW5jdGlvbiBQdShlLHQsbil7cmV0dXJuKGU9a3UoNixlLG51bGwsdCkpLmV4cGlyYXRpb25UaW1lPW4sZX1mdW5jdGlvbiBSdShlLHQsbil7cmV0dXJuKHQ9a3UoNCxudWxsIT09ZS5jaGlsZHJlbj9lLmNoaWxkcmVuOltdLGUua2V5LHQpKS5leHBpcmF0aW9uVGltZT1uLHQuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmUuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjplLmltcGxlbWVudGF0aW9ufSx0fWZ1bmN0aW9uIE51KGUsdCxuKXt0aGlzLnRhZz10LHRoaXMuY3VycmVudD1udWxsLHRoaXMuY29udGFpbmVySW5mbz1lLHRoaXMucGluZ0NhY2hlPXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGwsdGhpcy5maW5pc2hlZEV4cGlyYXRpb25UaW1lPTAsdGhpcy5maW5pc2hlZFdvcms9bnVsbCx0aGlzLnRpbWVvdXRIYW5kbGU9",
                    "LTEsdGhpcy5wZW5kaW5nQ29udGV4dD10aGlzLmNvbnRleHQ9bnVsbCx0aGlzLmh5ZHJhdGU9bix0aGlzLmNhbGxiYWNrTm9kZT1udWxsLHRoaXMuY2FsbGJhY2tQcmlvcml0eT05MCx0aGlzLmxhc3RFeHBpcmVkVGltZT10aGlzLmxhc3RQaW5nZWRUaW1lPXRoaXMubmV4dEtub3duUGVuZGluZ0xldmVsPXRoaXMubGFzdFN1c3BlbmRlZFRpbWU9dGhpcy5maXJzdFN1c3BlbmRlZFRpbWU9dGhpcy5maXJzdFBlbmRpbmdUaW1lPTB9ZnVuY3Rpb24gTXUoZSx0KXt2YXIgbj1lLmZpcnN0U3VzcGVuZGVkVGltZTtyZXR1cm4gZT1lLmxhc3RTdXNwZW5kZWRUaW1lLDAhPT1uJiZuPj10JiZlPD10fWZ1bmN0aW9uIF91KGUsdCl7dmFyIG49ZS5maXJzdFN1c3BlbmRlZFRpbWUscj1lLmxhc3RTdXNwZW5kZWRUaW1lO248dCYmKGUuZmlyc3RTdXNwZW5kZWRUaW1lPXQpLChyPnR8fDA9PT1uKSYmKGUubGFzdFN1c3BlbmRlZFRpbWU9dCksdDw9ZS5sYXN0UGluZ2VkVGltZSYmKGUubGFzdFBpbmdlZFRpbWU9MCksdDw9ZS5sYXN0RXhwaXJlZFRpbWUmJihlLmxhc3RFeHBpcmVkVGltZT0wKX1mdW5jdGlvbiBBdShlLHQpe3Q+ZS5maXJzdFBlbmRpbmdUaW1lJiYoZS5maXJzdFBlbmRpbmdUaW1lPXQpO3ZhciBuPWUuZmlyc3RTdXNwZW5kZWRUaW1lOzAhPT1uJiYodD49bj9lLmZpcnN0U3VzcGVuZGVkVGltZT1lLmxhc3RTdXNwZW5kZWRUaW1lPWUubmV4dEtub3duUGVuZGluZ0xldmVsPTA6dD49ZS5sYXN0U3VzcGVuZGVkVGltZSYmKGUu",
                    "bGFzdFN1c3BlbmRlZFRpbWU9dCsxKSx0PmUubmV4dEtub3duUGVuZGluZ0xldmVsJiYoZS5uZXh0S25vd25QZW5kaW5nTGV2ZWw9dCkpfWZ1bmN0aW9uIEl1KGUsdCl7dmFyIG49ZS5sYXN0RXhwaXJlZFRpbWU7KDA9PT1ufHxuPnQpJiYoZS5sYXN0RXhwaXJlZFRpbWU9dCl9ZnVuY3Rpb24gRHUoZSx0LG4scil7dmFyIG89dC5jdXJyZW50LGk9cWwoKSxsPXBpLnN1c3BlbnNlO2k9S2woaSxvLGwpO2U6aWYobil7dDp7aWYoWmUobj1uLl9yZWFjdEludGVybmFsRmliZXIpIT09bnx8MSE9PW4udGFnKXRocm93IEVycm9yKGEoMTcwKSk7dmFyIHU9bjtkb3tzd2l0Y2godS50YWcpe2Nhc2UgMzp1PXUuc3RhdGVOb2RlLmNvbnRleHQ7YnJlYWsgdDtjYXNlIDE6aWYodm8odS50eXBlKSl7dT11LnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayB0fX11PXUucmV0dXJufXdoaWxlKG51bGwhPT11KTt0aHJvdyBFcnJvcihhKDE3MSkpfWlmKDE9PT1uLnRhZyl7dmFyIHM9bi50eXBlO2lmKHZvKHMpKXtuPWdvKG4scyx1KTticmVhayBlfX1uPXV9ZWxzZSBuPWNvO3JldHVybiBudWxsPT09dC5jb250ZXh0P3QuY29udGV4dD1uOnQucGVuZGluZ0NvbnRleHQ9biwodD11aShpLGwpKS5wYXlsb2FkPXtlbGVtZW50OmV9LG51bGwhPT0ocj12b2lkIDA9PT1yP251bGw6cikmJih0LmNhbGxiYWNrPXIpLHNpKG8sdCksWWwobyxpKSxpfWZ1bmN0aW9uIHp1KGUpe2lmKCEoZT1lLmN1cnJl",
                    "bnQpLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChlLmNoaWxkLnRhZyl7Y2FzZSA1OmRlZmF1bHQ6cmV0dXJuIGUuY2hpbGQuc3RhdGVOb2RlfX1mdW5jdGlvbiBMdShlLHQpe251bGwhPT0oZT1lLm1lbW9pemVkU3RhdGUpJiZudWxsIT09ZS5kZWh5ZHJhdGVkJiZlLnJldHJ5VGltZTx0JiYoZS5yZXRyeVRpbWU9dCl9ZnVuY3Rpb24gRnUoZSx0KXtMdShlLHQpLChlPWUuYWx0ZXJuYXRlKSYmTHUoZSx0KX1mdW5jdGlvbiAkdShlLHQsbil7dmFyIHI9bmV3IE51KGUsdCxuPW51bGwhPW4mJiEwPT09bi5oeWRyYXRlKSxvPWt1KDMsbnVsbCxudWxsLDI9PT10Pzc6MT09PXQ/MzowKTtyLmN1cnJlbnQ9byxvLnN0YXRlTm9kZT1yLGFpKG8pLGVbQ25dPXIuY3VycmVudCxuJiYwIT09dCYmZnVuY3Rpb24oZSx0KXt2YXIgbj1KZSh0KTtDdC5mb3JFYWNoKChmdW5jdGlvbihlKXtodChlLHQsbil9KSksanQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aHQoZSx0LG4pfSkpfSgwLDk9PT1lLm5vZGVUeXBlP2U6ZS5vd25lckRvY3VtZW50KSx0aGlzLl9pbnRlcm5hbFJvb3Q9cn1mdW5jdGlvbiBXdShlKXtyZXR1cm4hKCFlfHwxIT09ZS5ub2RlVHlwZSYmOSE9PWUubm9kZVR5cGUmJjExIT09ZS5ub2RlVHlwZSYmKDghPT1lLm5vZGVUeXBlfHwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICIhPT1lLm5vZGVWYWx1ZSkpfWZ1bmN0aW9uIEJ1KGUsdCxuLHIsbyl7dmFyIGk9bi5fcmVhY3RSb290Q29udGFpbmVyO2lmKGkpe3ZhciBhPWku",
                    "X2ludGVybmFsUm9vdDtpZigiZnVuY3Rpb24iPT09dHlwZW9mIG8pe3ZhciBsPW87bz1mdW5jdGlvbigpe3ZhciBlPXp1KGEpO2wuY2FsbChlKX19RHUodCxhLGUsbyl9ZWxzZXtpZihpPW4uX3JlYWN0Um9vdENvbnRhaW5lcj1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PSEoISh0PWU/OT09PWUubm9kZVR5cGU/ZS5kb2N1bWVudEVsZW1lbnQ6ZS5maXJzdENoaWxkOm51bGwpfHwxIT09dC5ub2RlVHlwZXx8IXQuaGFzQXR0cmlidXRlKCJkYXRhLXJlYWN0cm9vdCIpKSksIXQpZm9yKHZhciBuO249ZS5sYXN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQobik7cmV0dXJuIG5ldyAkdShlLDAsdD97aHlkcmF0ZTohMH06dm9pZCAwKX0obixyKSxhPWkuX2ludGVybmFsUm9vdCwiZnVuY3Rpb24iPT09dHlwZW9mIG8pe3ZhciB1PW87bz1mdW5jdGlvbigpe3ZhciBlPXp1KGEpO3UuY2FsbChlKX19dHUoKGZ1bmN0aW9uKCl7RHUodCxhLGUsbyl9KSl9cmV0dXJuIHp1KGEpfWZ1bmN0aW9uIEh1KGUsdCxuKXt2YXIgcj0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6dGUsa2V5Om51bGw9PXI/bnVsbDoiIityLGNoaWxkcmVuOmUsY29udGFpbmVySW5mbzp0LGltcGxlbWVudGF0aW9uOm59fWZ1bmN0aW9uIFZ1KGUsdCl7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7aWYoIVd1KHQpKXRo",
                    "cm93IEVycm9yKGEoMjAwKSk7cmV0dXJuIEh1KGUsdCxudWxsLG4pfSR1LnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oZSl7RHUoZSx0aGlzLl9pbnRlcm5hbFJvb3QsbnVsbCxudWxsKX0sJHUucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9pbnRlcm5hbFJvb3QsdD1lLmNvbnRhaW5lckluZm87RHUobnVsbCxlLG51bGwsKGZ1bmN0aW9uKCl7dFtDbl09bnVsbH0pKX0sbXQ9ZnVuY3Rpb24oZSl7aWYoMTM9PT1lLnRhZyl7dmFyIHQ9WW8ocWwoKSwxNTAsMTAwKTtZbChlLHQpLEZ1KGUsdCl9fSx2dD1mdW5jdGlvbihlKXsxMz09PWUudGFnJiYoWWwoZSwzKSxGdShlLDMpKX0sYnQ9ZnVuY3Rpb24oZSl7aWYoMTM9PT1lLnRhZyl7dmFyIHQ9cWwoKTtZbChlLHQ9S2wodCxlLG51bGwpKSxGdShlLHQpfX0sVD1mdW5jdGlvbihlLHQsbil7c3dpdGNoKHQpe2Nhc2UiaW5wdXQiOmlmKFNlKGUsbiksdD1uLm5hbWUsInJhZGlvIj09PW4udHlwZSYmbnVsbCE9dCl7Zm9yKG49ZTtuLnBhcmVudE5vZGU7KW49bi5wYXJlbnROb2RlO2ZvcihuPW4ucXVlcnlTZWxlY3RvckFsbCgiaW5wdXRbbmFtZT0iK0pTT04uc3RyaW5naWZ5KCIiK3QpKyddW3R5cGU9InJhZGlvIl0nKSx0PTA7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07aWYociE9PWUmJnIuZm9ybT09PWUuZm9ybSl7dmFyIG89Um4ocik7aWYoIW8pdGhyb3cgRXJyb3IoYSg5MCkpO3hlKHIpLFNlKHIsbyl9fX1icmVhaztjYXNlInRleHRhcmVhIjpN",
                    "ZShlLG4pO2JyZWFrO2Nhc2Uic2VsZWN0IjpudWxsIT0odD1uLnZhbHVlKSYmUGUoZSwhIW4ubXVsdGlwbGUsdCwhMSl9fSxBPWV1LEk9ZnVuY3Rpb24oZSx0LG4scixvKXt2YXIgaT1PbDtPbHw9NDt0cnl7cmV0dXJuIEhvKDk4LGUuYmluZChudWxsLHQsbixyLG8pKX1maW5hbGx5ezA9PT0oT2w9aSkmJnFvKCl9fSxEPWZ1bmN0aW9uKCl7MD09PSg0OSZPbCkmJihmdW5jdGlvbigpe2lmKG51bGwhPT1CbCl7dmFyIGU9Qmw7Qmw9bnVsbCxlLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7SXUodCxlKSxHbCh0KX0pKSxxbygpfX0oKSxtdSgpKX0sej1mdW5jdGlvbihlLHQpe3ZhciBuPU9sO09sfD0yO3RyeXtyZXR1cm4gZSh0KX1maW5hbGx5ezA9PT0oT2w9bikmJnFvKCl9fTt2YXIgVXU9e0V2ZW50czpbVG4sUG4sUm4sQyxPLHpuLGZ1bmN0aW9uKGUpe290KGUsRG4pfSxNLF8sR3QsbHQsbXUse2N1cnJlbnQ6ITF9XX07IWZ1bmN0aW9uKGUpe3ZhciB0PWUuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7KGZ1bmN0aW9uKGUpe2lmKCJ1bmRlZmluZWQiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgdD1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYodC5pc0Rpc2FibGVkfHwhdC5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgbj10LmluamVjdChlKTt4dT1mdW5jdGlvbihlKXt0cnl7dC5vbkNvbW1pdEZpYmVyUm9vdChuLGUsdm9pZCAwLDY0PT09KDY0JmUuY3Vy",
                    "cmVudC5lZmZlY3RUYWcpKX1jYXRjaChyKXt9fSxFdT1mdW5jdGlvbihlKXt0cnl7dC5vbkNvbW1pdEZpYmVyVW5tb3VudChuLGUpfWNhdGNoKHIpe319fWNhdGNoKHIpe319KShvKHt9LGUse292ZXJyaWRlSG9va1N0YXRlOm51bGwsb3ZlcnJpZGVQcm9wczpudWxsLHNldFN1c3BlbnNlSGFuZGxlcjpudWxsLHNjaGVkdWxlVXBkYXRlOm51bGwsY3VycmVudERpc3BhdGNoZXJSZWY6WC5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09KGU9bnQoZSkpP251bGw6ZS5zdGF0ZU5vZGV9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGUpe3JldHVybiB0P3QoZSk6bnVsbH0sZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOm51bGwsc2NoZWR1bGVSZWZyZXNoOm51bGwsc2NoZWR1bGVSb290Om51bGwsc2V0UmVmcmVzaEhhbmRsZXI6bnVsbCxnZXRDdXJyZW50RmliZXI6bnVsbH0pKX0oe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmpuLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOiIxNi4xMy4xIixyZW5kZXJlclBhY2thZ2VOYW1lOiJyZWFjdC1kb20ifSksdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1VdSx0LmNyZWF0ZVBvcnRhbD1WdSx0LmZpbmRET01Ob2RlPWZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoMT09PWUubm9kZVR5cGUpcmV0dXJuIGU7dmFyIHQ9ZS5fcmVh",
                    "Y3RJbnRlcm5hbEZpYmVyO2lmKHZvaWQgMD09PXQpe2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgZS5yZW5kZXIpdGhyb3cgRXJyb3IoYSgxODgpKTt0aHJvdyBFcnJvcihhKDI2OCxPYmplY3Qua2V5cyhlKSkpfXJldHVybiBlPW51bGw9PT0oZT1udCh0KSk/bnVsbDplLnN0YXRlTm9kZX0sdC5mbHVzaFN5bmM9ZnVuY3Rpb24oZSx0KXtpZigwIT09KDQ4Jk9sKSl0aHJvdyBFcnJvcihhKDE4NykpO3ZhciBuPU9sO09sfD0xO3RyeXtyZXR1cm4gSG8oOTksZS5iaW5kKG51bGwsdCkpfWZpbmFsbHl7T2w9bixxbygpfX0sdC5oeWRyYXRlPWZ1bmN0aW9uKGUsdCxuKXtpZighV3UodCkpdGhyb3cgRXJyb3IoYSgyMDApKTtyZXR1cm4gQnUobnVsbCxlLHQsITAsbil9LHQucmVuZGVyPWZ1bmN0aW9uKGUsdCxuKXtpZighV3UodCkpdGhyb3cgRXJyb3IoYSgyMDApKTtyZXR1cm4gQnUobnVsbCxlLHQsITEsbil9LHQudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihlKXtpZighV3UoZSkpdGhyb3cgRXJyb3IoYSg0MCkpO3JldHVybiEhZS5fcmVhY3RSb290Q29udGFpbmVyJiYodHUoKGZ1bmN0aW9uKCl7QnUobnVsbCxudWxsLGUsITEsKGZ1bmN0aW9uKCl7ZS5fcmVhY3RSb290Q29udGFpbmVyPW51bGwsZVtDbl09bnVsbH0pKX0pKSwhMCl9LHQudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9ZXUsdC51bnN0YWJsZV9jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gVnUoZSx0LDI8YXJndW1lbnRzLmxlbmd0aCYmdm9p",
                    "ZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsKX0sdC51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1mdW5jdGlvbihlLHQsbixyKXtpZighV3UobikpdGhyb3cgRXJyb3IoYSgyMDApKTtpZihudWxsPT1lfHx2b2lkIDA9PT1lLl9yZWFjdEludGVybmFsRmliZXIpdGhyb3cgRXJyb3IoYSgzOCkpO3JldHVybiBCdShlLHQsbiwhMSxyKX0sdC52ZXJzaW9uPSIxNi4xMy4xIn0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9big3Nyl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHIsbyxpLGEsbDtpZigidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3d8fCJmdW5jdGlvbiIhPT10eXBlb2YgTWVzc2FnZUNoYW5uZWwpe3ZhciB1PW51bGwscz1udWxsLGM9ZnVuY3Rpb24gZSgpe2lmKG51bGwhPT11KXRyeXt2YXIgbj10LnVuc3RhYmxlX25vdygpO3UoITAsbiksdT1udWxsfWNhdGNoKHIpe3Rocm93IHNldFRpbWVvdXQoZSwwKSxyfX0sZD1EYXRlLm5vdygpO3QudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCktZH0scj1mdW5jdGlvbihlKXtudWxsIT09dT9zZXRUaW1lb3V0KHIsMCxlKToodT1lLHNldFRpbWVvdXQoYywwKSl9LG89ZnVuY3Rpb24oZSx0KXtzPXNldFRpbWVvdXQoZSx0KX0saT1mdW5jdGlvbigpe2NsZWFyVGltZW91dChzKX0sYT1mdW5jdGlvbigpe3JldHVybiExfSxsPXQudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9",
                    "ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIGY9d2luZG93LnBlcmZvcm1hbmNlLHA9d2luZG93LkRhdGUsaD13aW5kb3cuc2V0VGltZW91dCxtPXdpbmRvdy5jbGVhclRpbWVvdXQ7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgY29uc29sZSl7dmFyIHY9d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lOyJmdW5jdGlvbiIhPT10eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSYmY29uc29sZS5lcnJvcigiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzIiksImZ1bmN0aW9uIiE9PXR5cGVvZiB2JiZjb25zb2xlLmVycm9yKCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscyIpfWlmKCJvYmplY3QiPT09dHlwZW9mIGYmJiJmdW5jdGlvbiI9PT10eXBlb2YgZi5ub3cpdC51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gZi5ub3coKX07ZWxzZXt2YXIgYj1wLm5vdygpO3QudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktYn19dmFyIHk9ITEsZz1udWxsLHc9LTEseD01LEU9MDthPWZ1bmN0aW9uKCl7cmV0dXJuIHQu",
                    "dW5zdGFibGVfbm93KCk+PUV9LGw9ZnVuY3Rpb24oKXt9LHQudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oZSl7MD5lfHwxMjU8ZT9jb25zb2xlLmVycm9yKCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZXJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHVuc3VwcG9ydGVkIik6eD0wPGU/TWF0aC5mbG9vcigxZTMvZSk6NX07dmFyIE89bmV3IE1lc3NhZ2VDaGFubmVsLGs9Ty5wb3J0MjtPLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKG51bGwhPT1nKXt2YXIgZT10LnVuc3RhYmxlX25vdygpO0U9ZSt4O3RyeXtnKCEwLGUpP2sucG9zdE1lc3NhZ2UobnVsbCk6KHk9ITEsZz1udWxsKX1jYXRjaChuKXt0aHJvdyBrLnBvc3RNZXNzYWdlKG51bGwpLG59fWVsc2UgeT0hMX0scj1mdW5jdGlvbihlKXtnPWUseXx8KHk9ITAsay5wb3N0TWVzc2FnZShudWxsKSl9LG89ZnVuY3Rpb24oZSxuKXt3PWgoKGZ1bmN0aW9uKCl7ZSh0LnVuc3RhYmxlX25vdygpKX0pLG4pfSxpPWZ1bmN0aW9uKCl7bSh3KSx3PS0xfX1mdW5jdGlvbiBTKGUsdCl7dmFyIG49ZS5sZW5ndGg7ZS5wdXNoKHQpO2U6Zm9yKDs7KXt2YXIgcj1uLTE+Pj4xLG89ZVtyXTtpZighKHZvaWQgMCE9PW8mJjA8VChvLHQpKSlicmVhayBlO2Vbcl09dCxlW25dPW8sbj1yfX1mdW5jdGlvbiBDKGUpe3JldHVybiB2b2lkIDA9PT0oZT1lWzBdKT9udWxsOmV9ZnVuY3Rp",
                    "b24gaihlKXt2YXIgdD1lWzBdO2lmKHZvaWQgMCE9PXQpe3ZhciBuPWUucG9wKCk7aWYobiE9PXQpe2VbMF09bjtlOmZvcih2YXIgcj0wLG89ZS5sZW5ndGg7cjxvOyl7dmFyIGk9MioocisxKS0xLGE9ZVtpXSxsPWkrMSx1PWVbbF07aWYodm9pZCAwIT09YSYmMD5UKGEsbikpdm9pZCAwIT09dSYmMD5UKHUsYSk/KGVbcl09dSxlW2xdPW4scj1sKTooZVtyXT1hLGVbaV09bixyPWkpO2Vsc2V7aWYoISh2b2lkIDAhPT11JiYwPlQodSxuKSkpYnJlYWsgZTtlW3JdPXUsZVtsXT1uLHI9bH19fXJldHVybiB0fXJldHVybiBudWxsfWZ1bmN0aW9uIFQoZSx0KXt2YXIgbj1lLnNvcnRJbmRleC10LnNvcnRJbmRleDtyZXR1cm4gMCE9PW4/bjplLmlkLXQuaWR9dmFyIFA9W10sUj1bXSxOPTEsTT1udWxsLF89MyxBPSExLEk9ITEsRD0hMTtmdW5jdGlvbiB6KGUpe2Zvcih2YXIgdD1DKFIpO251bGwhPT10Oyl7aWYobnVsbD09PXQuY2FsbGJhY2spaihSKTtlbHNle2lmKCEodC5zdGFydFRpbWU8PWUpKWJyZWFrO2ooUiksdC5zb3J0SW5kZXg9dC5leHBpcmF0aW9uVGltZSxTKFAsdCl9dD1DKFIpfX1mdW5jdGlvbiBMKGUpe2lmKEQ9ITEseihlKSwhSSlpZihudWxsIT09QyhQKSlJPSEwLHIoRik7ZWxzZXt2YXIgdD1DKFIpO251bGwhPT10JiZvKEwsdC5zdGFydFRpbWUtZSl9fWZ1bmN0aW9uIEYoZSxuKXtJPSExLEQmJihEPSExLGkoKSksQT0hMDt2YXIgcj1fO3RyeXtmb3IoeihuKSxNPUMoUCk7bnVsbCE9PU0mJighKE0uZXhwaXJh",
                    "dGlvblRpbWU+bil8fGUmJiFhKCkpOyl7dmFyIGw9TS5jYWxsYmFjaztpZihudWxsIT09bCl7TS5jYWxsYmFjaz1udWxsLF89TS5wcmlvcml0eUxldmVsO3ZhciB1PWwoTS5leHBpcmF0aW9uVGltZTw9bik7bj10LnVuc3RhYmxlX25vdygpLCJmdW5jdGlvbiI9PT10eXBlb2YgdT9NLmNhbGxiYWNrPXU6TT09PUMoUCkmJmooUCkseihuKX1lbHNlIGooUCk7TT1DKFApfWlmKG51bGwhPT1NKXZhciBzPSEwO2Vsc2V7dmFyIGM9QyhSKTtudWxsIT09YyYmbyhMLGMuc3RhcnRUaW1lLW4pLHM9ITF9cmV0dXJuIHN9ZmluYWxseXtNPW51bGwsXz1yLEE9ITF9fWZ1bmN0aW9uICQoZSl7c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4tMTtjYXNlIDI6cmV0dXJuIDI1MDtjYXNlIDU6cmV0dXJuIDEwNzM3NDE4MjM7Y2FzZSA0OnJldHVybiAxZTQ7ZGVmYXVsdDpyZXR1cm4gNWUzfX12YXIgVz1sO3QudW5zdGFibGVfSWRsZVByaW9yaXR5PTUsdC51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xLHQudW5zdGFibGVfTG93UHJpb3JpdHk9NCx0LnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTMsdC51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbCx0LnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTIsdC51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihlKXtlLmNhbGxiYWNrPW51bGx9LHQudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtJfHxBfHwoST0hMCxyKEYpKX0sdC51bnN0YWJsZV9nZXRDdXJyZW50UHJp",
                    "b3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBffSx0LnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIEMoUCl9LHQudW5zdGFibGVfbmV4dD1mdW5jdGlvbihlKXtzd2l0Y2goXyl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6dmFyIHQ9MzticmVhaztkZWZhdWx0OnQ9X312YXIgbj1fO189dDt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e189bn19LHQudW5zdGFibGVfcGF1c2VFeGVjdXRpb249ZnVuY3Rpb24oKXt9LHQudW5zdGFibGVfcmVxdWVzdFBhaW50PVcsdC51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk9ZnVuY3Rpb24oZSx0KXtzd2l0Y2goZSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6Y2FzZSA0OmNhc2UgNTpicmVhaztkZWZhdWx0OmU9M312YXIgbj1fO189ZTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e189bn19LHQudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaz1mdW5jdGlvbihlLG4sYSl7dmFyIGw9dC51bnN0YWJsZV9ub3coKTtpZigib2JqZWN0Ij09PXR5cGVvZiBhJiZudWxsIT09YSl7dmFyIHU9YS5kZWxheTt1PSJudW1iZXIiPT09dHlwZW9mIHUmJjA8dT9sK3U6bCxhPSJudW1iZXIiPT09dHlwZW9mIGEudGltZW91dD9hLnRpbWVvdXQ6JChlKX1lbHNlIGE9JChlKSx1PWw7cmV0dXJuIGU9e2lkOk4rKyxjYWxsYmFjazpuLHByaW9yaXR5TGV2ZWw6ZSxzdGFydFRpbWU6dSxleHBpcmF0aW9uVGltZTphPXUrYSxzb3J0SW5kZXg6LTF9LHU+bD8oZS5zb3J0SW5kZXg9dSxTKFIsZSks",
                    "bnVsbD09PUMoUCkmJmU9PT1DKFIpJiYoRD9pKCk6RD0hMCxvKEwsdS1sKSkpOihlLnNvcnRJbmRleD1hLFMoUCxlKSxJfHxBfHwoST0hMCxyKEYpKSksZX0sdC51bnN0YWJsZV9zaG91bGRZaWVsZD1mdW5jdGlvbigpe3ZhciBlPXQudW5zdGFibGVfbm93KCk7eihlKTt2YXIgbj1DKFApO3JldHVybiBuIT09TSYmbnVsbCE9PU0mJm51bGwhPT1uJiZudWxsIT09bi5jYWxsYmFjayYmbi5zdGFydFRpbWU8PWUmJm4uZXhwaXJhdGlvblRpbWU8TS5leHBpcmF0aW9uVGltZXx8YSgpfSx0LnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihlKXt2YXIgdD1fO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPV87Xz10O3RyeXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtfPW59fX19LCwsZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDgxKTtmdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIGkoKXt9aS5yZXNldFdhcm5pbmdDYWNoZT1vLGUuZXhwb3J0cz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4sbyxpLGEpe2lmKGEhPT1yKXt2YXIgbD1uZXcgRXJyb3IoIkNhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFVzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uIFJlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMiKTt0aHJvdyBsLm5h",
                    "bWU9IkludmFyaWFudCBWaW9sYXRpb24iLGx9fWZ1bmN0aW9uIHQoKXtyZXR1cm4gZX1lLmlzUmVxdWlyZWQ9ZTt2YXIgbj17YXJyYXk6ZSxib29sOmUsZnVuYzplLG51bWJlcjplLG9iamVjdDplLHN0cmluZzplLHN5bWJvbDplLGFueTplLGFycmF5T2Y6dCxlbGVtZW50OmUsZWxlbWVudFR5cGU6ZSxpbnN0YW5jZU9mOnQsbm9kZTplLG9iamVjdE9mOnQsb25lT2Y6dCxvbmVPZlR5cGU6dCxzaGFwZTp0LGV4YWN0OnQsY2hlY2tQcm9wVHlwZXM6aSxyZXNldFdhcm5pbmdDYWNoZTpvfTtyZXR1cm4gbi5Qcm9wVHlwZXM9bixufX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9IlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEIn0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj0iZnVuY3Rpb24iPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcixvPXI/U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpOjYwMTAzLGk9cj9TeW1ib2wuZm9yKCJyZWFjdC5wb3J0YWwiKTo2MDEwNixhPXI/U3ltYm9sLmZvcigicmVhY3QuZnJhZ21lbnQiKTo2MDEwNyxsPXI/U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKTo2MDEwOCx1PXI/U3ltYm9sLmZvcigicmVhY3QucHJvZmlsZXIiKTo2MDExNCxzPXI/U3ltYm9sLmZvcigicmVhY3QucHJvdmlkZXIiKTo2MDEwOSxjPXI/U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpOjYwMTEwLGQ9cj9TeW1ib2wuZm9yKCJy",
                    "ZWFjdC5hc3luY19tb2RlIik6NjAxMTEsZj1yP1N5bWJvbC5mb3IoInJlYWN0LmNvbmN1cnJlbnRfbW9kZSIpOjYwMTExLHA9cj9TeW1ib2wuZm9yKCJyZWFjdC5mb3J3YXJkX3JlZiIpOjYwMTEyLGg9cj9TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpOjYwMTEzLG09cj9TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZV9saXN0Iik6NjAxMjAsdj1yP1N5bWJvbC5mb3IoInJlYWN0Lm1lbW8iKTo2MDExNSxiPXI/U3ltYm9sLmZvcigicmVhY3QubGF6eSIpOjYwMTE2LHk9cj9TeW1ib2wuZm9yKCJyZWFjdC5ibG9jayIpOjYwMTIxLGc9cj9TeW1ib2wuZm9yKCJyZWFjdC5mdW5kYW1lbnRhbCIpOjYwMTE3LHc9cj9TeW1ib2wuZm9yKCJyZWFjdC5yZXNwb25kZXIiKTo2MDExOCx4PXI/U3ltYm9sLmZvcigicmVhY3Quc2NvcGUiKTo2MDExOTtmdW5jdGlvbiBFKGUpe2lmKCJvYmplY3QiPT09dHlwZW9mIGUmJm51bGwhPT1lKXt2YXIgdD1lLiQkdHlwZW9mO3N3aXRjaCh0KXtjYXNlIG86c3dpdGNoKGU9ZS50eXBlKXtjYXNlIGQ6Y2FzZSBmOmNhc2UgYTpjYXNlIHU6Y2FzZSBsOmNhc2UgaDpyZXR1cm4gZTtkZWZhdWx0OnN3aXRjaChlPWUmJmUuJCR0eXBlb2Ype2Nhc2UgYzpjYXNlIHA6Y2FzZSBiOmNhc2UgdjpjYXNlIHM6cmV0dXJuIGU7ZGVmYXVsdDpyZXR1cm4gdH19Y2FzZSBpOnJldHVybiB0fX19ZnVuY3Rpb24gTyhlKXtyZXR1cm4gRShlKT09PWZ9dC5Bc3luY01vZGU9ZCx0LkNvbmN1cnJlbnRNb2RlPWYsdC5Db250",
                    "ZXh0Q29uc3VtZXI9Yyx0LkNvbnRleHRQcm92aWRlcj1zLHQuRWxlbWVudD1vLHQuRm9yd2FyZFJlZj1wLHQuRnJhZ21lbnQ9YSx0Lkxhenk9Yix0Lk1lbW89dix0LlBvcnRhbD1pLHQuUHJvZmlsZXI9dSx0LlN0cmljdE1vZGU9bCx0LlN1c3BlbnNlPWgsdC5pc0FzeW5jTW9kZT1mdW5jdGlvbihlKXtyZXR1cm4gTyhlKXx8RShlKT09PWR9LHQuaXNDb25jdXJyZW50TW9kZT1PLHQuaXNDb250ZXh0Q29uc3VtZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSk9PT1jfSx0LmlzQ29udGV4dFByb3ZpZGVyPWZ1bmN0aW9uKGUpe3JldHVybiBFKGUpPT09c30sdC5pc0VsZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIm9iamVjdCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJmUuJCR0eXBlb2Y9PT1vfSx0LmlzRm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm4gRShlKT09PXB9LHQuaXNGcmFnbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gRShlKT09PWF9LHQuaXNMYXp5PWZ1bmN0aW9uKGUpe3JldHVybiBFKGUpPT09Yn0sdC5pc01lbW89ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSk9PT12fSx0LmlzUG9ydGFsPWZ1bmN0aW9uKGUpe3JldHVybiBFKGUpPT09aX0sdC5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGUpe3JldHVybiBFKGUpPT09dX0sdC5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSk9PT1sfSx0LmlzU3VzcGVuc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSk9PT1ofSx0LmlzVmFsaWRFbGVtZW50VHlwZT1mdW5jdGlvbihl",
                    "KXtyZXR1cm4ic3RyaW5nIj09PXR5cGVvZiBlfHwiZnVuY3Rpb24iPT09dHlwZW9mIGV8fGU9PT1hfHxlPT09Znx8ZT09PXV8fGU9PT1sfHxlPT09aHx8ZT09PW18fCJvYmplY3QiPT09dHlwZW9mIGUmJm51bGwhPT1lJiYoZS4kJHR5cGVvZj09PWJ8fGUuJCR0eXBlb2Y9PT12fHxlLiQkdHlwZW9mPT09c3x8ZS4kJHR5cGVvZj09PWN8fGUuJCR0eXBlb2Y9PT1wfHxlLiQkdHlwZW9mPT09Z3x8ZS4kJHR5cGVvZj09PXd8fGUuJCR0eXBlb2Y9PT14fHxlLiQkdHlwZW9mPT09eSl9LHQudHlwZU9mPUV9LGZ1bmN0aW9uKGUsdCl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoKHIpeyJvYmplY3QiPT09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoIWUud2VicGFja1BvbHlmaWxsKXt2YXIgdD1PYmplY3QuY3JlYXRlKGUpO3QuY2hpbGRyZW58fCh0LmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwibG9hZGVkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJpZCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuaX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZXhwb3J0cyIse2VudW1lcmFibGU6ITB9KSx0LndlYnBhY2tQ",
                    "b2x5ZmlsbD0xfXJldHVybiB0fX0sZnVuY3Rpb24oZSx0LG4pe3ZhciByPWZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0Ijt2YXIgdD1PYmplY3QucHJvdG90eXBlLG49dC5oYXNPd25Qcm9wZXJ0eSxyPSJmdW5jdGlvbiI9PT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxvPXIuaXRlcmF0b3J8fCJAQGl0ZXJhdG9yIixpPXIuYXN5bmNJdGVyYXRvcnx8IkBAYXN5bmNJdGVyYXRvciIsYT1yLnRvU3RyaW5nVGFnfHwiQEB0b1N0cmluZ1RhZyI7ZnVuY3Rpb24gbChlLHQsbixyKXt2YXIgbz10JiZ0LnByb3RvdHlwZSBpbnN0YW5jZW9mIGM/dDpjLGk9T2JqZWN0LmNyZWF0ZShvLnByb3RvdHlwZSksYT1uZXcgRShyfHxbXSk7cmV0dXJuIGkuX2ludm9rZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9InN1c3BlbmRlZFN0YXJ0IjtyZXR1cm4gZnVuY3Rpb24obyxpKXtpZigiZXhlY3V0aW5nIj09PXIpdGhyb3cgbmV3IEVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nIik7aWYoImNvbXBsZXRlZCI9PT1yKXtpZigidGhyb3ciPT09byl0aHJvdyBpO3JldHVybiBrKCl9Zm9yKG4ubWV0aG9kPW8sbi5hcmc9aTs7KXt2YXIgYT1uLmRlbGVnYXRlO2lmKGEpe3ZhciBsPWcoYSxuKTtpZihsKXtpZihsPT09cyljb250aW51ZTtyZXR1cm4gbH19aWYoIm5leHQiPT09bi5tZXRob2Qpbi5zZW50PW4uX3NlbnQ9bi5hcmc7ZWxzZSBpZigidGhyb3ciPT09bi5tZXRob2Qpe2lmKCJzdXNwZW5kZWRTdGFydCI9PT1yKXRocm93IHI9ImNvbXBs",
                    "ZXRlZCIsbi5hcmc7bi5kaXNwYXRjaEV4Y2VwdGlvbihuLmFyZyl9ZWxzZSJyZXR1cm4iPT09bi5tZXRob2QmJm4uYWJydXB0KCJyZXR1cm4iLG4uYXJnKTtyPSJleGVjdXRpbmciO3ZhciBjPXUoZSx0LG4pO2lmKCJub3JtYWwiPT09Yy50eXBlKXtpZihyPW4uZG9uZT8iY29tcGxldGVkIjoic3VzcGVuZGVkWWllbGQiLGMuYXJnPT09cyljb250aW51ZTtyZXR1cm57dmFsdWU6Yy5hcmcsZG9uZTpuLmRvbmV9fSJ0aHJvdyI9PT1jLnR5cGUmJihyPSJjb21wbGV0ZWQiLG4ubWV0aG9kPSJ0aHJvdyIsbi5hcmc9Yy5hcmcpfX19KGUsbixhKSxpfWZ1bmN0aW9uIHUoZSx0LG4pe3RyeXtyZXR1cm57dHlwZToibm9ybWFsIixhcmc6ZS5jYWxsKHQsbil9fWNhdGNoKHIpe3JldHVybnt0eXBlOiJ0aHJvdyIsYXJnOnJ9fX1lLndyYXA9bDt2YXIgcz17fTtmdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGQoKXt9ZnVuY3Rpb24gZigpe312YXIgcD17fTtwW29dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3ZhciBoPU9iamVjdC5nZXRQcm90b3R5cGVPZixtPWgmJmgoaChPKFtdKSkpO20mJm0hPT10JiZuLmNhbGwobSxvKSYmKHA9bSk7dmFyIHY9Zi5wcm90b3R5cGU9Yy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShwKTtmdW5jdGlvbiBiKGUpe1sibmV4dCIsInRocm93IiwicmV0dXJuIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5faW52b2tlKHQsZSl9fSkpfWZ1bmN0aW9uIHkoZSx0KXt2YXIg",
                    "cjt0aGlzLl9pbnZva2U9ZnVuY3Rpb24obyxpKXtmdW5jdGlvbiBhKCl7cmV0dXJuIG5ldyB0KChmdW5jdGlvbihyLGEpeyFmdW5jdGlvbiByKG8saSxhLGwpe3ZhciBzPXUoZVtvXSxlLGkpO2lmKCJ0aHJvdyIhPT1zLnR5cGUpe3ZhciBjPXMuYXJnLGQ9Yy52YWx1ZTtyZXR1cm4gZCYmIm9iamVjdCI9PT10eXBlb2YgZCYmbi5jYWxsKGQsIl9fYXdhaXQiKT90LnJlc29sdmUoZC5fX2F3YWl0KS50aGVuKChmdW5jdGlvbihlKXtyKCJuZXh0IixlLGEsbCl9KSwoZnVuY3Rpb24oZSl7cigidGhyb3ciLGUsYSxsKX0pKTp0LnJlc29sdmUoZCkudGhlbigoZnVuY3Rpb24oZSl7Yy52YWx1ZT1lLGEoYyl9KSwoZnVuY3Rpb24oZSl7cmV0dXJuIHIoInRocm93IixlLGEsbCl9KSl9bChzLmFyZyl9KG8saSxyLGEpfSkpfXJldHVybiByPXI/ci50aGVuKGEsYSk6YSgpfX1mdW5jdGlvbiBnKGUsdCl7dmFyIG49ZS5pdGVyYXRvclt0Lm1ldGhvZF07aWYodm9pZCAwPT09bil7aWYodC5kZWxlZ2F0ZT1udWxsLCJ0aHJvdyI9PT10Lm1ldGhvZCl7aWYoZS5pdGVyYXRvci5yZXR1cm4mJih0Lm1ldGhvZD0icmV0dXJuIix0LmFyZz12b2lkIDAsZyhlLHQpLCJ0aHJvdyI9PT10Lm1ldGhvZCkpcmV0dXJuIHM7dC5tZXRob2Q9InRocm93Iix0LmFyZz1uZXcgVHlwZUVycm9yKCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kIil9cmV0dXJuIHN9dmFyIHI9dShuLGUuaXRlcmF0b3IsdC5hcmcpO2lmKCJ0aHJv",
                    "dyI9PT1yLnR5cGUpcmV0dXJuIHQubWV0aG9kPSJ0aHJvdyIsdC5hcmc9ci5hcmcsdC5kZWxlZ2F0ZT1udWxsLHM7dmFyIG89ci5hcmc7cmV0dXJuIG8/by5kb25lPyh0W2UucmVzdWx0TmFtZV09by52YWx1ZSx0Lm5leHQ9ZS5uZXh0TG9jLCJyZXR1cm4iIT09dC5tZXRob2QmJih0Lm1ldGhvZD0ibmV4dCIsdC5hcmc9dm9pZCAwKSx0LmRlbGVnYXRlPW51bGwscyk6bzoodC5tZXRob2Q9InRocm93Iix0LmFyZz1uZXcgVHlwZUVycm9yKCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdCIpLHQuZGVsZWdhdGU9bnVsbCxzKX1mdW5jdGlvbiB3KGUpe3ZhciB0PXt0cnlMb2M6ZVswXX07MSBpbiBlJiYodC5jYXRjaExvYz1lWzFdKSwyIGluIGUmJih0LmZpbmFsbHlMb2M9ZVsyXSx0LmFmdGVyTG9jPWVbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKHQpfWZ1bmN0aW9uIHgoZSl7dmFyIHQ9ZS5jb21wbGV0aW9ufHx7fTt0LnR5cGU9Im5vcm1hbCIsZGVsZXRlIHQuYXJnLGUuY29tcGxldGlvbj10fWZ1bmN0aW9uIEUoZSl7dGhpcy50cnlFbnRyaWVzPVt7dHJ5TG9jOiJyb290In1dLGUuZm9yRWFjaCh3LHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIE8oZSl7aWYoZSl7dmFyIHQ9ZVtvXTtpZih0KXJldHVybiB0LmNhbGwoZSk7aWYoImZ1bmN0aW9uIj09PXR5cGVvZiBlLm5leHQpcmV0dXJuIGU7aWYoIWlzTmFOKGUubGVuZ3RoKSl7dmFyIHI9LTEsaT1mdW5jdGlvbiB0KCl7Zm9yKDsrK3I8ZS5sZW5ndGg7KWlm",
                    "KG4uY2FsbChlLHIpKXJldHVybiB0LnZhbHVlPWVbcl0sdC5kb25lPSExLHQ7cmV0dXJuIHQudmFsdWU9dm9pZCAwLHQuZG9uZT0hMCx0fTtyZXR1cm4gaS5uZXh0PWl9fXJldHVybntuZXh0Omt9fWZ1bmN0aW9uIGsoKXtyZXR1cm57dmFsdWU6dm9pZCAwLGRvbmU6ITB9fXJldHVybiBkLnByb3RvdHlwZT12LmNvbnN0cnVjdG9yPWYsZi5jb25zdHJ1Y3Rvcj1kLGZbYV09ZC5kaXNwbGF5TmFtZT0iR2VuZXJhdG9yRnVuY3Rpb24iLGUuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbihlKXt2YXIgdD0iZnVuY3Rpb24iPT09dHlwZW9mIGUmJmUuY29uc3RydWN0b3I7cmV0dXJuISF0JiYodD09PWR8fCJHZW5lcmF0b3JGdW5jdGlvbiI9PT0odC5kaXNwbGF5TmFtZXx8dC5uYW1lKSl9LGUubWFyaz1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLGYpOihlLl9fcHJvdG9fXz1mLGEgaW4gZXx8KGVbYV09IkdlbmVyYXRvckZ1bmN0aW9uIikpLGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodiksZX0sZS5hd3JhcD1mdW5jdGlvbihlKXtyZXR1cm57X19hd2FpdDplfX0sYih5LnByb3RvdHlwZSkseS5wcm90b3R5cGVbaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZS5Bc3luY0l0ZXJhdG9yPXksZS5hc3luYz1mdW5jdGlvbih0LG4scixvLGkpe3ZvaWQgMD09PWkmJihpPVByb21pc2UpO3ZhciBhPW5ldyB5KGwodCxuLHIsbyksaSk7cmV0dXJuIGUuaXNHZW5l",
                    "cmF0b3JGdW5jdGlvbihuKT9hOmEubmV4dCgpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRvbmU/ZS52YWx1ZTphLm5leHQoKX0pKX0sYih2KSx2W2FdPSJHZW5lcmF0b3IiLHZbb109ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sdi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiJbb2JqZWN0IEdlbmVyYXRvcl0ifSxlLmtleXM9ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKG4pO3JldHVybiB0LnJldmVyc2UoKSxmdW5jdGlvbiBuKCl7Zm9yKDt0Lmxlbmd0aDspe3ZhciByPXQucG9wKCk7aWYociBpbiBlKXJldHVybiBuLnZhbHVlPXIsbi5kb25lPSExLG59cmV0dXJuIG4uZG9uZT0hMCxufX0sZS52YWx1ZXM9TyxFLnByb3RvdHlwZT17Y29uc3RydWN0b3I6RSxyZXNldDpmdW5jdGlvbihlKXtpZih0aGlzLnByZXY9MCx0aGlzLm5leHQ9MCx0aGlzLnNlbnQ9dGhpcy5fc2VudD12b2lkIDAsdGhpcy5kb25lPSExLHRoaXMuZGVsZWdhdGU9bnVsbCx0aGlzLm1ldGhvZD0ibmV4dCIsdGhpcy5hcmc9dm9pZCAwLHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHgpLCFlKWZvcih2YXIgdCBpbiB0aGlzKSJ0Ij09PXQuY2hhckF0KDApJiZuLmNhbGwodGhpcyx0KSYmIWlzTmFOKCt0LnNsaWNlKDEpKSYmKHRoaXNbdF09dm9pZCAwKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgZT10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZigidGhyb3ciPT09ZS50eXBlKXRocm93IGUu",
                    "YXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKGUpe2lmKHRoaXMuZG9uZSl0aHJvdyBlO3ZhciB0PXRoaXM7ZnVuY3Rpb24gcihuLHIpe3JldHVybiBhLnR5cGU9InRocm93IixhLmFyZz1lLHQubmV4dD1uLHImJih0Lm1ldGhvZD0ibmV4dCIsdC5hcmc9dm9pZCAwKSwhIXJ9Zm9yKHZhciBvPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtvPj0wOy0tbyl7dmFyIGk9dGhpcy50cnlFbnRyaWVzW29dLGE9aS5jb21wbGV0aW9uO2lmKCJyb290Ij09PWkudHJ5TG9jKXJldHVybiByKCJlbmQiKTtpZihpLnRyeUxvYzw9dGhpcy5wcmV2KXt2YXIgbD1uLmNhbGwoaSwiY2F0Y2hMb2MiKSx1PW4uY2FsbChpLCJmaW5hbGx5TG9jIik7aWYobCYmdSl7aWYodGhpcy5wcmV2PGkuY2F0Y2hMb2MpcmV0dXJuIHIoaS5jYXRjaExvYywhMCk7aWYodGhpcy5wcmV2PGkuZmluYWxseUxvYylyZXR1cm4gcihpLmZpbmFsbHlMb2MpfWVsc2UgaWYobCl7aWYodGhpcy5wcmV2PGkuY2F0Y2hMb2MpcmV0dXJuIHIoaS5jYXRjaExvYywhMCl9ZWxzZXtpZighdSl0aHJvdyBuZXcgRXJyb3IoInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5Iik7aWYodGhpcy5wcmV2PGkuZmluYWxseUxvYylyZXR1cm4gcihpLmZpbmFsbHlMb2MpfX19fSxhYnJ1cHQ6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3I+PTA7LS1yKXt2YXIgbz10aGlzLnRyeUVudHJpZXNb",
                    "cl07aWYoby50cnlMb2M8PXRoaXMucHJldiYmbi5jYWxsKG8sImZpbmFsbHlMb2MiKSYmdGhpcy5wcmV2PG8uZmluYWxseUxvYyl7dmFyIGk9bzticmVha319aSYmKCJicmVhayI9PT1lfHwiY29udGludWUiPT09ZSkmJmkudHJ5TG9jPD10JiZ0PD1pLmZpbmFsbHlMb2MmJihpPW51bGwpO3ZhciBhPWk/aS5jb21wbGV0aW9uOnt9O3JldHVybiBhLnR5cGU9ZSxhLmFyZz10LGk/KHRoaXMubWV0aG9kPSJuZXh0Iix0aGlzLm5leHQ9aS5maW5hbGx5TG9jLHMpOnRoaXMuY29tcGxldGUoYSl9LGNvbXBsZXRlOmZ1bmN0aW9uKGUsdCl7aWYoInRocm93Ij09PWUudHlwZSl0aHJvdyBlLmFyZztyZXR1cm4iYnJlYWsiPT09ZS50eXBlfHwiY29udGludWUiPT09ZS50eXBlP3RoaXMubmV4dD1lLmFyZzoicmV0dXJuIj09PWUudHlwZT8odGhpcy5ydmFsPXRoaXMuYXJnPWUuYXJnLHRoaXMubWV0aG9kPSJyZXR1cm4iLHRoaXMubmV4dD0iZW5kIik6Im5vcm1hbCI9PT1lLnR5cGUmJnQmJih0aGlzLm5leHQ9dCksc30sZmluaXNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7dD49MDstLXQpe3ZhciBuPXRoaXMudHJ5RW50cmllc1t0XTtpZihuLmZpbmFsbHlMb2M9PT1lKXJldHVybiB0aGlzLmNvbXBsZXRlKG4uY29tcGxldGlvbixuLmFmdGVyTG9jKSx4KG4pLHN9fSxjYXRjaDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3Q+PTA7LS10KXt2YXIgbj10aGlz",
                    "LnRyeUVudHJpZXNbdF07aWYobi50cnlMb2M9PT1lKXt2YXIgcj1uLmNvbXBsZXRpb247aWYoInRocm93Ij09PXIudHlwZSl7dmFyIG89ci5hcmc7eChuKX1yZXR1cm4gb319dGhyb3cgbmV3IEVycm9yKCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHQiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOk8oZSkscmVzdWx0TmFtZTp0LG5leHRMb2M6bn0sIm5leHQiPT09dGhpcy5tZXRob2QmJih0aGlzLmFyZz12b2lkIDApLHN9fSxlfShlLmV4cG9ydHMpO3RyeXtyZWdlbmVyYXRvclJ1bnRpbWU9cn1jYXRjaChvKXtGdW5jdGlvbigiciIsInJlZ2VuZXJhdG9yUnVudGltZSA9IHIiKShyKX19LCwsLCwsLGZ1bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO2U9ZSYmZS5oYXNPd25Qcm9wZXJ0eSgiZGVmYXVsdCIpP2UuZGVmYXVsdDplO3ZhciB0PXtuYW1lOiJmciIsd2Vla2RheXM6ImRpbWFuY2hlX2x1bmRpX21hcmRpX21lcmNyZWRpX2pldWRpX3ZlbmRyZWRpX3NhbWVkaSIuc3BsaXQoIl8iKSx3ZWVrZGF5c1Nob3J0OiJkaW0uX2x1bi5fbWFyLl9tZXIuX2pldS5fdmVuLl9zYW0uIi5zcGxpdCgiXyIpLHdlZWtkYXlzTWluOiJkaV9sdV9tYV9tZV9qZV92ZV9zYSIuc3BsaXQoIl8iKSxtb250aHM6ImphbnZpZXJfZlx4ZTl2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW9ceGZidF9zZXB0ZW1icmVfb2N0b2JyZV9u",
                    "b3ZlbWJyZV9kXHhlOWNlbWJyZSIuc3BsaXQoIl8iKSxtb250aHNTaG9ydDoiamFudi5fZlx4ZTl2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2FvXHhmYnRfc2VwdC5fb2N0Ll9ub3YuX2RceGU5Yy4iLnNwbGl0KCJfIiksd2Vla1N0YXJ0OjEseWVhclN0YXJ0OjQsZm9ybWF0czp7TFQ6IkhIOm1tIixMVFM6IkhIOm1tOnNzIixMOiJERC9NTS9ZWVlZIixMTDoiRCBNTU1NIFlZWVkiLExMTDoiRCBNTU1NIFlZWVkgSEg6bW0iLExMTEw6ImRkZGQgRCBNTU1NIFlZWVkgSEg6bW0ifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZToiZGFucyAlcyIscGFzdDoiaWwgeSBhICVzIixzOiJxdWVscXVlcyBzZWNvbmRlcyIsbToidW5lIG1pbnV0ZSIsbW06IiVkIG1pbnV0ZXMiLGg6InVuZSBoZXVyZSIsaGg6IiVkIGhldXJlcyIsZDoidW4gam91ciIsZGQ6IiVkIGpvdXJzIixNOiJ1biBtb2lzIixNTToiJWQgbW9pcyIseToidW4gYW4iLHl5OiIlZCBhbnMifSxvcmRpbmFsOmZ1bmN0aW9uKGUpe3JldHVybiBlKygxPT09ZT8iZXIiOiIiKX19O3JldHVybiBlLmxvY2FsZSh0LG51bGwsITApLHR9KG4oNDgpKX0sLGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oMiksaT1uKDApLGE9KG4oNSksbigzKSksbD1uKDQpLHU9bigxMSkscz1uKDU2KSxjPW4oNiksZD1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5lZGdlLGw9dm9pZCAwIT09biYmbix1PWUuY2hpbGRyZW4sZD1lLmNsYXNzZXMsZj1l",
                    "LmNsYXNzTmFtZSxwPWUuY29sb3IsaD12b2lkIDA9PT1wPyJkZWZhdWx0IjpwLG09ZS5kaXNhYmxlZCx2PXZvaWQgMCE9PW0mJm0sYj1lLmRpc2FibGVGb2N1c1JpcHBsZSx5PXZvaWQgMCE9PWImJmIsZz1lLnNpemUsdz12b2lkIDA9PT1nPyJtZWRpdW0iOmcseD1PYmplY3Qoby5hKShlLFsiZWRnZSIsImNoaWxkcmVuIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbG9yIiwiZGlzYWJsZWQiLCJkaXNhYmxlRm9jdXNSaXBwbGUiLCJzaXplIl0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQocy5hLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkoZC5yb290LGYsImRlZmF1bHQiIT09aCYmZFsiY29sb3IiLmNvbmNhdChPYmplY3QoYy5hKShoKSldLHYmJmQuZGlzYWJsZWQsInNtYWxsIj09PXcmJmRbInNpemUiLmNvbmNhdChPYmplY3QoYy5hKSh3KSldLHtzdGFydDpkLmVkZ2VTdGFydCxlbmQ6ZC5lZGdlRW5kfVtsXSksY2VudGVyUmlwcGxlOiEwLGZvY3VzUmlwcGxlOiF5LGRpc2FibGVkOnYscmVmOnR9LHgpLGkuY3JlYXRlRWxlbWVudCgic3BhbiIse2NsYXNzTmFtZTpkLmxhYmVsfSx1KSl9KSk7dC5hPU9iamVjdChsLmEpKChmdW5jdGlvbihlKXtyZXR1cm57cm9vdDp7dGV4dEFsaWduOiJjZW50ZXIiLGZsZXg6IjAgMCBhdXRvIixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgyNCkscGFkZGluZzoxMixib3JkZXJSYWRpdXM6IjUwJSIsb3ZlcmZsb3c6InZpc2libGUiLGNvbG9yOmUucGFsZXR0ZS5h",
                    "Y3Rpb24uYWN0aXZlLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoImJhY2tncm91bmQtY29sb3IiLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXN0fSksIiY6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6T2JqZWN0KHUuYikoZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpLCJAbWVkaWEgKGhvdmVyOiBub25lKSI6e2JhY2tncm91bmRDb2xvcjoidHJhbnNwYXJlbnQifX0sIiYkZGlzYWJsZWQiOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50Iixjb2xvcjplLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkfX0sZWRnZVN0YXJ0OnttYXJnaW5MZWZ0Oi0xMiwiJHNpemVTbWFsbCYiOnttYXJnaW5MZWZ0Oi0zfX0sZWRnZUVuZDp7bWFyZ2luUmlnaHQ6LTEyLCIkc2l6ZVNtYWxsJiI6e21hcmdpblJpZ2h0Oi0zfX0sY29sb3JJbmhlcml0Ontjb2xvcjoiaW5oZXJpdCJ9LGNvbG9yUHJpbWFyeTp7Y29sb3I6ZS5wYWxldHRlLnByaW1hcnkubWFpbiwiJjpob3ZlciI6e2JhY2tncm91bmRDb2xvcjpPYmplY3QodS5iKShlLnBhbGV0dGUucHJpbWFyeS5tYWluLGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSwiQG1lZGlhIChob3Zlcjogbm9uZSkiOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50In19fSxjb2xvclNlY29uZGFyeTp7Y29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCImOmhvdmVyIjp7YmFja2dyb3VuZENvbG9yOk9i",
                    "amVjdCh1LmIpKGUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fX0sZGlzYWJsZWQ6e30sc2l6ZVNtYWxsOntwYWRkaW5nOjMsZm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTgpfSxsYWJlbDp7d2lkdGg6IjEwMCUiLGRpc3BsYXk6ImZsZXgiLGFsaWduSXRlbXM6ImluaGVyaXQiLGp1c3RpZnlDb250ZW50OiJpbmhlcml0In19fSkse25hbWU6Ik11aUljb25CdXR0b24ifSkoZCl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7bi5kKHQsImEiLChmdW5jdGlvbigpe3JldHVybiBhfSkpO3ZhciByPW4oMCksbz1uLm4ocik7dmFyIGk9by5hLmNyZWF0ZUNvbnRleHQobnVsbCk7ZnVuY3Rpb24gYSgpe3JldHVybiBvLmEudXNlQ29udGV4dChpKX19LCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtuLmQodCwiYSIsKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk7dmFyIHI9bigxKSxvPW4oMjkpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJiJvYmplY3QiPT09T2JqZWN0KG8uYSkoZSkmJmUuY29uc3RydWN0b3I9PT1PYmplY3R9ZnVuY3Rpb24gYShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7Y2xvbmU6ITB9LG89bi5jbG9uZT9PYmplY3Qoci5h",
                    "KSh7fSxlKTplO3JldHVybiBpKGUpJiZpKHQpJiZPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihyKXsiX19wcm90b19fIiE9PXImJihpKHRbcl0pJiZyIGluIGU/b1tyXT1hKGVbcl0sdFtyXSxuKTpvW3JdPXRbcl0pfSkpLG99fSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO24uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKTt2YXIgcj1uKDEpO2Z1bmN0aW9uIG8oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD1lLmJhc2VDbGFzc2VzLG49ZS5uZXdDbGFzc2VzO2UuQ29tcG9uZW50O2lmKCFuKXJldHVybiB0O3ZhciBvPU9iamVjdChyLmEpKHt9LHQpO3JldHVybiBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChmdW5jdGlvbihlKXtuW2VdJiYob1tlXT0iIi5jb25jYXQodFtlXSwiICIpLmNvbmNhdChuW2VdKSl9KSksb319LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXt2YXIgdD1lLnRoZW1lLG49ZS5uYW1lLHI9ZS5wcm9wcztpZighdHx8IXQucHJvcHN8fCF0LnByb3BzW25dKXJldHVybiByO3ZhciBvLGk9dC5wcm9wc1tuXTtmb3IobyBpbiBpKXZvaWQgMD09PXJbb10mJihyW29dPWlbb10pO3JldHVybiByfW4uZCh0LCJhIiwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDIpLG89bigxKSxpPW4oMCksYT0obig1KSxuKDMpKSxs",
                    "PW4oNCksdT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jbGFzc2VzLGw9ZS5jbGFzc05hbWUsdT1lLmNvbXBvbmVudCxzPXZvaWQgMD09PXU/ImRpdiI6dSxjPWUuc3F1YXJlLGQ9dm9pZCAwIT09YyYmYyxmPWUuZWxldmF0aW9uLHA9dm9pZCAwPT09Zj8xOmYsaD1lLnZhcmlhbnQsbT12b2lkIDA9PT1oPyJlbGV2YXRpb24iOmgsdj1PYmplY3Qoci5hKShlLFsiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbXBvbmVudCIsInNxdWFyZSIsImVsZXZhdGlvbiIsInZhcmlhbnQiXSk7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChzLE9iamVjdChvLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkobi5yb290LGwsIm91dGxpbmVkIj09PW0/bi5vdXRsaW5lZDpuWyJlbGV2YXRpb24iLmNvbmNhdChwKV0sIWQmJm4ucm91bmRlZCkscmVmOnR9LHYpKX0pKTt0LmE9T2JqZWN0KGwuYSkoKGZ1bmN0aW9uKGUpe3ZhciB0PXt9O3JldHVybiBlLnNoYWRvd3MuZm9yRWFjaCgoZnVuY3Rpb24oZSxuKXt0WyJlbGV2YXRpb24iLmNvbmNhdChuKV09e2JveFNoYWRvdzplfX0pKSxPYmplY3Qoby5hKSh7cm9vdDp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5iYWNrZ3JvdW5kLnBhcGVyLGNvbG9yOmUucGFsZXR0ZS50ZXh0LnByaW1hcnksdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiYm94LXNoYWRvdyIpfSxyb3VuZGVkOntib3JkZXJSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXN9LG91dGxpbmVkOntib3JkZXI6",
                    "IjFweCBzb2xpZCAiLmNvbmNhdChlLnBhbGV0dGUuZGl2aWRlcil9fSx0KX0pLHtuYW1lOiJNdWlQYXBlciJ9KSh1KX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDEpLG89bigyKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNTYpLHU9big5NCkscz1uKDQpLGM9big0NiksZD1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jaGlsZHJlbixzPWUuY2xhc3NlcyxkPWUuY2xhc3NOYW1lLGY9ZS5leHBhbmRJY29uLHA9ZS5JY29uQnV0dG9uUHJvcHMsaD1lLm9uQmx1cixtPWUub25DbGljayx2PWUub25Gb2N1c1Zpc2libGUsYj1PYmplY3Qoby5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiZXhwYW5kSWNvbiIsIkljb25CdXR0b25Qcm9wcyIsIm9uQmx1ciIsIm9uQ2xpY2siLCJvbkZvY3VzVmlzaWJsZSJdKSx5PWkudXNlU3RhdGUoITEpLGc9eVswXSx3PXlbMV0seD1pLnVzZUNvbnRleHQoYy5hKSxFPXguZGlzYWJsZWQsTz12b2lkIDAhPT1FJiZFLGs9eC5leHBhbmRlZCxTPXgudG9nZ2xlO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQobC5hLE9iamVjdChyLmEpKHtmb2N1c1JpcHBsZTohMSxkaXNhYmxlUmlwcGxlOiEwLGRpc2FibGVkOk8sY29tcG9uZW50OiJkaXYiLCJhcmlhLWV4cGFuZGVkIjprLGNsYXNzTmFtZTpPYmplY3QoYS5hKShzLnJvb3QsZCxPJiZzLmRpc2FibGVkLGsmJnMuZXhwYW5kZWQsZyYmcy5mb2N1c2VkKSxvbkZvY3VzVmlzaWJsZTpmdW5j",
                    "dGlvbihlKXt3KCEwKSx2JiZ2KGUpfSxvbkJsdXI6ZnVuY3Rpb24oZSl7dyghMSksaCYmaChlKX0sb25DbGljazpmdW5jdGlvbihlKXtTJiZTKGUpLG0mJm0oZSl9LHJlZjp0fSxiKSxpLmNyZWF0ZUVsZW1lbnQoImRpdiIse2NsYXNzTmFtZTpPYmplY3QoYS5hKShzLmNvbnRlbnQsayYmcy5leHBhbmRlZCl9LG4pLGYmJmkuY3JlYXRlRWxlbWVudCh1LmEsT2JqZWN0KHIuYSkoe2NsYXNzTmFtZTpPYmplY3QoYS5hKShzLmV4cGFuZEljb24sayYmcy5leHBhbmRlZCksZWRnZToiZW5kIixjb21wb25lbnQ6ImRpdiIsdGFiSW5kZXg6bnVsbCxyb2xlOm51bGwsImFyaWEtaGlkZGVuIjohMH0scCksZikpfSkpO3QuYT1PYmplY3Qocy5hKSgoZnVuY3Rpb24oZSl7dmFyIHQ9e2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3R9O3JldHVybntyb290OntkaXNwbGF5OiJmbGV4IixtaW5IZWlnaHQ6NDgsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZShbIm1pbi1oZWlnaHQiLCJiYWNrZ3JvdW5kLWNvbG9yIl0sdCkscGFkZGluZzplLnNwYWNpbmcoMCwyKSwiJjpob3Zlcjpub3QoJGRpc2FibGVkKSI6e2N1cnNvcjoicG9pbnRlciJ9LCImJGV4cGFuZGVkIjp7bWluSGVpZ2h0OjY0fSwiJiRmb2N1c2VkIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5hY3Rpb24uZm9jdXN9LCImJGRpc2FibGVkIjp7b3BhY2l0eTplLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkT3BhY2l0eX19LGV4cGFuZGVkOnt9LGZv",
                    "Y3VzZWQ6e30sZGlzYWJsZWQ6e30sY29udGVudDp7ZGlzcGxheToiZmxleCIsZmxleEdyb3c6MSx0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsibWFyZ2luIl0sdCksbWFyZ2luOiIxMnB4IDAiLCImJGV4cGFuZGVkIjp7bWFyZ2luOiIyMHB4IDAifX0sZXhwYW5kSWNvbjp7dHJhbnNmb3JtOiJyb3RhdGUoMGRlZykiLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoInRyYW5zZm9ybSIsdCksIiY6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50In0sIiYkZXhwYW5kZWQiOnt0cmFuc2Zvcm06InJvdGF0ZSgxODBkZWcpIn19fX0pLHtuYW1lOiJNdWlBY2NvcmRpb25TdW1tYXJ5In0pKGQpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMCksbz1uLm4ociksaT1uKDEyKTt0LmE9T2JqZWN0KGkuYSkoby5hLmNyZWF0ZUVsZW1lbnQoInBhdGgiLHtkOiJNMTYuNTkgOC41OUwxMiAxMy4xNyA3LjQxIDguNTkgNiAxMGw2IDYgNi02eiJ9KSwiRXhwYW5kTW9yZSIpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMSksbz1uKDIpLGk9bigwKSxhPShuKDUpLG4oMykpLGw9big0KSx1PW4oNikscz17aDE6ImgxIixoMjoiaDIiLGgzOiJoMyIsaDQ6Img0IixoNToiaDUiLGg2OiJoNiIsc3VidGl0bGUxOiJoNiIsc3VidGl0bGUyOiJoNiIsYm9keTE6InAiLGJvZHkyOiJwIn0sYz1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5hbGlnbixs",
                    "PXZvaWQgMD09PW4/ImluaGVyaXQiOm4sYz1lLmNsYXNzZXMsZD1lLmNsYXNzTmFtZSxmPWUuY29sb3IscD12b2lkIDA9PT1mPyJpbml0aWFsIjpmLGg9ZS5jb21wb25lbnQsbT1lLmRpc3BsYXksdj12b2lkIDA9PT1tPyJpbml0aWFsIjptLGI9ZS5ndXR0ZXJCb3R0b20seT12b2lkIDAhPT1iJiZiLGc9ZS5ub1dyYXAsdz12b2lkIDAhPT1nJiZnLHg9ZS5wYXJhZ3JhcGgsRT12b2lkIDAhPT14JiZ4LE89ZS52YXJpYW50LGs9dm9pZCAwPT09Tz8iYm9keTEiOk8sUz1lLnZhcmlhbnRNYXBwaW5nLEM9dm9pZCAwPT09Uz9zOlMsaj1PYmplY3Qoby5hKShlLFsiYWxpZ24iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29sb3IiLCJjb21wb25lbnQiLCJkaXNwbGF5IiwiZ3V0dGVyQm90dG9tIiwibm9XcmFwIiwicGFyYWdyYXBoIiwidmFyaWFudCIsInZhcmlhbnRNYXBwaW5nIl0pLFQ9aHx8KEU/InAiOkNba118fHNba10pfHwic3BhbiI7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChULE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkoYy5yb290LGQsImluaGVyaXQiIT09ayYmY1trXSwiaW5pdGlhbCIhPT1wJiZjWyJjb2xvciIuY29uY2F0KE9iamVjdCh1LmEpKHApKV0sdyYmYy5ub1dyYXAseSYmYy5ndXR0ZXJCb3R0b20sRSYmYy5wYXJhZ3JhcGgsImluaGVyaXQiIT09bCYmY1siYWxpZ24iLmNvbmNhdChPYmplY3QodS5hKShsKSldLCJpbml0aWFsIiE9PXYmJmNbImRpc3BsYXkiLmNvbmNhdChPYmplY3QodS5hKSh2",
                    "KSldKSxyZWY6dH0saikpfSkpO3QuYT1PYmplY3QobC5hKSgoZnVuY3Rpb24oZSl7cmV0dXJue3Jvb3Q6e21hcmdpbjowfSxib2R5MjplLnR5cG9ncmFwaHkuYm9keTIsYm9keTE6ZS50eXBvZ3JhcGh5LmJvZHkxLGNhcHRpb246ZS50eXBvZ3JhcGh5LmNhcHRpb24sYnV0dG9uOmUudHlwb2dyYXBoeS5idXR0b24saDE6ZS50eXBvZ3JhcGh5LmgxLGgyOmUudHlwb2dyYXBoeS5oMixoMzplLnR5cG9ncmFwaHkuaDMsaDQ6ZS50eXBvZ3JhcGh5Lmg0LGg1OmUudHlwb2dyYXBoeS5oNSxoNjplLnR5cG9ncmFwaHkuaDYsc3VidGl0bGUxOmUudHlwb2dyYXBoeS5zdWJ0aXRsZTEsc3VidGl0bGUyOmUudHlwb2dyYXBoeS5zdWJ0aXRsZTIsb3ZlcmxpbmU6ZS50eXBvZ3JhcGh5Lm92ZXJsaW5lLHNyT25seTp7cG9zaXRpb246ImFic29sdXRlIixoZWlnaHQ6MSx3aWR0aDoxLG92ZXJmbG93OiJoaWRkZW4ifSxhbGlnbkxlZnQ6e3RleHRBbGlnbjoibGVmdCJ9LGFsaWduQ2VudGVyOnt0ZXh0QWxpZ246ImNlbnRlciJ9LGFsaWduUmlnaHQ6e3RleHRBbGlnbjoicmlnaHQifSxhbGlnbkp1c3RpZnk6e3RleHRBbGlnbjoianVzdGlmeSJ9LG5vV3JhcDp7b3ZlcmZsb3c6ImhpZGRlbiIsdGV4dE92ZXJmbG93OiJlbGxpcHNpcyIsd2hpdGVTcGFjZToibm93cmFwIn0sZ3V0dGVyQm90dG9tOnttYXJnaW5Cb3R0b206IjAuMzVlbSJ9LHBhcmFncmFwaDp7bWFyZ2luQm90dG9tOjE2fSxjb2xvckluaGVyaXQ6e2NvbG9yOiJpbmhlcml0In0sY29s",
                    "b3JQcmltYXJ5Ontjb2xvcjplLnBhbGV0dGUucHJpbWFyeS5tYWlufSxjb2xvclNlY29uZGFyeTp7Y29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWlufSxjb2xvclRleHRQcmltYXJ5Ontjb2xvcjplLnBhbGV0dGUudGV4dC5wcmltYXJ5fSxjb2xvclRleHRTZWNvbmRhcnk6e2NvbG9yOmUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeX0sY29sb3JFcnJvcjp7Y29sb3I6ZS5wYWxldHRlLmVycm9yLm1haW59LGRpc3BsYXlJbmxpbmU6e2Rpc3BsYXk6ImlubGluZSJ9LGRpc3BsYXlCbG9jazp7ZGlzcGxheToiYmxvY2sifX19KSx7bmFtZToiTXVpVHlwb2dyYXBoeSJ9KShjKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDEpLG89bigyKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNCksdT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jbGFzc2VzLGw9ZS5jbGFzc05hbWUsdT1PYmplY3Qoby5hKShlLFsiY2xhc3NlcyIsImNsYXNzTmFtZSJdKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KCJkaXYiLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkobi5yb290LGwpLHJlZjp0fSx1KSl9KSk7dC5hPU9iamVjdChsLmEpKChmdW5jdGlvbihlKXtyZXR1cm57cm9vdDp7ZGlzcGxheToiZmxleCIscGFkZGluZzplLnNwYWNpbmcoMSwyLDIpfX19KSx7bmFtZToiTXVpQWNjb3JkaW9uRGV0YWlscyJ9KSh1KX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDIpLG89",
                    "bigxKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNCksdT1uKDExKSxzPW4oNTYpLGM9big2KSxkPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNoaWxkcmVuLGw9ZS5jbGFzc2VzLHU9ZS5jbGFzc05hbWUsZD1lLmNvbG9yLGY9dm9pZCAwPT09ZD8iZGVmYXVsdCI6ZCxwPWUuY29tcG9uZW50LGg9dm9pZCAwPT09cD8iYnV0dG9uIjpwLG09ZS5kaXNhYmxlZCx2PXZvaWQgMCE9PW0mJm0sYj1lLmRpc2FibGVFbGV2YXRpb24seT12b2lkIDAhPT1iJiZiLGc9ZS5kaXNhYmxlRm9jdXNSaXBwbGUsdz12b2lkIDAhPT1nJiZnLHg9ZS5lbmRJY29uLEU9ZS5mb2N1c1Zpc2libGVDbGFzc05hbWUsTz1lLmZ1bGxXaWR0aCxrPXZvaWQgMCE9PU8mJk8sUz1lLnNpemUsQz12b2lkIDA9PT1TPyJtZWRpdW0iOlMsaj1lLnN0YXJ0SWNvbixUPWUudHlwZSxQPXZvaWQgMD09PVQ/ImJ1dHRvbiI6VCxSPWUudmFyaWFudCxOPXZvaWQgMD09PVI/InRleHQiOlIsTT1PYmplY3Qoci5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29sb3IiLCJjb21wb25lbnQiLCJkaXNhYmxlZCIsImRpc2FibGVFbGV2YXRpb24iLCJkaXNhYmxlRm9jdXNSaXBwbGUiLCJlbmRJY29uIiwiZm9jdXNWaXNpYmxlQ2xhc3NOYW1lIiwiZnVsbFdpZHRoIiwic2l6ZSIsInN0YXJ0SWNvbiIsInR5cGUiLCJ2YXJpYW50Il0pLF89aiYmaS5jcmVhdGVFbGVtZW50KCJzcGFuIix7Y2xhc3NOYW1lOk9iamVjdChhLmEpKGwuc3Rh",
                    "cnRJY29uLGxbImljb25TaXplIi5jb25jYXQoT2JqZWN0KGMuYSkoQykpXSl9LGopLEE9eCYmaS5jcmVhdGVFbGVtZW50KCJzcGFuIix7Y2xhc3NOYW1lOk9iamVjdChhLmEpKGwuZW5kSWNvbixsWyJpY29uU2l6ZSIuY29uY2F0KE9iamVjdChjLmEpKEMpKV0pfSx4KTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KHMuYSxPYmplY3Qoby5hKSh7Y2xhc3NOYW1lOk9iamVjdChhLmEpKGwucm9vdCxsW05dLHUsImluaGVyaXQiPT09Zj9sLmNvbG9ySW5oZXJpdDoiZGVmYXVsdCIhPT1mJiZsWyIiLmNvbmNhdChOKS5jb25jYXQoT2JqZWN0KGMuYSkoZikpXSwibWVkaXVtIiE9PUMmJltsWyIiLmNvbmNhdChOLCJTaXplIikuY29uY2F0KE9iamVjdChjLmEpKEMpKV0sbFsic2l6ZSIuY29uY2F0KE9iamVjdChjLmEpKEMpKV1dLHkmJmwuZGlzYWJsZUVsZXZhdGlvbix2JiZsLmRpc2FibGVkLGsmJmwuZnVsbFdpZHRoKSxjb21wb25lbnQ6aCxkaXNhYmxlZDp2LGZvY3VzUmlwcGxlOiF3LGZvY3VzVmlzaWJsZUNsYXNzTmFtZTpPYmplY3QoYS5hKShsLmZvY3VzVmlzaWJsZSxFKSxyZWY6dCx0eXBlOlB9LE0pLGkuY3JlYXRlRWxlbWVudCgic3BhbiIse2NsYXNzTmFtZTpsLmxhYmVsfSxfLG4sQSkpfSkpO3QuYT1PYmplY3QobC5hKSgoZnVuY3Rpb24oZSl7cmV0dXJue3Jvb3Q6T2JqZWN0KG8uYSkoe30sZS50eXBvZ3JhcGh5LmJ1dHRvbix7Ym94U2l6aW5nOiJib3JkZXItYm94IixtaW5XaWR0aDo2NCxwYWRkaW5nOiI2cHggMTZweCIs",
                    "Ym9yZGVyUmFkaXVzOmUuc2hhcGUuYm9yZGVyUmFkaXVzLGNvbG9yOmUucGFsZXR0ZS50ZXh0LnByaW1hcnksdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZShbImJhY2tncm91bmQtY29sb3IiLCJib3gtc2hhZG93IiwiYm9yZGVyIl0se2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnR9KSwiJjpob3ZlciI6e3RleHREZWNvcmF0aW9uOiJub25lIixiYWNrZ3JvdW5kQ29sb3I6T2JqZWN0KHUuYikoZS5wYWxldHRlLnRleHQucHJpbWFyeSxlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9LCImJGRpc2FibGVkIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fSwiJiRkaXNhYmxlZCI6e2NvbG9yOmUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWR9fSksbGFiZWw6e3dpZHRoOiIxMDAlIixkaXNwbGF5OiJpbmhlcml0IixhbGlnbkl0ZW1zOiJpbmhlcml0IixqdXN0aWZ5Q29udGVudDoiaW5oZXJpdCJ9LHRleHQ6e3BhZGRpbmc6IjZweCA4cHgifSx0ZXh0UHJpbWFyeTp7Y29sb3I6ZS5wYWxldHRlLnByaW1hcnkubWFpbiwiJjpob3ZlciI6e2JhY2tncm91bmRDb2xvcjpPYmplY3QodS5iKShlLnBhbGV0dGUucHJpbWFyeS5tYWluLGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSwiQG1lZGlhIChob3Zlcjogbm9uZSkiOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50In19fSx0ZXh0",
                    "U2Vjb25kYXJ5Ontjb2xvcjplLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIiY6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6T2JqZWN0KHUuYikoZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSwiQG1lZGlhIChob3Zlcjogbm9uZSkiOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50In19fSxvdXRsaW5lZDp7cGFkZGluZzoiNXB4IDE1cHgiLGJvcmRlcjoiMXB4IHNvbGlkICIuY29uY2F0KCJsaWdodCI9PT1lLnBhbGV0dGUudHlwZT8icmdiYSgwLCAwLCAwLCAwLjIzKSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yMykiKSwiJiRkaXNhYmxlZCI6e2JvcmRlcjoiMXB4IHNvbGlkICIuY29uY2F0KGUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRCYWNrZ3JvdW5kKX19LG91dGxpbmVkUHJpbWFyeTp7Y29sb3I6ZS5wYWxldHRlLnByaW1hcnkubWFpbixib3JkZXI6IjFweCBzb2xpZCAiLmNvbmNhdChPYmplY3QodS5iKShlLnBhbGV0dGUucHJpbWFyeS5tYWluLC41KSksIiY6aG92ZXIiOntib3JkZXI6IjFweCBzb2xpZCAiLmNvbmNhdChlLnBhbGV0dGUucHJpbWFyeS5tYWluKSxiYWNrZ3JvdW5kQ29sb3I6T2JqZWN0KHUuYikoZS5wYWxldHRlLnByaW1hcnkubWFpbixlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fX0sb3V0bGluZWRTZWNvbmRhcnk6e2NvbG9yOmUucGFs",
                    "ZXR0ZS5zZWNvbmRhcnkubWFpbixib3JkZXI6IjFweCBzb2xpZCAiLmNvbmNhdChPYmplY3QodS5iKShlLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sLjUpKSwiJjpob3ZlciI6e2JvcmRlcjoiMXB4IHNvbGlkICIuY29uY2F0KGUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiksYmFja2dyb3VuZENvbG9yOk9iamVjdCh1LmIpKGUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fSwiJiRkaXNhYmxlZCI6e2JvcmRlcjoiMXB4IHNvbGlkICIuY29uY2F0KGUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWQpfX0sY29udGFpbmVkOntjb2xvcjplLnBhbGV0dGUuZ2V0Q29udHJhc3RUZXh0KGUucGFsZXR0ZS5ncmV5WzMwMF0pLGJhY2tncm91bmRDb2xvcjplLnBhbGV0dGUuZ3JleVszMDBdLGJveFNoYWRvdzplLnNoYWRvd3NbMl0sIiY6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLmdyZXkuQTEwMCxib3hTaGFkb3c6ZS5zaGFkb3dzWzRdLCJAbWVkaWEgKGhvdmVyOiBub25lKSI6e2JveFNoYWRvdzplLnNoYWRvd3NbMl0sYmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5ncmV5WzMwMF19LCImJGRpc2FibGVkIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRCYWNrZ3JvdW5kfX0sIiYkZm9jdXNWaXNpYmxlIjp7Ym94U2hhZG93OmUuc2hhZG93c1s2XX0s",
                    "IiY6YWN0aXZlIjp7Ym94U2hhZG93OmUuc2hhZG93c1s4XX0sIiYkZGlzYWJsZWQiOntjb2xvcjplLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkLGJveFNoYWRvdzplLnNoYWRvd3NbMF0sYmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRCYWNrZ3JvdW5kfX0sY29udGFpbmVkUHJpbWFyeTp7Y29sb3I6ZS5wYWxldHRlLnByaW1hcnkuY29udHJhc3RUZXh0LGJhY2tncm91bmRDb2xvcjplLnBhbGV0dGUucHJpbWFyeS5tYWluLCImOmhvdmVyIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5wcmltYXJ5LmRhcmssIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5wcmltYXJ5Lm1haW59fX0sY29udGFpbmVkU2Vjb25kYXJ5Ontjb2xvcjplLnBhbGV0dGUuc2Vjb25kYXJ5LmNvbnRyYXN0VGV4dCxiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCImOmhvdmVyIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5zZWNvbmRhcnkuZGFyaywiQG1lZGlhIChob3Zlcjogbm9uZSkiOntiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWlufX19LGRpc2FibGVFbGV2YXRpb246e2JveFNoYWRvdzoibm9uZSIsIiY6aG92ZXIiOntib3hTaGFkb3c6Im5vbmUifSwiJiRmb2N1c1Zpc2libGUiOntib3hTaGFkb3c6Im5vbmUifSwiJjphY3RpdmUiOntib3hTaGFkb3c6Im5vbmUifSwiJiRkaXNhYmxlZCI6e2JveFNoYWRvdzoibm9uZSJ9",
                    "fSxmb2N1c1Zpc2libGU6e30sZGlzYWJsZWQ6e30sY29sb3JJbmhlcml0Ontjb2xvcjoiaW5oZXJpdCIsYm9yZGVyQ29sb3I6ImN1cnJlbnRDb2xvciJ9LHRleHRTaXplU21hbGw6e3BhZGRpbmc6IjRweCA1cHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDEzKX0sdGV4dFNpemVMYXJnZTp7cGFkZGluZzoiOHB4IDExcHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDE1KX0sb3V0bGluZWRTaXplU21hbGw6e3BhZGRpbmc6IjNweCA5cHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDEzKX0sb3V0bGluZWRTaXplTGFyZ2U6e3BhZGRpbmc6IjdweCAyMXB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxNSl9LGNvbnRhaW5lZFNpemVTbWFsbDp7cGFkZGluZzoiNHB4IDEwcHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDEzKX0sY29udGFpbmVkU2l6ZUxhcmdlOntwYWRkaW5nOiI4cHggMjJweCIsZm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTUpfSxzaXplU21hbGw6e30sc2l6ZUxhcmdlOnt9LGZ1bGxXaWR0aDp7d2lkdGg6IjEwMCUifSxzdGFydEljb246e2Rpc3BsYXk6ImluaGVyaXQiLG1hcmdpblJpZ2h0OjgsbWFyZ2luTGVmdDotNCwiJiRpY29uU2l6ZVNtYWxsIjp7bWFyZ2luTGVmdDotMn19LGVuZEljb246e2Rpc3BsYXk6ImluaGVyaXQiLG1hcmdpblJpZ2h0Oi00LG1hcmdpbkxlZnQ6OCwiJiRpY29uU2l6ZVNtYWxsIjp7bWFyZ2luUmlnaHQ6LTJ9",
                    "fSxpY29uU2l6ZVNtYWxsOnsiJiA+ICo6Zmlyc3QtY2hpbGQiOntmb250U2l6ZToxOH19LGljb25TaXplTWVkaXVtOnsiJiA+ICo6Zmlyc3QtY2hpbGQiOntmb250U2l6ZToyMH19LGljb25TaXplTGFyZ2U6eyImID4gKjpmaXJzdC1jaGlsZCI6e2ZvbnRTaXplOjIyfX19fSkse25hbWU6Ik11aUJ1dHRvbiJ9KShkKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDApLG89bi5uKHIpLGk9bigxMik7dC5hPU9iamVjdChpLmEpKG8uYS5jcmVhdGVFbGVtZW50KCJwYXRoIix7ZDoiTTE3LjY1IDYuMzVDMTYuMiA0LjkgMTQuMjEgNCAxMiA0Yy00LjQyIDAtNy45OSAzLjU4LTcuOTkgOHMzLjU3IDggNy45OSA4YzMuNzMgMCA2Ljg0LTIuNTUgNy43My02aC0yLjA4Yy0uODIgMi4zMy0zLjA0IDQtNS42NSA0LTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTZjMS42NiAwIDMuMTQuNjkgNC4yMiAxLjc4TDEzIDExaDdWNGwtMi4zNSAyLjM1eiJ9KSwiUmVmcmVzaCIpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMCksbz1uLm4ociksaT1uKDEyKTt0LmE9T2JqZWN0KGkuYSkoby5hLmNyZWF0ZUVsZW1lbnQoInBhdGgiLHtkOiJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiJ9KSwiQ2xlYXIiKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIg",
                    "cj1uKDEpLG89bigyKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNCksdT1uKDIzKSxzPW4oMTEpLGM9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2xhc3NlcyxsPWUuY2xhc3NOYW1lLHM9ZS5jb21wb25lbnQsYz12b2lkIDA9PT1zPyJ0ciI6cyxkPWUuaG92ZXIsZj12b2lkIDAhPT1kJiZkLHA9ZS5zZWxlY3RlZCxoPXZvaWQgMCE9PXAmJnAsbT1PYmplY3Qoby5hKShlLFsiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbXBvbmVudCIsImhvdmVyIiwic2VsZWN0ZWQiXSksdj1pLnVzZUNvbnRleHQodS5hKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KGMsT2JqZWN0KHIuYSkoe3JlZjp0LGNsYXNzTmFtZTpPYmplY3QoYS5hKShuLnJvb3QsbCx2JiZ7aGVhZDpuLmhlYWQsZm9vdGVyOm4uZm9vdGVyfVt2LnZhcmlhbnRdLGYmJm4uaG92ZXIsaCYmbi5zZWxlY3RlZCkscm9sZToidHIiPT09Yz9udWxsOiJyb3cifSxtKSl9KSk7dC5hPU9iamVjdChsLmEpKChmdW5jdGlvbihlKXtyZXR1cm57cm9vdDp7Y29sb3I6ImluaGVyaXQiLGRpc3BsYXk6InRhYmxlLXJvdyIsdmVydGljYWxBbGlnbjoibWlkZGxlIixvdXRsaW5lOjAsIiYkaG92ZXI6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLmFjdGlvbi5ob3Zlcn0sIiYkc2VsZWN0ZWQsICYkc2VsZWN0ZWQ6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6T2JqZWN0KHMuYikoZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLGUucGFsZXR0ZS5hY3Rpb24uc2Vs",
                    "ZWN0ZWRPcGFjaXR5KX19LHNlbGVjdGVkOnt9LGhvdmVyOnt9LGhlYWQ6e30sZm9vdGVyOnt9fX0pLHtuYW1lOiJNdWlUYWJsZVJvdyJ9KShjKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDIpLG89bigxKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNCksdT1uKDYpLHM9bigxMSksYz1uKDQ3KSxkPW4oMjMpLGY9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuLGwscz1lLmFsaWduLGY9dm9pZCAwPT09cz8iaW5oZXJpdCI6cyxwPWUuY2xhc3NlcyxoPWUuY2xhc3NOYW1lLG09ZS5jb21wb25lbnQsdj1lLnBhZGRpbmcsYj1lLnNjb3BlLHk9ZS5zaXplLGc9ZS5zb3J0RGlyZWN0aW9uLHc9ZS52YXJpYW50LHg9T2JqZWN0KHIuYSkoZSxbImFsaWduIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbXBvbmVudCIsInBhZGRpbmciLCJzY29wZSIsInNpemUiLCJzb3J0RGlyZWN0aW9uIiwidmFyaWFudCJdKSxFPWkudXNlQ29udGV4dChjLmEpLE89aS51c2VDb250ZXh0KGQuYSksaz1PJiYiaGVhZCI9PT1PLnZhcmlhbnQ7bT8obD1tLG49az8iY29sdW1uaGVhZGVyIjoiY2VsbCIpOmw9az8idGgiOiJ0ZCI7dmFyIFM9YjshUyYmayYmKFM9ImNvbCIpO3ZhciBDPXZ8fChFJiZFLnBhZGRpbmc/RS5wYWRkaW5nOiJkZWZhdWx0Iiksaj15fHwoRSYmRS5zaXplP0Uuc2l6ZToibWVkaXVtIiksVD13fHxPJiZPLnZhcmlhbnQsUD1udWxsO3JldHVybiBnJiYoUD0iYXNjIj09PWc/ImFzY2VuZGluZyI6",
                    "ImRlc2NlbmRpbmciKSxpLmNyZWF0ZUVsZW1lbnQobCxPYmplY3Qoby5hKSh7cmVmOnQsY2xhc3NOYW1lOk9iamVjdChhLmEpKHAucm9vdCxwW1RdLGgsImluaGVyaXQiIT09ZiYmcFsiYWxpZ24iLmNvbmNhdChPYmplY3QodS5hKShmKSldLCJkZWZhdWx0IiE9PUMmJnBbInBhZGRpbmciLmNvbmNhdChPYmplY3QodS5hKShDKSldLCJtZWRpdW0iIT09aiYmcFsic2l6ZSIuY29uY2F0KE9iamVjdCh1LmEpKGopKV0sImhlYWQiPT09VCYmRSYmRS5zdGlja3lIZWFkZXImJnAuc3RpY2t5SGVhZGVyKSwiYXJpYS1zb3J0IjpQLHJvbGU6bixzY29wZTpTfSx4KSl9KSk7dC5hPU9iamVjdChsLmEpKChmdW5jdGlvbihlKXtyZXR1cm57cm9vdDpPYmplY3Qoby5hKSh7fSxlLnR5cG9ncmFwaHkuYm9keTIse2Rpc3BsYXk6InRhYmxlLWNlbGwiLHZlcnRpY2FsQWxpZ246ImluaGVyaXQiLGJvcmRlckJvdHRvbToiMXB4IHNvbGlkXG4gICAgIi5jb25jYXQoImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlP09iamVjdChzLmQpKE9iamVjdChzLmIpKGUucGFsZXR0ZS5kaXZpZGVyLDEpLC44OCk6T2JqZWN0KHMuYSkoT2JqZWN0KHMuYikoZS5wYWxldHRlLmRpdmlkZXIsMSksLjY4KSksdGV4dEFsaWduOiJsZWZ0IixwYWRkaW5nOjE2fSksaGVhZDp7Y29sb3I6ZS5wYWxldHRlLnRleHQucHJpbWFyeSxsaW5lSGVpZ2h0OmUudHlwb2dyYXBoeS5weFRvUmVtKDI0KSxmb250V2VpZ2h0OmUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtfSxib2R5",
                    "Ontjb2xvcjplLnBhbGV0dGUudGV4dC5wcmltYXJ5fSxmb290ZXI6e2NvbG9yOmUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSxsaW5lSGVpZ2h0OmUudHlwb2dyYXBoeS5weFRvUmVtKDIxKSxmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxMil9LHNpemVTbWFsbDp7cGFkZGluZzoiNnB4IDI0cHggNnB4IDE2cHgiLCImOmxhc3QtY2hpbGQiOntwYWRkaW5nUmlnaHQ6MTZ9LCImJHBhZGRpbmdDaGVja2JveCI6e3dpZHRoOjI0LHBhZGRpbmc6IjAgMTJweCAwIDE2cHgiLCImOmxhc3QtY2hpbGQiOntwYWRkaW5nTGVmdDoxMixwYWRkaW5nUmlnaHQ6MTZ9LCImID4gKiI6e3BhZGRpbmc6MH19fSxwYWRkaW5nQ2hlY2tib3g6e3dpZHRoOjQ4LHBhZGRpbmc6IjAgMCAwIDRweCIsIiY6bGFzdC1jaGlsZCI6e3BhZGRpbmdMZWZ0OjAscGFkZGluZ1JpZ2h0OjR9fSxwYWRkaW5nTm9uZTp7cGFkZGluZzowLCImOmxhc3QtY2hpbGQiOntwYWRkaW5nOjB9fSxhbGlnbkxlZnQ6e3RleHRBbGlnbjoibGVmdCJ9LGFsaWduQ2VudGVyOnt0ZXh0QWxpZ246ImNlbnRlciJ9LGFsaWduUmlnaHQ6e3RleHRBbGlnbjoicmlnaHQiLGZsZXhEaXJlY3Rpb246InJvdy1yZXZlcnNlIn0sYWxpZ25KdXN0aWZ5Ont0ZXh0QWxpZ246Imp1c3RpZnkifSxzdGlja3lIZWFkZXI6e3Bvc2l0aW9uOiJzdGlja3kiLHRvcDowLGxlZnQ6MCx6SW5kZXg6MixiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLmJhY2tncm91bmQuZGVmYXVsdH19fSkse25hbWU6Ik11",
                    "aVRhYmxlQ2VsbCJ9KShmKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDApLG89bi5uKHIpLGk9bigxMik7dC5hPU9iamVjdChpLmEpKG8uYS5jcmVhdGVFbGVtZW50KCJwYXRoIix7ZDoiTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoifSksIkFkZCIpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMCksbz1uLm4ociksaT1uKDEyKTt0LmE9T2JqZWN0KGkuYSkoby5hLmNyZWF0ZUVsZW1lbnQoInBhdGgiLHtkOiJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiJ9KSwiRGVsZXRlIil9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigwKSxvPW4ubihyKSxpPW4oMTIpO3QuYT1PYmplY3QoaS5hKShvLmEuY3JlYXRlRWxlbWVudCgicGF0aCIse2Q6Ik0xOSAxM0g1di0yaDE0djJ6In0pLCJSZW1vdmUiKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDEpLG89bigyKSxpPW4oMCksYT0obig1KSxuKDMpKSxsPW4oNCksdT1uKDIzKSxzPXt2YXJpYW50OiJoZWFkIn0sYz1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jbGFzc2VzLGw9ZS5jbGFzc05hbWUsYz1lLmNvbXBvbmVudCxkPXZvaWQgMD09PWM/InRoZWFkIjpjLGY9T2JqZWN0KG8uYSkoZSxbImNsYXNzZXMiLCJjbGFzc05hbWUiLCJjb21wb25lbnQiXSk7cmV0",
                    "dXJuIGkuY3JlYXRlRWxlbWVudCh1LmEuUHJvdmlkZXIse3ZhbHVlOnN9LGkuY3JlYXRlRWxlbWVudChkLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGEuYSkobi5yb290LGwpLHJlZjp0LHJvbGU6InRoZWFkIj09PWQ/bnVsbDoicm93Z3JvdXAifSxmKSkpfSkpO3QuYT1PYmplY3QobC5hKSh7cm9vdDp7ZGlzcGxheToidGFibGUtaGVhZGVyLWdyb3VwIn19LHtuYW1lOiJNdWlUYWJsZUhlYWQifSkoYyl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oMiksaT1uKDApLGE9KG4oNSksbigzKSksbD1uKDQpLHU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2xhc3NlcyxsPWUuY2xhc3NOYW1lLHU9ZS5jb21wb25lbnQscz12b2lkIDA9PT11PyJkaXYiOnUsYz1PYmplY3Qoby5hKShlLFsiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbXBvbmVudCJdKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KHMsT2JqZWN0KHIuYSkoe3JlZjp0LGNsYXNzTmFtZTpPYmplY3QoYS5hKShuLnJvb3QsbCl9LGMpKX0pKTt0LmE9T2JqZWN0KGwuYSkoe3Jvb3Q6e3dpZHRoOiIxMDAlIixvdmVyZmxvd1g6ImF1dG8ifX0se25hbWU6Ik11aVRhYmxlQ29udGFpbmVyIn0pKHUpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMiksbz1uKDEpLGk9bigwKSxhPShuKDUpLG4oMykpLGw9big0KSx1PW4oNDcpLHM9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUu",
                    "Y2xhc3NlcyxsPWUuY2xhc3NOYW1lLHM9ZS5jb21wb25lbnQsYz12b2lkIDA9PT1zPyJ0YWJsZSI6cyxkPWUucGFkZGluZyxmPXZvaWQgMD09PWQ/ImRlZmF1bHQiOmQscD1lLnNpemUsaD12b2lkIDA9PT1wPyJtZWRpdW0iOnAsbT1lLnN0aWNreUhlYWRlcix2PXZvaWQgMCE9PW0mJm0sYj1PYmplY3Qoci5hKShlLFsiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbXBvbmVudCIsInBhZGRpbmciLCJzaXplIiwic3RpY2t5SGVhZGVyIl0pLHk9aS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybntwYWRkaW5nOmYsc2l6ZTpoLHN0aWNreUhlYWRlcjp2fX0pLFtmLGgsdl0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQodS5hLlByb3ZpZGVyLHt2YWx1ZTp5fSxpLmNyZWF0ZUVsZW1lbnQoYyxPYmplY3Qoby5hKSh7cm9sZToidGFibGUiPT09Yz9udWxsOiJ0YWJsZSIscmVmOnQsY2xhc3NOYW1lOk9iamVjdChhLmEpKG4ucm9vdCxsLHYmJm4uc3RpY2t5SGVhZGVyKX0sYikpKX0pKTt0LmE9T2JqZWN0KGwuYSkoKGZ1bmN0aW9uKGUpe3JldHVybntyb290OntkaXNwbGF5OiJ0YWJsZSIsd2lkdGg6IjEwMCUiLGJvcmRlckNvbGxhcHNlOiJjb2xsYXBzZSIsYm9yZGVyU3BhY2luZzowLCImIGNhcHRpb24iOk9iamVjdChvLmEpKHt9LGUudHlwb2dyYXBoeS5ib2R5Mix7cGFkZGluZzplLnNwYWNpbmcoMiksY29sb3I6ZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LHRleHRBbGlnbjoibGVmdCIsY2FwdGlvblNpZGU6ImJvdHRvbSJ9KX0sc3Rp",
                    "Y2t5SGVhZGVyOntib3JkZXJDb2xsYXBzZToic2VwYXJhdGUifX19KSx7bmFtZToiTXVpVGFibGUifSkocyl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oMiksaT1uKDApLGE9KG4oNSksbigzKSksbD1uKDQpLHU9bigyMykscz17dmFyaWFudDoiYm9keSJ9LGM9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2xhc3NlcyxsPWUuY2xhc3NOYW1lLGM9ZS5jb21wb25lbnQsZD12b2lkIDA9PT1jPyJ0Ym9keSI6YyxmPU9iamVjdChvLmEpKGUsWyJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29tcG9uZW50Il0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQodS5hLlByb3ZpZGVyLHt2YWx1ZTpzfSxpLmNyZWF0ZUVsZW1lbnQoZCxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChhLmEpKG4ucm9vdCxsKSxyZWY6dCxyb2xlOiJ0Ym9keSI9PT1kP251bGw6InJvd2dyb3VwIn0sZikpKX0pKTt0LmE9T2JqZWN0KGwuYSkoe3Jvb3Q6e2Rpc3BsYXk6InRhYmxlLXJvdy1ncm91cCJ9fSx7bmFtZToiTXVpVGFibGVCb2R5In0pKGMpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMCksbz1uLm4ociksaT1uKDEyKTt0LmE9T2JqZWN0KGkuYSkoby5hLmNyZWF0ZUVsZW1lbnQoInBhdGgiLHtkOiJNNiA2aDEydjEySDZ6In0pLCJTdG9wIil9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigwKSxvPW4ubihyKSxpPW4oMTIpO3QuYT1PYmplY3QoaS5h",
                    "KShvLmEuY3JlYXRlRWxlbWVudCgicGF0aCIse2Q6Ik0xOSA5aC00VjNIOXY2SDVsNyA3IDctN3pNNSAxOHYyaDE0di0ySDV6In0pLCJHZXRBcHAiKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDApLG89bi5uKHIpLGk9bigxMik7dC5hPU9iamVjdChpLmEpKG8uYS5jcmVhdGVFbGVtZW50KCJwYXRoIix7ZDoiTTIuMDEgMjFMMjMgMTIgMi4wMSAzIDIgMTBsMTUgMi0xNSAyeiJ9KSwiU2VuZCIpfSxmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO3ZhciByPW4oMSksbz1uKDIpLGk9bigwKSxhPW4ubihpKSxsPShuKDUpLG4oMykpLHU9big2Nik7ZnVuY3Rpb24gcyhlKXt2YXIgdD1lLnByb3BzLG49ZS5zdGF0ZXMscj1lLm11aUZvcm1Db250cm9sO3JldHVybiBuLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVtuXT10W25dLHImJiJ1bmRlZmluZWQiPT09dHlwZW9mIHRbbl0mJihlW25dPXJbbl0pLGV9KSx7fSl9dmFyIGM9aS5jcmVhdGVDb250ZXh0KCk7dmFyIGQ9YyxmPW4oNCkscD1uKDYpLGg9bigxMCk7ZnVuY3Rpb24gbShlKXt2YXIgdCxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxNjY7ZnVuY3Rpb24gcigpe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLG89bmV3IEFycmF5KHIpLGk9MDtpPHI7aSsrKW9baV09YXJndW1lbnRzW2ldO3ZhciBhPXRoaXMsbD1mdW5jdGlvbigpe2UuYXBwbHkoYSxvKX07Y2xlYXJUaW1lb3V0",
                    "KHQpLHQ9c2V0VGltZW91dChsLG4pfXJldHVybiByLmNsZWFyPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHQpfSxyfWZ1bmN0aW9uIHYoZSx0KXtyZXR1cm4gcGFyc2VJbnQoZVt0XSwxMCl8fDB9dmFyIGI9InVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93P2kudXNlTGF5b3V0RWZmZWN0OmkudXNlRWZmZWN0LHk9e3Zpc2liaWxpdHk6ImhpZGRlbiIscG9zaXRpb246ImFic29sdXRlIixvdmVyZmxvdzoiaGlkZGVuIixoZWlnaHQ6MCx0b3A6MCxsZWZ0OjAsdHJhbnNmb3JtOiJ0cmFuc2xhdGVaKDApIn0sZz1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5vbkNoYW5nZSxhPWUucm93cyxsPWUucm93c01heCx1PWUucm93c01pbixzPXZvaWQgMD09PXU/MTp1LGM9ZS5zdHlsZSxkPWUudmFsdWUsZj1PYmplY3Qoby5hKShlLFsib25DaGFuZ2UiLCJyb3dzIiwicm93c01heCIsInJvd3NNaW4iLCJzdHlsZSIsInZhbHVlIl0pLHA9YXx8cyxnPWkudXNlUmVmKG51bGwhPWQpLmN1cnJlbnQsdz1pLnVzZVJlZihudWxsKSx4PU9iamVjdChoLmEpKHQsdyksRT1pLnVzZVJlZihudWxsKSxPPWkudXNlUmVmKDApLGs9aS51c2VTdGF0ZSh7fSksUz1rWzBdLEM9a1sxXSxqPWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7dmFyIHQ9dy5jdXJyZW50LG49d2luZG93LmdldENvbXB1dGVkU3R5bGUodCkscj1FLmN1cnJlbnQ7ci5zdHlsZS53aWR0aD1uLndpZHRoLHIudmFsdWU9dC52YWx1ZXx8ZS5wbGFjZWhvbGRlcnx8Ingi",
                    "LCJcbiI9PT1yLnZhbHVlLnNsaWNlKC0xKSYmKHIudmFsdWUrPSIgIik7dmFyIG89blsiYm94LXNpemluZyJdLGk9dihuLCJwYWRkaW5nLWJvdHRvbSIpK3YobiwicGFkZGluZy10b3AiKSxhPXYobiwiYm9yZGVyLWJvdHRvbS13aWR0aCIpK3YobiwiYm9yZGVyLXRvcC13aWR0aCIpLHU9ci5zY3JvbGxIZWlnaHQtaTtyLnZhbHVlPSJ4Ijt2YXIgcz1yLnNjcm9sbEhlaWdodC1pLGM9dTtwJiYoYz1NYXRoLm1heChOdW1iZXIocCkqcyxjKSksbCYmKGM9TWF0aC5taW4oTnVtYmVyKGwpKnMsYykpO3ZhciBkPShjPU1hdGgubWF4KGMscykpKygiYm9yZGVyLWJveCI9PT1vP2krYTowKSxmPU1hdGguYWJzKGMtdSk8PTE7QygoZnVuY3Rpb24oZSl7cmV0dXJuIE8uY3VycmVudDwyMCYmKGQ+MCYmTWF0aC5hYnMoKGUub3V0ZXJIZWlnaHRTdHlsZXx8MCktZCk+MXx8ZS5vdmVyZmxvdyE9PWYpPyhPLmN1cnJlbnQrPTEse292ZXJmbG93OmYsb3V0ZXJIZWlnaHRTdHlsZTpkfSk6ZX0pKX0pLFtsLHAsZS5wbGFjZWhvbGRlcl0pO2kudXNlRWZmZWN0KChmdW5jdGlvbigpe3ZhciBlPW0oKGZ1bmN0aW9uKCl7Ty5jdXJyZW50PTAsaigpfSkpO3JldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixlKSxmdW5jdGlvbigpe2UuY2xlYXIoKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIixlKX19KSxbal0pLGIoKGZ1bmN0aW9uKCl7aigpfSkpLGkudXNlRWZmZWN0KChmdW5jdGlvbigpe08uY3VycmVudD0w",
                    "fSksW2RdKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KGkuRnJhZ21lbnQsbnVsbCxpLmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIixPYmplY3Qoci5hKSh7dmFsdWU6ZCxvbkNoYW5nZTpmdW5jdGlvbihlKXtPLmN1cnJlbnQ9MCxnfHxqKCksbiYmbihlKX0scmVmOngscm93czpwLHN0eWxlOk9iamVjdChyLmEpKHtoZWlnaHQ6Uy5vdXRlckhlaWdodFN0eWxlLG92ZXJmbG93OlMub3ZlcmZsb3c/ImhpZGRlbiI6bnVsbH0sYyl9LGYpKSxpLmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIix7ImFyaWEtaGlkZGVuIjohMCxjbGFzc05hbWU6ZS5jbGFzc05hbWUscmVhZE9ubHk6ITAscmVmOkUsdGFiSW5kZXg6LTEsc3R5bGU6T2JqZWN0KHIuYSkoe30seSxjKX0pKX0pKTtmdW5jdGlvbiB3KGUpe3JldHVybiBudWxsIT1lJiYhKEFycmF5LmlzQXJyYXkoZSkmJjA9PT1lLmxlbmd0aCl9ZnVuY3Rpb24geChlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO3JldHVybiBlJiYodyhlLnZhbHVlKSYmIiIhPT1lLnZhbHVlfHx0JiZ3KGUuZGVmYXVsdFZhbHVlKSYmIiIhPT1lLmRlZmF1bHRWYWx1ZSl9dmFyIEU9InVuZGVmaW5lZCI9PT10eXBlb2Ygd2luZG93P2kudXNlRWZmZWN0OmkudXNlTGF5b3V0RWZmZWN0LE89aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWVbImFyaWEtZGVzY3JpYmVkYnkiXSxhPWUuYXV0b0NvbXBsZXRlLGY9ZS5hdXRvRm9jdXMsbT1l",
                    "LmNsYXNzZXMsdj1lLmNsYXNzTmFtZSxiPShlLmNvbG9yLGUuZGVmYXVsdFZhbHVlKSx5PWUuZGlzYWJsZWQsdz1lLmVuZEFkb3JubWVudCxPPShlLmVycm9yLGUuZnVsbFdpZHRoKSxrPXZvaWQgMCE9PU8mJk8sUz1lLmlkLEM9ZS5pbnB1dENvbXBvbmVudCxqPXZvaWQgMD09PUM/ImlucHV0IjpDLFQ9ZS5pbnB1dFByb3BzLFA9dm9pZCAwPT09VD97fTpULFI9ZS5pbnB1dFJlZixOPShlLm1hcmdpbixlLm11bHRpbGluZSksTT12b2lkIDAhPT1OJiZOLF89ZS5uYW1lLEE9ZS5vbkJsdXIsST1lLm9uQ2hhbmdlLEQ9ZS5vbkNsaWNrLHo9ZS5vbkZvY3VzLEw9ZS5vbktleURvd24sRj1lLm9uS2V5VXAsJD1lLnBsYWNlaG9sZGVyLFc9ZS5yZWFkT25seSxCPWUucmVuZGVyU3VmZml4LEg9ZS5yb3dzLFY9ZS5yb3dzTWF4LFU9ZS5yb3dzTWluLHE9ZS5zdGFydEFkb3JubWVudCxLPWUudHlwZSxZPXZvaWQgMD09PUs/InRleHQiOkssUT1lLnZhbHVlLFg9T2JqZWN0KG8uYSkoZSxbImFyaWEtZGVzY3JpYmVkYnkiLCJhdXRvQ29tcGxldGUiLCJhdXRvRm9jdXMiLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29sb3IiLCJkZWZhdWx0VmFsdWUiLCJkaXNhYmxlZCIsImVuZEFkb3JubWVudCIsImVycm9yIiwiZnVsbFdpZHRoIiwiaWQiLCJpbnB1dENvbXBvbmVudCIsImlucHV0UHJvcHMiLCJpbnB1dFJlZiIsIm1hcmdpbiIsIm11bHRpbGluZSIsIm5hbWUiLCJvbkJsdXIiLCJvbkNoYW5nZSIsIm9uQ2xpY2siLCJvbkZvY3VzIiwib25L",
                    "ZXlEb3duIiwib25LZXlVcCIsInBsYWNlaG9sZGVyIiwicmVhZE9ubHkiLCJyZW5kZXJTdWZmaXgiLCJyb3dzIiwicm93c01heCIsInJvd3NNaW4iLCJzdGFydEFkb3JubWVudCIsInR5cGUiLCJ2YWx1ZSJdKSxHPW51bGwhPVAudmFsdWU/UC52YWx1ZTpRLEo9aS51c2VSZWYobnVsbCE9RykuY3VycmVudCxaPWkudXNlUmVmKCksZWU9aS51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7MH0pLFtdKSx0ZT1PYmplY3QoaC5hKShQLnJlZixlZSksbmU9T2JqZWN0KGguYSkoUix0ZSkscmU9T2JqZWN0KGguYSkoWixuZSksb2U9aS51c2VTdGF0ZSghMSksaWU9b2VbMF0sYWU9b2VbMV0sbGU9aS51c2VDb250ZXh0KGMpO3ZhciB1ZT1zKHtwcm9wczplLG11aUZvcm1Db250cm9sOmxlLHN0YXRlczpbImNvbG9yIiwiZGlzYWJsZWQiLCJlcnJvciIsImhpZGRlbkxhYmVsIiwibWFyZ2luIiwicmVxdWlyZWQiLCJmaWxsZWQiXX0pO3VlLmZvY3VzZWQ9bGU/bGUuZm9jdXNlZDppZSxpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXshbGUmJnkmJmllJiYoYWUoITEpLEEmJkEoKSl9KSxbbGUseSxpZSxBXSk7dmFyIHNlPWxlJiZsZS5vbkZpbGxlZCxjZT1sZSYmbGUub25FbXB0eSxkZT1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXt4KGUpP3NlJiZzZSgpOmNlJiZjZSgpfSksW3NlLGNlXSk7RSgoZnVuY3Rpb24oKXtKJiZkZSh7dmFsdWU6R30pfSksW0csZGUsSl0pO2kudXNlRWZmZWN0KChmdW5jdGlvbigpe2RlKFouY3VycmVudCl9KSxbXSk7",
                    "dmFyIGZlPWoscGU9T2JqZWN0KHIuYSkoe30sUCx7cmVmOnJlfSk7InN0cmluZyIhPT10eXBlb2YgZmU/cGU9T2JqZWN0KHIuYSkoe2lucHV0UmVmOnJlLHR5cGU6WX0scGUse3JlZjpudWxsfSk6TT8hSHx8Vnx8VT8ocGU9T2JqZWN0KHIuYSkoe3Jvd3M6SCxyb3dzTWF4OlZ9LHBlKSxmZT1nKTpmZT0idGV4dGFyZWEiOnBlPU9iamVjdChyLmEpKHt0eXBlOll9LHBlKTtyZXR1cm4gaS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7bGUmJmxlLnNldEFkb3JuZWRTdGFydChCb29sZWFuKHEpKX0pLFtsZSxxXSksaS5jcmVhdGVFbGVtZW50KCJkaXYiLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGwuYSkobS5yb290LG1bImNvbG9yIi5jb25jYXQoT2JqZWN0KHAuYSkodWUuY29sb3J8fCJwcmltYXJ5IikpXSx2LHVlLmRpc2FibGVkJiZtLmRpc2FibGVkLHVlLmVycm9yJiZtLmVycm9yLGsmJm0uZnVsbFdpZHRoLHVlLmZvY3VzZWQmJm0uZm9jdXNlZCxsZSYmbS5mb3JtQ29udHJvbCxNJiZtLm11bHRpbGluZSxxJiZtLmFkb3JuZWRTdGFydCx3JiZtLmFkb3JuZWRFbmQsImRlbnNlIj09PXVlLm1hcmdpbiYmbS5tYXJnaW5EZW5zZSksb25DbGljazpmdW5jdGlvbihlKXtaLmN1cnJlbnQmJmUuY3VycmVudFRhcmdldD09PWUudGFyZ2V0JiZaLmN1cnJlbnQuZm9jdXMoKSxEJiZEKGUpfSxyZWY6dH0sWCkscSxpLmNyZWF0ZUVsZW1lbnQoZC5Qcm92aWRlcix7dmFsdWU6bnVsbH0saS5jcmVhdGVFbGVtZW50KGZlLE9iamVjdChy",
                    "LmEpKHsiYXJpYS1pbnZhbGlkIjp1ZS5lcnJvciwiYXJpYS1kZXNjcmliZWRieSI6bixhdXRvQ29tcGxldGU6YSxhdXRvRm9jdXM6ZixkZWZhdWx0VmFsdWU6YixkaXNhYmxlZDp1ZS5kaXNhYmxlZCxpZDpTLG9uQW5pbWF0aW9uU3RhcnQ6ZnVuY3Rpb24oZSl7ZGUoIm11aS1hdXRvLWZpbGwtY2FuY2VsIj09PWUuYW5pbWF0aW9uTmFtZT9aLmN1cnJlbnQ6e3ZhbHVlOiJ4In0pfSxuYW1lOl8scGxhY2Vob2xkZXI6JCxyZWFkT25seTpXLHJlcXVpcmVkOnVlLnJlcXVpcmVkLHJvd3M6SCx2YWx1ZTpHLG9uS2V5RG93bjpMLG9uS2V5VXA6Rn0scGUse2NsYXNzTmFtZTpPYmplY3QobC5hKShtLmlucHV0LFAuY2xhc3NOYW1lLHVlLmRpc2FibGVkJiZtLmRpc2FibGVkLE0mJm0uaW5wdXRNdWx0aWxpbmUsdWUuaGlkZGVuTGFiZWwmJm0uaW5wdXRIaWRkZW5MYWJlbCxxJiZtLmlucHV0QWRvcm5lZFN0YXJ0LHcmJm0uaW5wdXRBZG9ybmVkRW5kLCJzZWFyY2giPT09WSYmbS5pbnB1dFR5cGVTZWFyY2gsImRlbnNlIj09PXVlLm1hcmdpbiYmbS5pbnB1dE1hcmdpbkRlbnNlKSxvbkJsdXI6ZnVuY3Rpb24oZSl7QSYmQShlKSxQLm9uQmx1ciYmUC5vbkJsdXIoZSksbGUmJmxlLm9uQmx1cj9sZS5vbkJsdXIoZSk6YWUoITEpfSxvbkNoYW5nZTpmdW5jdGlvbihlKXtpZighSil7dmFyIHQ9ZS50YXJnZXR8fFouY3VycmVudDtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihPYmplY3QodS5hKSgxKSk7ZGUoe3ZhbHVlOnQudmFsdWV9KX1m",
                    "b3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShuPjE/bi0xOjApLG89MTtvPG47bysrKXJbby0xXT1hcmd1bWVudHNbb107UC5vbkNoYW5nZSYmUC5vbkNoYW5nZS5hcHBseShQLFtlXS5jb25jYXQocikpLEkmJkkuYXBwbHkodm9pZCAwLFtlXS5jb25jYXQocikpfSxvbkZvY3VzOmZ1bmN0aW9uKGUpe3VlLmRpc2FibGVkP2Uuc3RvcFByb3BhZ2F0aW9uKCk6KHomJnooZSksUC5vbkZvY3VzJiZQLm9uRm9jdXMoZSksbGUmJmxlLm9uRm9jdXM/bGUub25Gb2N1cyhlKTphZSghMCkpfX0pKSksdyxCP0IoT2JqZWN0KHIuYSkoe30sdWUse3N0YXJ0QWRvcm5tZW50OnF9KSk6bnVsbCl9KSksaz1PYmplY3QoZi5hKSgoZnVuY3Rpb24oZSl7dmFyIHQ9ImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlLG49e2NvbG9yOiJjdXJyZW50Q29sb3IiLG9wYWNpdHk6dD8uNDI6LjUsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcn0pfSxvPXtvcGFjaXR5OiIwICFpbXBvcnRhbnQifSxpPXtvcGFjaXR5OnQ/LjQyOi41fTtyZXR1cm57IkBnbG9iYWwiOnsiQGtleWZyYW1lcyBtdWktYXV0by1maWxsIjp7fSwiQGtleWZyYW1lcyBtdWktYXV0by1maWxsLWNhbmNlbCI6e319LHJvb3Q6T2JqZWN0KHIuYSkoe30sZS50eXBvZ3JhcGh5LmJvZHkxLHtjb2xvcjplLnBhbGV0dGUudGV4dC5wcmltYXJ5LGxpbmVIZWlnaHQ6IjEuMTg3NmVt",
                    "Iixib3hTaXppbmc6ImJvcmRlci1ib3giLHBvc2l0aW9uOiJyZWxhdGl2ZSIsY3Vyc29yOiJ0ZXh0IixkaXNwbGF5OiJpbmxpbmUtZmxleCIsYWxpZ25JdGVtczoiY2VudGVyIiwiJiRkaXNhYmxlZCI6e2NvbG9yOmUucGFsZXR0ZS50ZXh0LmRpc2FibGVkLGN1cnNvcjoiZGVmYXVsdCJ9fSksZm9ybUNvbnRyb2w6e30sZm9jdXNlZDp7fSxkaXNhYmxlZDp7fSxhZG9ybmVkU3RhcnQ6e30sYWRvcm5lZEVuZDp7fSxlcnJvcjp7fSxtYXJnaW5EZW5zZTp7fSxtdWx0aWxpbmU6e3BhZGRpbmc6IiIuY29uY2F0KDYsInB4IDAgIikuY29uY2F0KDcsInB4IiksIiYkbWFyZ2luRGVuc2UiOntwYWRkaW5nVG9wOjN9fSxjb2xvclNlY29uZGFyeTp7fSxmdWxsV2lkdGg6e3dpZHRoOiIxMDAlIn0saW5wdXQ6e2ZvbnQ6ImluaGVyaXQiLGxldHRlclNwYWNpbmc6ImluaGVyaXQiLGNvbG9yOiJjdXJyZW50Q29sb3IiLHBhZGRpbmc6IiIuY29uY2F0KDYsInB4IDAgIikuY29uY2F0KDcsInB4IiksYm9yZGVyOjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsYmFja2dyb3VuZDoibm9uZSIsaGVpZ2h0OiIxLjE4NzZlbSIsbWFyZ2luOjAsV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6InRyYW5zcGFyZW50IixkaXNwbGF5OiJibG9jayIsbWluV2lkdGg6MCx3aWR0aDoiMTAwJSIsYW5pbWF0aW9uTmFtZToibXVpLWF1dG8tZmlsbC1jYW5jZWwiLGFuaW1hdGlvbkR1cmF0aW9uOiIxMG1zIiwiJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciI6biwi",
                    "Jjo6LW1vei1wbGFjZWhvbGRlciI6biwiJjotbXMtaW5wdXQtcGxhY2Vob2xkZXIiOm4sIiY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciI6biwiJjpmb2N1cyI6e291dGxpbmU6MH0sIiY6aW52YWxpZCI6e2JveFNoYWRvdzoibm9uZSJ9LCImOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIjp7Ii13ZWJraXQtYXBwZWFyYW5jZSI6Im5vbmUifSwibGFiZWxbZGF0YS1zaHJpbms9ZmFsc2VdICsgJGZvcm1Db250cm9sICYiOnsiJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciI6bywiJjo6LW1vei1wbGFjZWhvbGRlciI6bywiJjotbXMtaW5wdXQtcGxhY2Vob2xkZXIiOm8sIiY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciI6bywiJjpmb2N1czo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciI6aSwiJjpmb2N1czo6LW1vei1wbGFjZWhvbGRlciI6aSwiJjpmb2N1czotbXMtaW5wdXQtcGxhY2Vob2xkZXIiOmksIiY6Zm9jdXM6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciI6aX0sIiYkZGlzYWJsZWQiOntvcGFjaXR5OjF9LCImOi13ZWJraXQtYXV0b2ZpbGwiOnthbmltYXRpb25EdXJhdGlvbjoiNTAwMHMiLGFuaW1hdGlvbk5hbWU6Im11aS1hdXRvLWZpbGwifX0saW5wdXRNYXJnaW5EZW5zZTp7cGFkZGluZ1RvcDozfSxpbnB1dE11bHRpbGluZTp7aGVpZ2h0OiJhdXRvIixyZXNpemU6Im5vbmUiLHBhZGRpbmc6MH0saW5wdXRUeXBlU2VhcmNoOnsiLW1vei1hcHBlYXJhbmNlIjoidGV4dGZpZWxkIiwiLXdlYmtpdC1hcHBlYXJhbmNl",
                    "IjoidGV4dGZpZWxkIn0saW5wdXRBZG9ybmVkU3RhcnQ6e30saW5wdXRBZG9ybmVkRW5kOnt9LGlucHV0SGlkZGVuTGFiZWw6e319fSkse25hbWU6Ik11aUlucHV0QmFzZSJ9KShPKSxTPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmRpc2FibGVVbmRlcmxpbmUsYT1lLmNsYXNzZXMsdT1lLmZ1bGxXaWR0aCxzPXZvaWQgMCE9PXUmJnUsYz1lLmlucHV0Q29tcG9uZW50LGQ9dm9pZCAwPT09Yz8iaW5wdXQiOmMsZj1lLm11bHRpbGluZSxwPXZvaWQgMCE9PWYmJmYsaD1lLnR5cGUsbT12b2lkIDA9PT1oPyJ0ZXh0IjpoLHY9T2JqZWN0KG8uYSkoZSxbImRpc2FibGVVbmRlcmxpbmUiLCJjbGFzc2VzIiwiZnVsbFdpZHRoIiwiaW5wdXRDb21wb25lbnQiLCJtdWx0aWxpbmUiLCJ0eXBlIl0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoayxPYmplY3Qoci5hKSh7Y2xhc3NlczpPYmplY3Qoci5hKSh7fSxhLHtyb290Ok9iamVjdChsLmEpKGEucm9vdCwhbiYmYS51bmRlcmxpbmUpLHVuZGVybGluZTpudWxsfSksZnVsbFdpZHRoOnMsaW5wdXRDb21wb25lbnQ6ZCxtdWx0aWxpbmU6cCxyZWY6dCx0eXBlOm19LHYpKX0pKTtTLm11aU5hbWU9IklucHV0Ijt2YXIgQz1PYmplY3QoZi5hKSgoZnVuY3Rpb24oZSl7dmFyIHQ9ImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlPyJyZ2JhKDAsIDAsIDAsIDAuNDIpIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpIjtyZXR1cm57cm9vdDp7cG9zaXRpb246InJlbGF0aXZlIn0sZm9y",
                    "bUNvbnRyb2w6eyJsYWJlbCArICYiOnttYXJnaW5Ub3A6MTZ9fSxmb2N1c2VkOnt9LGRpc2FibGVkOnt9LGNvbG9yU2Vjb25kYXJ5OnsiJiR1bmRlcmxpbmU6YWZ0ZXIiOntib3JkZXJCb3R0b21Db2xvcjplLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW59fSx1bmRlcmxpbmU6eyImOmFmdGVyIjp7Ym9yZGVyQm90dG9tOiIycHggc29saWQgIi5jb25jYXQoZS5wYWxldHRlLnByaW1hcnkubWFpbiksbGVmdDowLGJvdHRvbTowLGNvbnRlbnQ6JyIiJyxwb3NpdGlvbjoiYWJzb2x1dGUiLHJpZ2h0OjAsdHJhbnNmb3JtOiJzY2FsZVgoMCkiLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoInRyYW5zZm9ybSIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dH0pLHBvaW50ZXJFdmVudHM6Im5vbmUifSwiJiRmb2N1c2VkOmFmdGVyIjp7dHJhbnNmb3JtOiJzY2FsZVgoMSkifSwiJiRlcnJvcjphZnRlciI6e2JvcmRlckJvdHRvbUNvbG9yOmUucGFsZXR0ZS5lcnJvci5tYWluLHRyYW5zZm9ybToic2NhbGVYKDEpIn0sIiY6YmVmb3JlIjp7Ym9yZGVyQm90dG9tOiIxcHggc29saWQgIi5jb25jYXQodCksbGVmdDowLGJvdHRvbTowLGNvbnRlbnQ6JyJcXDAwYTAiJyxwb3NpdGlvbjoiYWJzb2x1dGUiLHJpZ2h0OjAsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiYm9yZGVyLWJvdHRvbS1jb2xvciIse2R1cmF0aW9uOmUudHJhbnNp",
                    "dGlvbnMuZHVyYXRpb24uc2hvcnRlcn0pLHBvaW50ZXJFdmVudHM6Im5vbmUifSwiJjpob3Zlcjpub3QoJGRpc2FibGVkKTpiZWZvcmUiOntib3JkZXJCb3R0b206IjJweCBzb2xpZCAiLmNvbmNhdChlLnBhbGV0dGUudGV4dC5wcmltYXJ5KSwiQG1lZGlhIChob3Zlcjogbm9uZSkiOntib3JkZXJCb3R0b206IjFweCBzb2xpZCAiLmNvbmNhdCh0KX19LCImJGRpc2FibGVkOmJlZm9yZSI6e2JvcmRlckJvdHRvbVN0eWxlOiJkb3R0ZWQifX0sZXJyb3I6e30sbWFyZ2luRGVuc2U6e30sbXVsdGlsaW5lOnt9LGZ1bGxXaWR0aDp7fSxpbnB1dDp7fSxpbnB1dE1hcmdpbkRlbnNlOnt9LGlucHV0TXVsdGlsaW5lOnt9LGlucHV0VHlwZVNlYXJjaDp7fX19KSx7bmFtZToiTXVpSW5wdXQifSkoUyksaj1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5kaXNhYmxlVW5kZXJsaW5lLGE9ZS5jbGFzc2VzLHU9ZS5mdWxsV2lkdGgscz12b2lkIDAhPT11JiZ1LGM9ZS5pbnB1dENvbXBvbmVudCxkPXZvaWQgMD09PWM/ImlucHV0IjpjLGY9ZS5tdWx0aWxpbmUscD12b2lkIDAhPT1mJiZmLGg9ZS50eXBlLG09dm9pZCAwPT09aD8idGV4dCI6aCx2PU9iamVjdChvLmEpKGUsWyJkaXNhYmxlVW5kZXJsaW5lIiwiY2xhc3NlcyIsImZ1bGxXaWR0aCIsImlucHV0Q29tcG9uZW50IiwibXVsdGlsaW5lIiwidHlwZSJdKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KGssT2JqZWN0KHIuYSkoe2NsYXNzZXM6T2JqZWN0KHIuYSkoe30sYSx7",
                    "cm9vdDpPYmplY3QobC5hKShhLnJvb3QsIW4mJmEudW5kZXJsaW5lKSx1bmRlcmxpbmU6bnVsbH0pLGZ1bGxXaWR0aDpzLGlucHV0Q29tcG9uZW50OmQsbXVsdGlsaW5lOnAscmVmOnQsdHlwZTptfSx2KSl9KSk7ai5tdWlOYW1lPSJJbnB1dCI7dmFyIFQ9T2JqZWN0KGYuYSkoKGZ1bmN0aW9uKGUpe3ZhciB0PSJsaWdodCI9PT1lLnBhbGV0dGUudHlwZSxuPXQ/InJnYmEoMCwgMCwgMCwgMC40MikiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNykiLHI9dD8icmdiYSgwLCAwLCAwLCAwLjA5KSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOSkiO3JldHVybntyb290Ontwb3NpdGlvbjoicmVsYXRpdmUiLGJhY2tncm91bmRDb2xvcjpyLGJvcmRlclRvcExlZnRSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXMsYm9yZGVyVG9wUmlnaHRSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXMsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiYmFja2dyb3VuZC1jb2xvciIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dH0pLCImOmhvdmVyIjp7YmFja2dyb3VuZENvbG9yOnQ/InJnYmEoMCwgMCwgMCwgMC4xMykiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTMpIiwiQG1lZGlhIChob3Zlcjogbm9uZSkiOntiYWNrZ3JvdW5kQ29sb3I6cn19LCImJGZvY3VzZWQiOntiYWNrZ3JvdW5kQ29sb3I6dD8icmdiYSgwLCAwLCAwLCAwLjA5KSI6InJn",
                    "YmEoMjU1LCAyNTUsIDI1NSwgMC4wOSkifSwiJiRkaXNhYmxlZCI6e2JhY2tncm91bmRDb2xvcjp0PyJyZ2JhKDAsIDAsIDAsIDAuMTIpIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKSJ9fSxjb2xvclNlY29uZGFyeTp7IiYkdW5kZXJsaW5lOmFmdGVyIjp7Ym9yZGVyQm90dG9tQ29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWlufX0sdW5kZXJsaW5lOnsiJjphZnRlciI6e2JvcmRlckJvdHRvbToiMnB4IHNvbGlkICIuY29uY2F0KGUucGFsZXR0ZS5wcmltYXJ5Lm1haW4pLGxlZnQ6MCxib3R0b206MCxjb250ZW50OiciIicscG9zaXRpb246ImFic29sdXRlIixyaWdodDowLHRyYW5zZm9ybToic2NhbGVYKDApIix0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsZWFzaW5nOmUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXR9KSxwb2ludGVyRXZlbnRzOiJub25lIn0sIiYkZm9jdXNlZDphZnRlciI6e3RyYW5zZm9ybToic2NhbGVYKDEpIn0sIiYkZXJyb3I6YWZ0ZXIiOntib3JkZXJCb3R0b21Db2xvcjplLnBhbGV0dGUuZXJyb3IubWFpbix0cmFuc2Zvcm06InNjYWxlWCgxKSJ9LCImOmJlZm9yZSI6e2JvcmRlckJvdHRvbToiMXB4IHNvbGlkICIuY29uY2F0KG4pLGxlZnQ6MCxib3R0b206MCxjb250ZW50OiciXFwwMGEwIicscG9zaXRpb246ImFic29sdXRlIixyaWdodDowLHRyYW5zaXRpb246ZS50cmFuc2l0aW9u",
                    "cy5jcmVhdGUoImJvcmRlci1ib3R0b20tY29sb3IiLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJ9KSxwb2ludGVyRXZlbnRzOiJub25lIn0sIiY6aG92ZXI6YmVmb3JlIjp7Ym9yZGVyQm90dG9tOiIxcHggc29saWQgIi5jb25jYXQoZS5wYWxldHRlLnRleHQucHJpbWFyeSl9LCImJGRpc2FibGVkOmJlZm9yZSI6e2JvcmRlckJvdHRvbVN0eWxlOiJkb3R0ZWQifX0sZm9jdXNlZDp7fSxkaXNhYmxlZDp7fSxhZG9ybmVkU3RhcnQ6e3BhZGRpbmdMZWZ0OjEyfSxhZG9ybmVkRW5kOntwYWRkaW5nUmlnaHQ6MTJ9LGVycm9yOnt9LG1hcmdpbkRlbnNlOnt9LG11bHRpbGluZTp7cGFkZGluZzoiMjdweCAxMnB4IDEwcHgiLCImJG1hcmdpbkRlbnNlIjp7cGFkZGluZ1RvcDoyMyxwYWRkaW5nQm90dG9tOjZ9fSxpbnB1dDp7cGFkZGluZzoiMjdweCAxMnB4IDEwcHgiLCImOi13ZWJraXQtYXV0b2ZpbGwiOntXZWJraXRCb3hTaGFkb3c6ImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlP251bGw6IjAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQiLFdlYmtpdFRleHRGaWxsQ29sb3I6ImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlP251bGw6IiNmZmYiLGNhcmV0Q29sb3I6ImxpZ2h0Ij09PWUucGFsZXR0ZS50eXBlP251bGw6IiNmZmYiLGJvcmRlclRvcExlZnRSYWRpdXM6ImluaGVyaXQiLGJvcmRlclRvcFJpZ2h0UmFkaXVzOiJpbmhlcml0In19LGlucHV0TWFyZ2luRGVuc2U6e3BhZGRpbmdUb3A6MjMscGFkZGluZ0Jv",
                    "dHRvbTo2fSxpbnB1dEhpZGRlbkxhYmVsOntwYWRkaW5nVG9wOjE4LHBhZGRpbmdCb3R0b206MTksIiYkaW5wdXRNYXJnaW5EZW5zZSI6e3BhZGRpbmdUb3A6MTAscGFkZGluZ0JvdHRvbToxMX19LGlucHV0TXVsdGlsaW5lOntwYWRkaW5nOjB9LGlucHV0QWRvcm5lZFN0YXJ0OntwYWRkaW5nTGVmdDowfSxpbnB1dEFkb3JuZWRFbmQ6e3BhZGRpbmdSaWdodDowfX19KSx7bmFtZToiTXVpRmlsbGVkSW5wdXQifSkoaiksUD1uKDMwKSxSPW4oMjIpLE49aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe2UuY2hpbGRyZW47dmFyIG49ZS5jbGFzc2VzLGE9ZS5jbGFzc05hbWUsdT1lLmxhYmVsLHM9ZS5sYWJlbFdpZHRoLGM9ZS5ub3RjaGVkLGQ9ZS5zdHlsZSxmPU9iamVjdChvLmEpKGUsWyJjaGlsZHJlbiIsImNsYXNzZXMiLCJjbGFzc05hbWUiLCJsYWJlbCIsImxhYmVsV2lkdGgiLCJub3RjaGVkIiwic3R5bGUiXSksaD0icnRsIj09PU9iamVjdChSLmEpKCkuZGlyZWN0aW9uPyJyaWdodCI6ImxlZnQiO2lmKHZvaWQgMCE9PXUpcmV0dXJuIGkuY3JlYXRlRWxlbWVudCgiZmllbGRzZXQiLE9iamVjdChyLmEpKHsiYXJpYS1oaWRkZW4iOiEwLGNsYXNzTmFtZTpPYmplY3QobC5hKShuLnJvb3QsYSkscmVmOnQsc3R5bGU6ZH0sZiksaS5jcmVhdGVFbGVtZW50KCJsZWdlbmQiLHtjbGFzc05hbWU6T2JqZWN0KGwuYSkobi5sZWdlbmRMYWJlbGxlZCxjJiZuLmxlZ2VuZE5vdGNoZWQpfSx1P2kuY3JlYXRlRWxlbWVudCgic3BhbiIs",
                    "bnVsbCx1KTppLmNyZWF0ZUVsZW1lbnQoInNwYW4iLHtkYW5nZXJvdXNseVNldElubmVySFRNTDp7X19odG1sOiImIzgyMDM7In19KSkpO3ZhciBtPXM+MD8uNzUqcys4Oi4wMTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KCJmaWVsZHNldCIsT2JqZWN0KHIuYSkoeyJhcmlhLWhpZGRlbiI6ITAsc3R5bGU6T2JqZWN0KHIuYSkoT2JqZWN0KFAuYSkoe30sInBhZGRpbmciLmNvbmNhdChPYmplY3QocC5hKShoKSksOCksZCksY2xhc3NOYW1lOk9iamVjdChsLmEpKG4ucm9vdCxhKSxyZWY6dH0sZiksaS5jcmVhdGVFbGVtZW50KCJsZWdlbmQiLHtjbGFzc05hbWU6bi5sZWdlbmQsc3R5bGU6e3dpZHRoOmM/bTouMDF9fSxpLmNyZWF0ZUVsZW1lbnQoInNwYW4iLHtkYW5nZXJvdXNseVNldElubmVySFRNTDp7X19odG1sOiImIzgyMDM7In19KSkpfSkpLE09T2JqZWN0KGYuYSkoKGZ1bmN0aW9uKGUpe3JldHVybntyb290Ontwb3NpdGlvbjoiYWJzb2x1dGUiLGJvdHRvbTowLHJpZ2h0OjAsdG9wOi01LGxlZnQ6MCxtYXJnaW46MCxwYWRkaW5nOiIwIDhweCIscG9pbnRlckV2ZW50czoibm9uZSIsYm9yZGVyUmFkaXVzOiJpbmhlcml0Iixib3JkZXJTdHlsZToic29saWQiLGJvcmRlcldpZHRoOjEsb3ZlcmZsb3c6ImhpZGRlbiJ9LGxlZ2VuZDp7dGV4dEFsaWduOiJsZWZ0IixwYWRkaW5nOjAsbGluZUhlaWdodDoiMTFweCIsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgid2lkdGgiLHtkdXJhdGlvbjoxNTAsZWFzaW5nOmUu",
                    "dHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXR9KX0sbGVnZW5kTGFiZWxsZWQ6e2Rpc3BsYXk6ImJsb2NrIix3aWR0aDoiYXV0byIsdGV4dEFsaWduOiJsZWZ0IixwYWRkaW5nOjAsaGVpZ2h0OjExLGZvbnRTaXplOiIwLjc1ZW0iLHZpc2liaWxpdHk6ImhpZGRlbiIsbWF4V2lkdGg6LjAxLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoIm1heC13aWR0aCIse2R1cmF0aW9uOjUwLGVhc2luZzplLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0fSksIiYgPiBzcGFuIjp7cGFkZGluZ0xlZnQ6NSxwYWRkaW5nUmlnaHQ6NSxkaXNwbGF5OiJpbmxpbmUtYmxvY2sifX0sbGVnZW5kTm90Y2hlZDp7bWF4V2lkdGg6MWUzLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoIm1heC13aWR0aCIse2R1cmF0aW9uOjEwMCxlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dCxkZWxheTo1MH0pfX19KSx7bmFtZToiUHJpdmF0ZU5vdGNoZWRPdXRsaW5lIn0pKE4pLF89aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2xhc3NlcyxhPWUuZnVsbFdpZHRoLHU9dm9pZCAwIT09YSYmYSxzPWUuaW5wdXRDb21wb25lbnQsYz12b2lkIDA9PT1zPyJpbnB1dCI6cyxkPWUubGFiZWwsZj1lLmxhYmVsV2lkdGgscD12b2lkIDA9PT1mPzA6ZixoPWUubXVsdGlsaW5lLG09dm9pZCAwIT09aCYmaCx2PWUubm90Y2hlZCxiPWUudHlwZSx5PXZvaWQgMD09PWI/InRleHQiOmIsZz1PYmplY3Qoby5hKShlLFsiY2xh",
                    "c3NlcyIsImZ1bGxXaWR0aCIsImlucHV0Q29tcG9uZW50IiwibGFiZWwiLCJsYWJlbFdpZHRoIiwibXVsdGlsaW5lIiwibm90Y2hlZCIsInR5cGUiXSk7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChrLE9iamVjdChyLmEpKHtyZW5kZXJTdWZmaXg6ZnVuY3Rpb24oZSl7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChNLHtjbGFzc05hbWU6bi5ub3RjaGVkT3V0bGluZSxsYWJlbDpkLGxhYmVsV2lkdGg6cCxub3RjaGVkOiJ1bmRlZmluZWQiIT09dHlwZW9mIHY/djpCb29sZWFuKGUuc3RhcnRBZG9ybm1lbnR8fGUuZmlsbGVkfHxlLmZvY3VzZWQpfSl9LGNsYXNzZXM6T2JqZWN0KHIuYSkoe30sbix7cm9vdDpPYmplY3QobC5hKShuLnJvb3Qsbi51bmRlcmxpbmUpLG5vdGNoZWRPdXRsaW5lOm51bGx9KSxmdWxsV2lkdGg6dSxpbnB1dENvbXBvbmVudDpjLG11bHRpbGluZTptLHJlZjp0LHR5cGU6eX0sZykpfSkpO18ubXVpTmFtZT0iSW5wdXQiO3ZhciBBPU9iamVjdChmLmEpKChmdW5jdGlvbihlKXt2YXIgdD0ibGlnaHQiPT09ZS5wYWxldHRlLnR5cGU/InJnYmEoMCwgMCwgMCwgMC4yMykiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjMpIjtyZXR1cm57cm9vdDp7cG9zaXRpb246InJlbGF0aXZlIixib3JkZXJSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXMsIiY6aG92ZXIgJG5vdGNoZWRPdXRsaW5lIjp7Ym9yZGVyQ29sb3I6ZS5wYWxldHRlLnRleHQucHJpbWFyeX0sIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7IiY6aG92ZXIgJG5v",
                    "dGNoZWRPdXRsaW5lIjp7Ym9yZGVyQ29sb3I6dH19LCImJGZvY3VzZWQgJG5vdGNoZWRPdXRsaW5lIjp7Ym9yZGVyQ29sb3I6ZS5wYWxldHRlLnByaW1hcnkubWFpbixib3JkZXJXaWR0aDoyfSwiJiRlcnJvciAkbm90Y2hlZE91dGxpbmUiOntib3JkZXJDb2xvcjplLnBhbGV0dGUuZXJyb3IubWFpbn0sIiYkZGlzYWJsZWQgJG5vdGNoZWRPdXRsaW5lIjp7Ym9yZGVyQ29sb3I6ZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZH19LGNvbG9yU2Vjb25kYXJ5OnsiJiRmb2N1c2VkICRub3RjaGVkT3V0bGluZSI6e2JvcmRlckNvbG9yOmUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbn19LGZvY3VzZWQ6e30sZGlzYWJsZWQ6e30sYWRvcm5lZFN0YXJ0OntwYWRkaW5nTGVmdDoxNH0sYWRvcm5lZEVuZDp7cGFkZGluZ1JpZ2h0OjE0fSxlcnJvcjp7fSxtYXJnaW5EZW5zZTp7fSxtdWx0aWxpbmU6e3BhZGRpbmc6IjE4LjVweCAxNHB4IiwiJiRtYXJnaW5EZW5zZSI6e3BhZGRpbmdUb3A6MTAuNSxwYWRkaW5nQm90dG9tOjEwLjV9fSxub3RjaGVkT3V0bGluZTp7Ym9yZGVyQ29sb3I6dH0saW5wdXQ6e3BhZGRpbmc6IjE4LjVweCAxNHB4IiwiJjotd2Via2l0LWF1dG9maWxsIjp7V2Via2l0Qm94U2hhZG93OiJsaWdodCI9PT1lLnBhbGV0dGUudHlwZT9udWxsOiIwIDAgMCAxMDBweCAjMjY2Nzk4IGluc2V0IixXZWJraXRUZXh0RmlsbENvbG9yOiJsaWdodCI9PT1lLnBhbGV0dGUudHlwZT9udWxsOiIjZmZmIixjYXJldENvbG9yOiJsaWdodCI9",
                    "PT1lLnBhbGV0dGUudHlwZT9udWxsOiIjZmZmIixib3JkZXJSYWRpdXM6ImluaGVyaXQifX0saW5wdXRNYXJnaW5EZW5zZTp7cGFkZGluZ1RvcDoxMC41LHBhZGRpbmdCb3R0b206MTAuNX0saW5wdXRNdWx0aWxpbmU6e3BhZGRpbmc6MH0saW5wdXRBZG9ybmVkU3RhcnQ6e3BhZGRpbmdMZWZ0OjB9LGlucHV0QWRvcm5lZEVuZDp7cGFkZGluZ1JpZ2h0OjB9fX0pLHtuYW1lOiJNdWlPdXRsaW5lZElucHV0In0pKF8pO2Z1bmN0aW9uIEkoKXtyZXR1cm4gaS51c2VDb250ZXh0KGQpfXZhciBEPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNoaWxkcmVuLGE9ZS5jbGFzc2VzLHU9ZS5jbGFzc05hbWUsYz0oZS5jb2xvcixlLmNvbXBvbmVudCksZD12b2lkIDA9PT1jPyJsYWJlbCI6YyxmPShlLmRpc2FibGVkLGUuZXJyb3IsZS5maWxsZWQsZS5mb2N1c2VkLGUucmVxdWlyZWQsT2JqZWN0KG8uYSkoZSxbImNoaWxkcmVuIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbG9yIiwiY29tcG9uZW50IiwiZGlzYWJsZWQiLCJlcnJvciIsImZpbGxlZCIsImZvY3VzZWQiLCJyZXF1aXJlZCJdKSksaD1zKHtwcm9wczplLG11aUZvcm1Db250cm9sOkkoKSxzdGF0ZXM6WyJjb2xvciIsInJlcXVpcmVkIiwiZm9jdXNlZCIsImRpc2FibGVkIiwiZXJyb3IiLCJmaWxsZWQiXX0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoZCxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChsLmEpKGEucm9vdCxhWyJjb2xvciIuY29uY2F0",
                    "KE9iamVjdChwLmEpKGguY29sb3J8fCJwcmltYXJ5IikpXSx1LGguZGlzYWJsZWQmJmEuZGlzYWJsZWQsaC5lcnJvciYmYS5lcnJvcixoLmZpbGxlZCYmYS5maWxsZWQsaC5mb2N1c2VkJiZhLmZvY3VzZWQsaC5yZXF1aXJlZCYmYS5yZXF1aXJlZCkscmVmOnR9LGYpLG4saC5yZXF1aXJlZCYmaS5jcmVhdGVFbGVtZW50KCJzcGFuIix7ImFyaWEtaGlkZGVuIjohMCxjbGFzc05hbWU6T2JqZWN0KGwuYSkoYS5hc3RlcmlzayxoLmVycm9yJiZhLmVycm9yKX0sIlx1MjAwOSIsIioiKSl9KSksej1PYmplY3QoZi5hKSgoZnVuY3Rpb24oZSl7cmV0dXJue3Jvb3Q6T2JqZWN0KHIuYSkoe2NvbG9yOmUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeX0sZS50eXBvZ3JhcGh5LmJvZHkxLHtsaW5lSGVpZ2h0OjEscGFkZGluZzowLCImJGZvY3VzZWQiOntjb2xvcjplLnBhbGV0dGUucHJpbWFyeS5tYWlufSwiJiRkaXNhYmxlZCI6e2NvbG9yOmUucGFsZXR0ZS50ZXh0LmRpc2FibGVkfSwiJiRlcnJvciI6e2NvbG9yOmUucGFsZXR0ZS5lcnJvci5tYWlufX0pLGNvbG9yU2Vjb25kYXJ5OnsiJiRmb2N1c2VkIjp7Y29sb3I6ZS5wYWxldHRlLnNlY29uZGFyeS5tYWlufX0sZm9jdXNlZDp7fSxkaXNhYmxlZDp7fSxlcnJvcjp7fSxmaWxsZWQ6e30scmVxdWlyZWQ6e30sYXN0ZXJpc2s6eyImJGVycm9yIjp7Y29sb3I6ZS5wYWxldHRlLmVycm9yLm1haW59fX19KSx7bmFtZToiTXVpRm9ybUxhYmVsIn0pKEQpLEw9aS5mb3J3YXJkUmVmKChmdW5jdGlv",
                    "bihlLHQpe3ZhciBuPWUuY2xhc3NlcyxhPWUuY2xhc3NOYW1lLHU9ZS5kaXNhYmxlQW5pbWF0aW9uLGM9dm9pZCAwIT09dSYmdSxkPShlLm1hcmdpbixlLnNocmluayksZj0oZS52YXJpYW50LE9iamVjdChvLmEpKGUsWyJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiZGlzYWJsZUFuaW1hdGlvbiIsIm1hcmdpbiIsInNocmluayIsInZhcmlhbnQiXSkpLHA9SSgpLGg9ZDsidW5kZWZpbmVkIj09PXR5cGVvZiBoJiZwJiYoaD1wLmZpbGxlZHx8cC5mb2N1c2VkfHxwLmFkb3JuZWRTdGFydCk7dmFyIG09cyh7cHJvcHM6ZSxtdWlGb3JtQ29udHJvbDpwLHN0YXRlczpbIm1hcmdpbiIsInZhcmlhbnQiXX0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoeixPYmplY3Qoci5hKSh7ImRhdGEtc2hyaW5rIjpoLGNsYXNzTmFtZTpPYmplY3QobC5hKShuLnJvb3QsYSxwJiZuLmZvcm1Db250cm9sLCFjJiZuLmFuaW1hdGVkLGgmJm4uc2hyaW5rLCJkZW5zZSI9PT1tLm1hcmdpbiYmbi5tYXJnaW5EZW5zZSx7ZmlsbGVkOm4uZmlsbGVkLG91dGxpbmVkOm4ub3V0bGluZWR9W20udmFyaWFudF0pLGNsYXNzZXM6e2ZvY3VzZWQ6bi5mb2N1c2VkLGRpc2FibGVkOm4uZGlzYWJsZWQsZXJyb3I6bi5lcnJvcixyZXF1aXJlZDpuLnJlcXVpcmVkLGFzdGVyaXNrOm4uYXN0ZXJpc2t9LHJlZjp0fSxmKSl9KSksRj1PYmplY3QoZi5hKSgoZnVuY3Rpb24oZSl7cmV0dXJue3Jvb3Q6e2Rpc3BsYXk6ImJsb2NrIix0cmFuc2Zvcm1PcmlnaW46InRvcCBsZWZ0In0s",
                    "Zm9jdXNlZDp7fSxkaXNhYmxlZDp7fSxlcnJvcjp7fSxyZXF1aXJlZDp7fSxhc3Rlcmlzazp7fSxmb3JtQ29udHJvbDp7cG9zaXRpb246ImFic29sdXRlIixsZWZ0OjAsdG9wOjAsdHJhbnNmb3JtOiJ0cmFuc2xhdGUoMCwgMjRweCkgc2NhbGUoMSkifSxtYXJnaW5EZW5zZTp7dHJhbnNmb3JtOiJ0cmFuc2xhdGUoMCwgMjFweCkgc2NhbGUoMSkifSxzaHJpbms6e3RyYW5zZm9ybToidHJhbnNsYXRlKDAsIDEuNXB4KSBzY2FsZSgwLjc1KSIsdHJhbnNmb3JtT3JpZ2luOiJ0b3AgbGVmdCJ9LGFuaW1hdGVkOnt0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsiY29sb3IiLCJ0cmFuc2Zvcm0iXSx7ZHVyYXRpb246ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLGVhc2luZzplLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0fSl9LGZpbGxlZDp7ekluZGV4OjEscG9pbnRlckV2ZW50czoibm9uZSIsdHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTJweCwgMjBweCkgc2NhbGUoMSkiLCImJG1hcmdpbkRlbnNlIjp7dHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTJweCwgMTdweCkgc2NhbGUoMSkifSwiJiRzaHJpbmsiOnt0cmFuc2Zvcm06InRyYW5zbGF0ZSgxMnB4LCAxMHB4KSBzY2FsZSgwLjc1KSIsIiYkbWFyZ2luRGVuc2UiOnt0cmFuc2Zvcm06InRyYW5zbGF0ZSgxMnB4LCA3cHgpIHNjYWxlKDAuNzUpIn19fSxvdXRsaW5lZDp7ekluZGV4OjEscG9pbnRlckV2ZW50czoibm9uZSIsdHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTRw",
                    "eCwgMjBweCkgc2NhbGUoMSkiLCImJG1hcmdpbkRlbnNlIjp7dHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTRweCwgMTJweCkgc2NhbGUoMSkifSwiJiRzaHJpbmsiOnt0cmFuc2Zvcm06InRyYW5zbGF0ZSgxNHB4LCAtNnB4KSBzY2FsZSgwLjc1KSJ9fX19KSx7bmFtZToiTXVpSW5wdXRMYWJlbCJ9KShMKTtmdW5jdGlvbiAkKGUsdCl7cmV0dXJuIGkuaXNWYWxpZEVsZW1lbnQoZSkmJi0xIT09dC5pbmRleE9mKGUudHlwZS5tdWlOYW1lKX12YXIgVz1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jaGlsZHJlbixhPWUuY2xhc3Nlcyx1PWUuY2xhc3NOYW1lLHM9ZS5jb2xvcixjPXZvaWQgMD09PXM/InByaW1hcnkiOnMsZj1lLmNvbXBvbmVudCxoPXZvaWQgMD09PWY/ImRpdiI6ZixtPWUuZGlzYWJsZWQsdj12b2lkIDAhPT1tJiZtLGI9ZS5lcnJvcix5PXZvaWQgMCE9PWImJmIsZz1lLmZ1bGxXaWR0aCx3PXZvaWQgMCE9PWcmJmcsRT1lLmZvY3VzZWQsTz1lLmhpZGRlbkxhYmVsLGs9dm9pZCAwIT09TyYmTyxTPWUubWFyZ2luLEM9dm9pZCAwPT09Uz8ibm9uZSI6UyxqPWUucmVxdWlyZWQsVD12b2lkIDAhPT1qJiZqLFA9ZS5zaXplLFI9ZS52YXJpYW50LE49dm9pZCAwPT09Uj8ic3RhbmRhcmQiOlIsTT1PYmplY3Qoby5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29sb3IiLCJjb21wb25lbnQiLCJkaXNhYmxlZCIsImVycm9yIiwiZnVsbFdpZHRoIiwiZm9jdXNlZCIsImhpZGRlbkxh",
                    "YmVsIiwibWFyZ2luIiwicmVxdWlyZWQiLCJzaXplIiwidmFyaWFudCJdKSxfPWkudXNlU3RhdGUoKGZ1bmN0aW9uKCl7dmFyIGU9ITE7cmV0dXJuIG4mJmkuQ2hpbGRyZW4uZm9yRWFjaChuLChmdW5jdGlvbih0KXtpZigkKHQsWyJJbnB1dCIsIlNlbGVjdCJdKSl7dmFyIG49JCh0LFsiU2VsZWN0Il0pP3QucHJvcHMuaW5wdXQ6dDtuJiZuLnByb3BzLnN0YXJ0QWRvcm5tZW50JiYoZT0hMCl9fSkpLGV9KSksQT1fWzBdLEk9X1sxXSxEPWkudXNlU3RhdGUoKGZ1bmN0aW9uKCl7dmFyIGU9ITE7cmV0dXJuIG4mJmkuQ2hpbGRyZW4uZm9yRWFjaChuLChmdW5jdGlvbih0KXskKHQsWyJJbnB1dCIsIlNlbGVjdCJdKSYmeCh0LnByb3BzLCEwKSYmKGU9ITApfSkpLGV9KSksej1EWzBdLEw9RFsxXSxGPWkudXNlU3RhdGUoITEpLFc9RlswXSxCPUZbMV0sSD12b2lkIDAhPT1FP0U6Vzt2JiZIJiZCKCExKTt2YXIgVj1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbigpe0woITApfSksW10pLFU9e2Fkb3JuZWRTdGFydDpBLHNldEFkb3JuZWRTdGFydDpJLGNvbG9yOmMsZGlzYWJsZWQ6dixlcnJvcjp5LGZpbGxlZDp6LGZvY3VzZWQ6SCxmdWxsV2lkdGg6dyxoaWRkZW5MYWJlbDprLG1hcmdpbjooInNtYWxsIj09PVA/ImRlbnNlIjp2b2lkIDApfHxDLG9uQmx1cjpmdW5jdGlvbigpe0IoITEpfSxvbkVtcHR5OmkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7TCghMSl9KSxbXSksb25GaWxsZWQ6VixvbkZvY3VzOmZ1bmN0aW9uKCl7QighMCl9",
                    "LHJlZ2lzdGVyRWZmZWN0OnZvaWQgMCxyZXF1aXJlZDpULHZhcmlhbnQ6Tn07cmV0dXJuIGkuY3JlYXRlRWxlbWVudChkLlByb3ZpZGVyLHt2YWx1ZTpVfSxpLmNyZWF0ZUVsZW1lbnQoaCxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChsLmEpKGEucm9vdCx1LCJub25lIiE9PUMmJmFbIm1hcmdpbiIuY29uY2F0KE9iamVjdChwLmEpKEMpKV0sdyYmYS5mdWxsV2lkdGgpLHJlZjp0fSxNKSxuKSl9KSksQj1PYmplY3QoZi5hKSh7cm9vdDp7ZGlzcGxheToiaW5saW5lLWZsZXgiLGZsZXhEaXJlY3Rpb246ImNvbHVtbiIscG9zaXRpb246InJlbGF0aXZlIixtaW5XaWR0aDowLHBhZGRpbmc6MCxtYXJnaW46MCxib3JkZXI6MCx2ZXJ0aWNhbEFsaWduOiJ0b3AifSxtYXJnaW5Ob3JtYWw6e21hcmdpblRvcDoxNixtYXJnaW5Cb3R0b206OH0sbWFyZ2luRGVuc2U6e21hcmdpblRvcDo4LG1hcmdpbkJvdHRvbTo0fSxmdWxsV2lkdGg6e3dpZHRoOiIxMDAlIn19LHtuYW1lOiJNdWlGb3JtQ29udHJvbCJ9KShXKSxIPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNoaWxkcmVuLGE9ZS5jbGFzc2VzLHU9ZS5jbGFzc05hbWUsYz1lLmNvbXBvbmVudCxkPXZvaWQgMD09PWM/InAiOmMsZj0oZS5kaXNhYmxlZCxlLmVycm9yLGUuZmlsbGVkLGUuZm9jdXNlZCxlLm1hcmdpbixlLnJlcXVpcmVkLGUudmFyaWFudCxPYmplY3Qoby5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29tcG9uZW50",
                    "IiwiZGlzYWJsZWQiLCJlcnJvciIsImZpbGxlZCIsImZvY3VzZWQiLCJtYXJnaW4iLCJyZXF1aXJlZCIsInZhcmlhbnQiXSkpLHA9cyh7cHJvcHM6ZSxtdWlGb3JtQ29udHJvbDpJKCksc3RhdGVzOlsidmFyaWFudCIsIm1hcmdpbiIsImRpc2FibGVkIiwiZXJyb3IiLCJmaWxsZWQiLCJmb2N1c2VkIiwicmVxdWlyZWQiXX0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoZCxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChsLmEpKGEucm9vdCwoImZpbGxlZCI9PT1wLnZhcmlhbnR8fCJvdXRsaW5lZCI9PT1wLnZhcmlhbnQpJiZhLmNvbnRhaW5lZCx1LHAuZGlzYWJsZWQmJmEuZGlzYWJsZWQscC5lcnJvciYmYS5lcnJvcixwLmZpbGxlZCYmYS5maWxsZWQscC5mb2N1c2VkJiZhLmZvY3VzZWQscC5yZXF1aXJlZCYmYS5yZXF1aXJlZCwiZGVuc2UiPT09cC5tYXJnaW4mJmEubWFyZ2luRGVuc2UpLHJlZjp0fSxmKSwiICI9PT1uP2kuY3JlYXRlRWxlbWVudCgic3BhbiIse2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MOntfX2h0bWw6IiYjODIwMzsifX0pOm4pfSkpLFY9T2JqZWN0KGYuYSkoKGZ1bmN0aW9uKGUpe3JldHVybntyb290Ok9iamVjdChyLmEpKHtjb2xvcjplLnBhbGV0dGUudGV4dC5zZWNvbmRhcnl9LGUudHlwb2dyYXBoeS5jYXB0aW9uLHt0ZXh0QWxpZ246ImxlZnQiLG1hcmdpblRvcDozLG1hcmdpbjowLCImJGRpc2FibGVkIjp7Y29sb3I6ZS5wYWxldHRlLnRleHQuZGlzYWJsZWR9LCImJGVycm9yIjp7Y29sb3I6",
                    "ZS5wYWxldHRlLmVycm9yLm1haW59fSksZXJyb3I6e30sZGlzYWJsZWQ6e30sbWFyZ2luRGVuc2U6e21hcmdpblRvcDo0fSxjb250YWluZWQ6e21hcmdpbkxlZnQ6MTQsbWFyZ2luUmlnaHQ6MTR9LGZvY3VzZWQ6e30sZmlsbGVkOnt9LHJlcXVpcmVkOnt9fX0pLHtuYW1lOiJNdWlGb3JtSGVscGVyVGV4dCJ9KShIKSxVPW4oMTI2KSxxPW4oMTkpLEs9bigyOSk7bigyOCk7ZnVuY3Rpb24gWShlKXtyZXR1cm4gZSYmZS5vd25lckRvY3VtZW50fHxkb2N1bWVudH12YXIgUT1uKDgpO2Z1bmN0aW9uIFgoZSl7cmV0dXJuIFkoZSkuZGVmYXVsdFZpZXd8fHdpbmRvd31mdW5jdGlvbiBHKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSksbj0wO248ZTtuKyspdFtuXT1hcmd1bWVudHNbbl07cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBudWxsPT10P2U6ZnVuY3Rpb24oKXtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShuKSxvPTA7bzxuO28rKylyW29dPWFyZ3VtZW50c1tvXTtlLmFwcGx5KHRoaXMsciksdC5hcHBseSh0aGlzLHIpfX0pLChmdW5jdGlvbigpe30pKX12YXIgSj1uKDk1KSxaPW4oMTI3KSxlZT1uKDI1KTt2YXIgdGU9InVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93P2kudXNlTGF5b3V0RWZmZWN0OmkudXNlRWZmZWN0O3ZhciBuZT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jaGlsZHJlbixyPWUuY29udGFpbmVyLG89ZS5k",
                    "aXNhYmxlUG9ydGFsLGE9dm9pZCAwIT09byYmbyxsPWUub25SZW5kZXJlZCx1PWkudXNlU3RhdGUobnVsbCkscz11WzBdLGM9dVsxXSxkPU9iamVjdChoLmEpKGkuaXNWYWxpZEVsZW1lbnQobik/bi5yZWY6bnVsbCx0KTtyZXR1cm4gdGUoKGZ1bmN0aW9uKCl7YXx8YyhmdW5jdGlvbihlKXtyZXR1cm4gZT0iZnVuY3Rpb24iPT09dHlwZW9mIGU/ZSgpOmUsUS5maW5kRE9NTm9kZShlKX0ocil8fGRvY3VtZW50LmJvZHkpfSksW3IsYV0pLHRlKChmdW5jdGlvbigpe2lmKHMmJiFhKXJldHVybiBPYmplY3QoZWUuYSkodCxzKSxmdW5jdGlvbigpe09iamVjdChlZS5hKSh0LG51bGwpfX0pLFt0LHMsYV0pLHRlKChmdW5jdGlvbigpe2wmJihzfHxhKSYmbCgpfSksW2wscyxhXSksYT9pLmlzVmFsaWRFbGVtZW50KG4pP2kuY2xvbmVFbGVtZW50KG4se3JlZjpkfSk6bjpzP1EuY3JlYXRlUG9ydGFsKG4scyk6c30pKSxyZT1uKDIwKSxvZT1uKDQ0KTt2YXIgaWU9bigzNSksYWU9bigyNCk7ZnVuY3Rpb24gbGUoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLnN0eWxlLndpZHRoPSI5OXB4IixlLnN0eWxlLmhlaWdodD0iOTlweCIsZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGUuc3R5bGUudG9wPSItOTk5OXB4IixlLnN0eWxlLm92ZXJmbG93PSJzY3JvbGwiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSk7dmFyIHQ9ZS5vZmZzZXRXaWR0aC1lLmNsaWVudFdpZHRoO3JldHVybiBkb2N1bWVudC5ib2R5",
                    "LnJlbW92ZUNoaWxkKGUpLHR9ZnVuY3Rpb24gdWUoZSx0KXt0P2Uuc2V0QXR0cmlidXRlKCJhcmlhLWhpZGRlbiIsInRydWUiKTplLnJlbW92ZUF0dHJpYnV0ZSgiYXJpYS1oaWRkZW4iKX1mdW5jdGlvbiBzZShlKXtyZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZSlbInBhZGRpbmctcmlnaHQiXSwxMCl8fDB9ZnVuY3Rpb24gY2UoZSx0LG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpbXSxvPWFyZ3VtZW50cy5sZW5ndGg+ND9hcmd1bWVudHNbNF06dm9pZCAwLGk9W3Qsbl0uY29uY2F0KE9iamVjdChhZS5hKShyKSksYT1bIlRFTVBMQVRFIiwiU0NSSVBUIiwiU1RZTEUiXTtbXS5mb3JFYWNoLmNhbGwoZS5jaGlsZHJlbiwoZnVuY3Rpb24oZSl7MT09PWUubm9kZVR5cGUmJi0xPT09aS5pbmRleE9mKGUpJiYtMT09PWEuaW5kZXhPZihlLnRhZ05hbWUpJiZ1ZShlLG8pfSkpfWZ1bmN0aW9uIGRlKGUsdCl7dmFyIG49LTE7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24oZSxyKXtyZXR1cm4hIXQoZSkmJihuPXIsITApfSkpLG59ZnVuY3Rpb24gZmUoZSx0KXt2YXIgbixyPVtdLG89W10saT1lLmNvbnRhaW5lcjtpZighdC5kaXNhYmxlU2Nyb2xsTG9jayl7aWYoZnVuY3Rpb24oZSl7dmFyIHQ9WShlKTtyZXR1cm4gdC5ib2R5PT09ZT9YKHQpLmlubmVyV2lkdGg+dC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6ZS5zY3JvbGxIZWlnaHQ+",
                    "ZS5jbGllbnRIZWlnaHR9KGkpKXt2YXIgYT1sZSgpO3IucHVzaCh7dmFsdWU6aS5zdHlsZS5wYWRkaW5nUmlnaHQsa2V5OiJwYWRkaW5nLXJpZ2h0IixlbDppfSksaS5zdHlsZVsicGFkZGluZy1yaWdodCJdPSIiLmNvbmNhdChzZShpKSthLCJweCIpLG49WShpKS5xdWVyeVNlbGVjdG9yQWxsKCIubXVpLWZpeGVkIiksW10uZm9yRWFjaC5jYWxsKG4sKGZ1bmN0aW9uKGUpe28ucHVzaChlLnN0eWxlLnBhZGRpbmdSaWdodCksZS5zdHlsZS5wYWRkaW5nUmlnaHQ9IiIuY29uY2F0KHNlKGUpK2EsInB4Iil9KSl9dmFyIGw9aS5wYXJlbnRFbGVtZW50LHU9IkhUTUwiPT09bC5ub2RlTmFtZSYmInNjcm9sbCI9PT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsKVsib3ZlcmZsb3cteSJdP2w6aTtyLnB1c2goe3ZhbHVlOnUuc3R5bGUub3ZlcmZsb3csa2V5OiJvdmVyZmxvdyIsZWw6dX0pLHUuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiJ9cmV0dXJuIGZ1bmN0aW9uKCl7biYmW10uZm9yRWFjaC5jYWxsKG4sKGZ1bmN0aW9uKGUsdCl7b1t0XT9lLnN0eWxlLnBhZGRpbmdSaWdodD1vW3RdOmUuc3R5bGUucmVtb3ZlUHJvcGVydHkoInBhZGRpbmctcmlnaHQiKX0pKSxyLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWUsbj1lLmVsLHI9ZS5rZXk7dD9uLnN0eWxlLnNldFByb3BlcnR5KHIsdCk6bi5zdHlsZS5yZW1vdmVQcm9wZXJ0eShyKX0pKX19dmFyIHBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeyFmdW5jdGlvbihlLHQp",
                    "e2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfSh0aGlzLGUpLHRoaXMubW9kYWxzPVtdLHRoaXMuY29udGFpbmVycz1bXX1yZXR1cm4gT2JqZWN0KGllLmEpKGUsW3trZXk6ImFkZCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLm1vZGFscy5pbmRleE9mKGUpO2lmKC0xIT09bilyZXR1cm4gbjtuPXRoaXMubW9kYWxzLmxlbmd0aCx0aGlzLm1vZGFscy5wdXNoKGUpLGUubW9kYWxSZWYmJnVlKGUubW9kYWxSZWYsITEpO3ZhciByPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO3JldHVybltdLmZvckVhY2guY2FsbChlLmNoaWxkcmVuLChmdW5jdGlvbihlKXtlLmdldEF0dHJpYnV0ZSYmInRydWUiPT09ZS5nZXRBdHRyaWJ1dGUoImFyaWEtaGlkZGVuIikmJnQucHVzaChlKX0pKSx0fSh0KTtjZSh0LGUubW91bnROb2RlLGUubW9kYWxSZWYsciwhMCk7dmFyIG89ZGUodGhpcy5jb250YWluZXJzLChmdW5jdGlvbihlKXtyZXR1cm4gZS5jb250YWluZXI9PT10fSkpO3JldHVybi0xIT09bz8odGhpcy5jb250YWluZXJzW29dLm1vZGFscy5wdXNoKGUpLG4pOih0aGlzLmNvbnRhaW5lcnMucHVzaCh7bW9kYWxzOltlXSxjb250YWluZXI6dCxyZXN0b3JlOm51bGwsaGlkZGVuU2libGluZ05vZGVzOnJ9KSxuKX19LHtrZXk6Im1vdW50Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWRlKHRoaXMuY29udGFpbmVycywoZnVuY3Rpb24odCl7",
                    "cmV0dXJuLTEhPT10Lm1vZGFscy5pbmRleE9mKGUpfSkpLHI9dGhpcy5jb250YWluZXJzW25dO3IucmVzdG9yZXx8KHIucmVzdG9yZT1mZShyLHQpKX19LHtrZXk6InJlbW92ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tb2RhbHMuaW5kZXhPZihlKTtpZigtMT09PXQpcmV0dXJuIHQ7dmFyIG49ZGUodGhpcy5jb250YWluZXJzLChmdW5jdGlvbih0KXtyZXR1cm4tMSE9PXQubW9kYWxzLmluZGV4T2YoZSl9KSkscj10aGlzLmNvbnRhaW5lcnNbbl07aWYoci5tb2RhbHMuc3BsaWNlKHIubW9kYWxzLmluZGV4T2YoZSksMSksdGhpcy5tb2RhbHMuc3BsaWNlKHQsMSksMD09PXIubW9kYWxzLmxlbmd0aClyLnJlc3RvcmUmJnIucmVzdG9yZSgpLGUubW9kYWxSZWYmJnVlKGUubW9kYWxSZWYsITApLGNlKHIuY29udGFpbmVyLGUubW91bnROb2RlLGUubW9kYWxSZWYsci5oaWRkZW5TaWJsaW5nTm9kZXMsITEpLHRoaXMuY29udGFpbmVycy5zcGxpY2UobiwxKTtlbHNle3ZhciBvPXIubW9kYWxzW3IubW9kYWxzLmxlbmd0aC0xXTtvLm1vZGFsUmVmJiZ1ZShvLm1vZGFsUmVmLCExKX1yZXR1cm4gdH19LHtrZXk6ImlzVG9wTW9kYWwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm1vZGFscy5sZW5ndGg+MCYmdGhpcy5tb2RhbHNbdGhpcy5tb2RhbHMubGVuZ3RoLTFdPT09ZX19XSksZX0oKTt2YXIgaGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGlsZHJlbixuPWUuZGlzYWJsZUF1dG9Gb2N1cyxyPXZvaWQgMCE9",
                    "PW4mJm4sbz1lLmRpc2FibGVFbmZvcmNlRm9jdXMsYT12b2lkIDAhPT1vJiZvLGw9ZS5kaXNhYmxlUmVzdG9yZUZvY3VzLHU9dm9pZCAwIT09bCYmbCxzPWUuZ2V0RG9jLGM9ZS5pc0VuYWJsZWQsZD1lLm9wZW4sZj1pLnVzZVJlZigpLHA9aS51c2VSZWYobnVsbCksbT1pLnVzZVJlZihudWxsKSx2PWkudXNlUmVmKCksYj1pLnVzZVJlZihudWxsKSx5PWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe2IuY3VycmVudD1RLmZpbmRET01Ob2RlKGUpfSksW10pLGc9T2JqZWN0KGguYSkodC5yZWYseSksdz1pLnVzZVJlZigpO3JldHVybiBpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXt3LmN1cnJlbnQ9ZH0pLFtkXSksIXcuY3VycmVudCYmZCYmInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93JiYodi5jdXJyZW50PXMoKS5hY3RpdmVFbGVtZW50KSxpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtpZihkKXt2YXIgZT1ZKGIuY3VycmVudCk7cnx8IWIuY3VycmVudHx8Yi5jdXJyZW50LmNvbnRhaW5zKGUuYWN0aXZlRWxlbWVudCl8fChiLmN1cnJlbnQuaGFzQXR0cmlidXRlKCJ0YWJJbmRleCIpfHxiLmN1cnJlbnQuc2V0QXR0cmlidXRlKCJ0YWJJbmRleCIsLTEpLGIuY3VycmVudC5mb2N1cygpKTt2YXIgdD1mdW5jdGlvbigpe2UuaGFzRm9jdXMoKSYmIWEmJmMoKSYmIWYuY3VycmVudD9iLmN1cnJlbnQmJiFiLmN1cnJlbnQuY29udGFpbnMoZS5hY3RpdmVFbGVtZW50KSYmYi5jdXJyZW50LmZvY3VzKCk6Zi5jdXJyZW50PSExfSxuPWZ1",
                    "bmN0aW9uKHQpeyFhJiZjKCkmJjk9PT10LmtleUNvZGUmJmUuYWN0aXZlRWxlbWVudD09PWIuY3VycmVudCYmKGYuY3VycmVudD0hMCx0LnNoaWZ0S2V5P20uY3VycmVudC5mb2N1cygpOnAuY3VycmVudC5mb2N1cygpKX07ZS5hZGRFdmVudExpc3RlbmVyKCJmb2N1cyIsdCwhMCksZS5hZGRFdmVudExpc3RlbmVyKCJrZXlkb3duIixuLCEwKTt2YXIgbz1zZXRJbnRlcnZhbCgoZnVuY3Rpb24oKXt0KCl9KSw1MCk7cmV0dXJuIGZ1bmN0aW9uKCl7Y2xlYXJJbnRlcnZhbChvKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoImZvY3VzIix0LCEwKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoImtleWRvd24iLG4sITApLHV8fCh2LmN1cnJlbnQmJnYuY3VycmVudC5mb2N1cyYmdi5jdXJyZW50LmZvY3VzKCksdi5jdXJyZW50PW51bGwpfX19KSxbcixhLHUsYyxkXSksaS5jcmVhdGVFbGVtZW50KGkuRnJhZ21lbnQsbnVsbCxpLmNyZWF0ZUVsZW1lbnQoImRpdiIse3RhYkluZGV4OjAscmVmOnAsImRhdGEtdGVzdCI6InNlbnRpbmVsU3RhcnQifSksaS5jbG9uZUVsZW1lbnQodCx7cmVmOmd9KSxpLmNyZWF0ZUVsZW1lbnQoImRpdiIse3RhYkluZGV4OjAscmVmOm0sImRhdGEtdGVzdCI6InNlbnRpbmVsRW5kIn0pKX0sbWU9e3Jvb3Q6e3pJbmRleDotMSxwb3NpdGlvbjoiZml4ZWQiLHJpZ2h0OjAsYm90dG9tOjAsdG9wOjAsbGVmdDowLGJhY2tncm91bmRDb2xvcjoicmdiYSgwLCAwLCAwLCAwLjUpIixXZWJraXRUYXBIaWdobGlnaHRDb2xv",
                    "cjoidHJhbnNwYXJlbnQifSxpbnZpc2libGU6e2JhY2tncm91bmRDb2xvcjoidHJhbnNwYXJlbnQifX0sdmU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuaW52aXNpYmxlLGE9dm9pZCAwIT09biYmbixsPWUub3Blbix1PU9iamVjdChvLmEpKGUsWyJpbnZpc2libGUiLCJvcGVuIl0pO3JldHVybiBsP2kuY3JlYXRlRWxlbWVudCgiZGl2IixPYmplY3Qoci5hKSh7ImFyaWEtaGlkZGVuIjohMCxyZWY6dH0sdSx7c3R5bGU6T2JqZWN0KHIuYSkoe30sbWUucm9vdCxhP21lLmludmlzaWJsZTp7fSx1LnN0eWxlKX0pKTpudWxsfSkpO3ZhciBiZT1uZXcgcGUseWU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPU9iamVjdChKLmEpKCksYT1PYmplY3QoWi5hKSh7bmFtZToiTXVpTW9kYWwiLHByb3BzOk9iamVjdChyLmEpKHt9LGUpLHRoZW1lOm59KSxsPWEuQmFja2Ryb3BDb21wb25lbnQsdT12b2lkIDA9PT1sP3ZlOmwscz1hLkJhY2tkcm9wUHJvcHMsYz1hLmNoaWxkcmVuLGQ9YS5jbG9zZUFmdGVyVHJhbnNpdGlvbixmPXZvaWQgMCE9PWQmJmQscD1hLmNvbnRhaW5lcixtPWEuZGlzYWJsZUF1dG9Gb2N1cyx2PXZvaWQgMCE9PW0mJm0sYj1hLmRpc2FibGVCYWNrZHJvcENsaWNrLHk9dm9pZCAwIT09YiYmYixnPWEuZGlzYWJsZUVuZm9yY2VGb2N1cyx3PXZvaWQgMCE9PWcmJmcseD1hLmRpc2FibGVFc2NhcGVLZXlEb3duLEU9dm9pZCAwIT09eCYmeCxPPWEuZGlzYWJsZVBvcnRhbCxrPXZvaWQg",
                    "MCE9PU8mJk8sUz1hLmRpc2FibGVSZXN0b3JlRm9jdXMsQz12b2lkIDAhPT1TJiZTLGo9YS5kaXNhYmxlU2Nyb2xsTG9jayxUPXZvaWQgMCE9PWomJmosUD1hLmhpZGVCYWNrZHJvcCxSPXZvaWQgMCE9PVAmJlAsTj1hLmtlZXBNb3VudGVkLE09dm9pZCAwIT09TiYmTixfPWEubWFuYWdlcixBPXZvaWQgMD09PV8/YmU6XyxJPWEub25CYWNrZHJvcENsaWNrLEQ9YS5vbkNsb3NlLHo9YS5vbkVzY2FwZUtleURvd24sTD1hLm9uUmVuZGVyZWQsRj1hLm9wZW4sJD1PYmplY3Qoby5hKShhLFsiQmFja2Ryb3BDb21wb25lbnQiLCJCYWNrZHJvcFByb3BzIiwiY2hpbGRyZW4iLCJjbG9zZUFmdGVyVHJhbnNpdGlvbiIsImNvbnRhaW5lciIsImRpc2FibGVBdXRvRm9jdXMiLCJkaXNhYmxlQmFja2Ryb3BDbGljayIsImRpc2FibGVFbmZvcmNlRm9jdXMiLCJkaXNhYmxlRXNjYXBlS2V5RG93biIsImRpc2FibGVQb3J0YWwiLCJkaXNhYmxlUmVzdG9yZUZvY3VzIiwiZGlzYWJsZVNjcm9sbExvY2siLCJoaWRlQmFja2Ryb3AiLCJrZWVwTW91bnRlZCIsIm1hbmFnZXIiLCJvbkJhY2tkcm9wQ2xpY2siLCJvbkNsb3NlIiwib25Fc2NhcGVLZXlEb3duIiwib25SZW5kZXJlZCIsIm9wZW4iXSksVz1pLnVzZVN0YXRlKCEwKSxCPVdbMF0sSD1XWzFdLFY9aS51c2VSZWYoe30pLFU9aS51c2VSZWYobnVsbCkscT1pLnVzZVJlZihudWxsKSxLPU9iamVjdChoLmEpKHEsdCksWD1mdW5jdGlvbihlKXtyZXR1cm4hIWUuY2hpbGRyZW4mJmUuY2hpbGRy",
                    "ZW4ucHJvcHMuaGFzT3duUHJvcGVydHkoImluIil9KGEpLGVlPWZ1bmN0aW9uKCl7cmV0dXJuIFkoVS5jdXJyZW50KX0sdGU9ZnVuY3Rpb24oKXtyZXR1cm4gVi5jdXJyZW50Lm1vZGFsUmVmPXEuY3VycmVudCxWLmN1cnJlbnQubW91bnROb2RlPVUuY3VycmVudCxWLmN1cnJlbnR9LGllPWZ1bmN0aW9uKCl7QS5tb3VudCh0ZSgpLHtkaXNhYmxlU2Nyb2xsTG9jazpUfSkscS5jdXJyZW50LnNjcm9sbFRvcD0wfSxhZT1PYmplY3QocmUuYSkoKGZ1bmN0aW9uKCl7dmFyIGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ImZ1bmN0aW9uIj09PXR5cGVvZiBlP2UoKTplLFEuZmluZERPTU5vZGUoZSl9KHApfHxlZSgpLmJvZHk7QS5hZGQodGUoKSxlKSxxLmN1cnJlbnQmJmllKCl9KSksbGU9aS51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXtyZXR1cm4gQS5pc1RvcE1vZGFsKHRlKCkpfSksW0FdKSxzZT1PYmplY3QocmUuYSkoKGZ1bmN0aW9uKGUpe1UuY3VycmVudD1lLGUmJihMJiZMKCksRiYmbGUoKT9pZSgpOnVlKHEuY3VycmVudCwhMCkpfSkpLGNlPWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7QS5yZW1vdmUodGUoKSl9KSxbQV0pO2lmKGkudXNlRWZmZWN0KChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe2NlKCl9fSksW2NlXSksaS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7Rj9hZSgpOlgmJmZ8fGNlKCl9KSxbRixjZSxYLGYsYWVdKSwhTSYmIUYmJighWHx8QikpcmV0dXJuIG51bGw7dmFyIGRlPWZ1bmN0aW9uKGUpe3JldHVy",
                    "bntyb290Ontwb3NpdGlvbjoiZml4ZWQiLHpJbmRleDplLnpJbmRleC5tb2RhbCxyaWdodDowLGJvdHRvbTowLHRvcDowLGxlZnQ6MH0saGlkZGVuOnt2aXNpYmlsaXR5OiJoaWRkZW4ifX19KG58fHt6SW5kZXg6b2UuYX0pLGZlPXt9O3JldHVybiB2b2lkIDA9PT1jLnByb3BzLnRhYkluZGV4JiYoZmUudGFiSW5kZXg9Yy5wcm9wcy50YWJJbmRleHx8Ii0xIiksWCYmKGZlLm9uRW50ZXI9RygoZnVuY3Rpb24oKXtIKCExKX0pLGMucHJvcHMub25FbnRlciksZmUub25FeGl0ZWQ9RygoZnVuY3Rpb24oKXtIKCEwKSxmJiZjZSgpfSksYy5wcm9wcy5vbkV4aXRlZCkpLGkuY3JlYXRlRWxlbWVudChuZSx7cmVmOnNlLGNvbnRhaW5lcjpwLGRpc2FibGVQb3J0YWw6a30saS5jcmVhdGVFbGVtZW50KCJkaXYiLE9iamVjdChyLmEpKHtyZWY6SyxvbktleURvd246ZnVuY3Rpb24oZSl7IkVzY2FwZSI9PT1lLmtleSYmbGUoKSYmKHomJnooZSksRXx8KGUuc3RvcFByb3BhZ2F0aW9uKCksRCYmRChlLCJlc2NhcGVLZXlEb3duIikpKX0scm9sZToicHJlc2VudGF0aW9uIn0sJCx7c3R5bGU6T2JqZWN0KHIuYSkoe30sZGUucm9vdCwhRiYmQj9kZS5oaWRkZW46e30sJC5zdHlsZSl9KSxSP251bGw6aS5jcmVhdGVFbGVtZW50KHUsT2JqZWN0KHIuYSkoe29wZW46RixvbkNsaWNrOmZ1bmN0aW9uKGUpe2UudGFyZ2V0PT09ZS5jdXJyZW50VGFyZ2V0JiYoSSYmSShlKSwheSYmRCYmRChlLCJiYWNrZHJvcENsaWNrIikpfX0scykpLGkuY3JlYXRl",
                    "RWxlbWVudChoZSx7ZGlzYWJsZUVuZm9yY2VGb2N1czp3LGRpc2FibGVBdXRvRm9jdXM6dixkaXNhYmxlUmVzdG9yZUZvY3VzOkMsZ2V0RG9jOmVlLGlzRW5hYmxlZDpsZSxvcGVuOkZ9LGkuY2xvbmVFbGVtZW50KGMsZmUpKSkpfSkpLGdlPW4oNjUpLHdlPW4oMzIpO2Z1bmN0aW9uIHhlKGUpe3JldHVybiJzY2FsZSgiLmNvbmNhdChlLCIsICIpLmNvbmNhdChNYXRoLnBvdyhlLDIpLCIpIil9dmFyIEVlPXtlbnRlcmluZzp7b3BhY2l0eToxLHRyYW5zZm9ybTp4ZSgxKX0sZW50ZXJlZDp7b3BhY2l0eToxLHRyYW5zZm9ybToibm9uZSJ9fSxPZT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jaGlsZHJlbixhPWUuZGlzYWJsZVN0cmljdE1vZGVDb21wYXQsbD12b2lkIDAhPT1hJiZhLHU9ZS5pbixzPWUub25FbnRlcixjPWUub25FbnRlcmVkLGQ9ZS5vbkVudGVyaW5nLGY9ZS5vbkV4aXQscD1lLm9uRXhpdGVkLG09ZS5vbkV4aXRpbmcsdj1lLnN0eWxlLGI9ZS50aW1lb3V0LHk9dm9pZCAwPT09Yj8iYXV0byI6YixnPWUuVHJhbnNpdGlvbkNvbXBvbmVudCx3PXZvaWQgMD09PWc/Z2UuYTpnLHg9T2JqZWN0KG8uYSkoZSxbImNoaWxkcmVuIiwiZGlzYWJsZVN0cmljdE1vZGVDb21wYXQiLCJpbiIsIm9uRW50ZXIiLCJvbkVudGVyZWQiLCJvbkVudGVyaW5nIiwib25FeGl0Iiwib25FeGl0ZWQiLCJvbkV4aXRpbmciLCJzdHlsZSIsInRpbWVvdXQiLCJUcmFuc2l0aW9uQ29tcG9uZW50Il0pLEU9aS51c2VSZWYo",
                    "KSxPPWkudXNlUmVmKCksaz1PYmplY3QoUi5hKSgpLFM9ay51bnN0YWJsZV9zdHJpY3RNb2RlJiYhbCxDPWkudXNlUmVmKG51bGwpLGo9T2JqZWN0KGguYSkobi5yZWYsdCksVD1PYmplY3QoaC5hKShTP0M6dm9pZCAwLGopLFA9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYoZSl7dmFyIHI9Uz9bQy5jdXJyZW50LHRdOlt0LG5dLG89T2JqZWN0KHEuYSkociwyKSxpPW9bMF0sYT1vWzFdO3ZvaWQgMD09PWE/ZShpKTplKGksYSl9fX0sTj1QKGQpLE09UCgoZnVuY3Rpb24oZSx0KXtPYmplY3Qod2UuYikoZSk7dmFyIG4scj1PYmplY3Qod2UuYSkoe3N0eWxlOnYsdGltZW91dDp5fSx7bW9kZToiZW50ZXIifSksbz1yLmR1cmF0aW9uLGk9ci5kZWxheTsiYXV0byI9PT15PyhuPWsudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKGUuY2xpZW50SGVpZ2h0KSxPLmN1cnJlbnQ9bik6bj1vLGUuc3R5bGUudHJhbnNpdGlvbj1bay50cmFuc2l0aW9ucy5jcmVhdGUoIm9wYWNpdHkiLHtkdXJhdGlvbjpuLGRlbGF5Oml9KSxrLnRyYW5zaXRpb25zLmNyZWF0ZSgidHJhbnNmb3JtIix7ZHVyYXRpb246LjY2NipuLGRlbGF5Oml9KV0uam9pbigiLCIpLHMmJnMoZSx0KX0pKSxfPVAoYyksQT1QKG0pLEk9UCgoZnVuY3Rpb24oZSl7dmFyIHQsbj1PYmplY3Qod2UuYSkoe3N0eWxlOnYsdGltZW91dDp5fSx7bW9kZToiZXhpdCJ9KSxyPW4uZHVyYXRpb24sbz1uLmRlbGF5OyJhdXRvIj09PXk/KHQ9ay50cmFuc2l0",
                    "aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24oZS5jbGllbnRIZWlnaHQpLE8uY3VycmVudD10KTp0PXIsZS5zdHlsZS50cmFuc2l0aW9uPVtrLnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIse2R1cmF0aW9uOnQsZGVsYXk6b30pLGsudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjouNjY2KnQsZGVsYXk6b3x8LjMzMyp0fSldLmpvaW4oIiwiKSxlLnN0eWxlLm9wYWNpdHk9IjAiLGUuc3R5bGUudHJhbnNmb3JtPXhlKC43NSksZiYmZihlKX0pKSxEPVAocCk7cmV0dXJuIGkudXNlRWZmZWN0KChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe2NsZWFyVGltZW91dChFLmN1cnJlbnQpfX0pLFtdKSxpLmNyZWF0ZUVsZW1lbnQodyxPYmplY3Qoci5hKSh7YXBwZWFyOiEwLGluOnUsbm9kZVJlZjpTP0M6dm9pZCAwLG9uRW50ZXI6TSxvbkVudGVyZWQ6XyxvbkVudGVyaW5nOk4sb25FeGl0Okksb25FeGl0ZWQ6RCxvbkV4aXRpbmc6QSxhZGRFbmRMaXN0ZW5lcjpmdW5jdGlvbihlLHQpe3ZhciBuPVM/ZTp0OyJhdXRvIj09PXkmJihFLmN1cnJlbnQ9c2V0VGltZW91dChuLE8uY3VycmVudHx8MCkpfSx0aW1lb3V0OiJhdXRvIj09PXk/bnVsbDp5fSx4KSwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gaS5jbG9uZUVsZW1lbnQobixPYmplY3Qoci5hKSh7c3R5bGU6T2JqZWN0KHIuYSkoe29wYWNpdHk6MCx0cmFuc2Zvcm06eGUoLjc1KSx2aXNpYmlsaXR5OiJleGl0ZWQiIT09ZXx8dT92b2lkIDA6ImhpZGRl",
                    "biJ9LEVlW2VdLHYsbi5wcm9wcy5zdHlsZSkscmVmOlR9LHQpKX0pKX0pKTtPZS5tdWlTdXBwb3J0QXV0bz0hMDt2YXIga2U9T2UsU2U9bigxMjgpO2Z1bmN0aW9uIENlKGUsdCl7dmFyIG49MDtyZXR1cm4ibnVtYmVyIj09PXR5cGVvZiB0P249dDoiY2VudGVyIj09PXQ/bj1lLmhlaWdodC8yOiJib3R0b20iPT09dCYmKG49ZS5oZWlnaHQpLG59ZnVuY3Rpb24gamUoZSx0KXt2YXIgbj0wO3JldHVybiJudW1iZXIiPT09dHlwZW9mIHQ/bj10OiJjZW50ZXIiPT09dD9uPWUud2lkdGgvMjoicmlnaHQiPT09dCYmKG49ZS53aWR0aCksbn1mdW5jdGlvbiBUZShlKXtyZXR1cm5bZS5ob3Jpem9udGFsLGUudmVydGljYWxdLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIm51bWJlciI9PT10eXBlb2YgZT8iIi5jb25jYXQoZSwicHgiKTplfSkpLmpvaW4oIiAiKX1mdW5jdGlvbiBQZShlKXtyZXR1cm4iZnVuY3Rpb24iPT09dHlwZW9mIGU/ZSgpOmV9dmFyIFJlPWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmFjdGlvbixhPWUuYW5jaG9yRWwsdT1lLmFuY2hvck9yaWdpbixzPXZvaWQgMD09PXU/e3ZlcnRpY2FsOiJ0b3AiLGhvcml6b250YWw6ImxlZnQifTp1LGM9ZS5hbmNob3JQb3NpdGlvbixkPWUuYW5jaG9yUmVmZXJlbmNlLGY9dm9pZCAwPT09ZD8iYW5jaG9yRWwiOmQscD1lLmNoaWxkcmVuLGg9ZS5jbGFzc2VzLHY9ZS5jbGFzc05hbWUsYj1lLmNvbnRhaW5lcix5PWUuZWxldmF0aW9uLGc9dm9pZCAwPT09eT84",
                    "Onksdz1lLmdldENvbnRlbnRBbmNob3JFbCx4PWUubWFyZ2luVGhyZXNob2xkLEU9dm9pZCAwPT09eD8xNjp4LE89ZS5vbkVudGVyLGs9ZS5vbkVudGVyZWQsUz1lLm9uRW50ZXJpbmcsQz1lLm9uRXhpdCxqPWUub25FeGl0ZWQsVD1lLm9uRXhpdGluZyxQPWUub3BlbixSPWUuUGFwZXJQcm9wcyxOPXZvaWQgMD09PVI/e306UixNPWUudHJhbnNmb3JtT3JpZ2luLF89dm9pZCAwPT09TT97dmVydGljYWw6InRvcCIsaG9yaXpvbnRhbDoibGVmdCJ9Ok0sQT1lLlRyYW5zaXRpb25Db21wb25lbnQsST12b2lkIDA9PT1BP2tlOkEsRD1lLnRyYW5zaXRpb25EdXJhdGlvbix6PXZvaWQgMD09PUQ/ImF1dG8iOkQsTD1lLlRyYW5zaXRpb25Qcm9wcyxGPXZvaWQgMD09PUw/e306TCwkPU9iamVjdChvLmEpKGUsWyJhY3Rpb24iLCJhbmNob3JFbCIsImFuY2hvck9yaWdpbiIsImFuY2hvclBvc2l0aW9uIiwiYW5jaG9yUmVmZXJlbmNlIiwiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiZWxldmF0aW9uIiwiZ2V0Q29udGVudEFuY2hvckVsIiwibWFyZ2luVGhyZXNob2xkIiwib25FbnRlciIsIm9uRW50ZXJlZCIsIm9uRW50ZXJpbmciLCJvbkV4aXQiLCJvbkV4aXRlZCIsIm9uRXhpdGluZyIsIm9wZW4iLCJQYXBlclByb3BzIiwidHJhbnNmb3JtT3JpZ2luIiwiVHJhbnNpdGlvbkNvbXBvbmVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsIlRyYW5zaXRpb25Qcm9wcyJdKSxXPWkudXNlUmVmKCksQj1pLnVz",
                    "ZUNhbGxiYWNrKChmdW5jdGlvbihlKXtpZigiYW5jaG9yUG9zaXRpb24iPT09ZilyZXR1cm4gYzt2YXIgdD1QZShhKSxuPSh0JiYxPT09dC5ub2RlVHlwZT90OlkoVy5jdXJyZW50KS5ib2R5KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxyPTA9PT1lP3MudmVydGljYWw6ImNlbnRlciI7cmV0dXJue3RvcDpuLnRvcCtDZShuLHIpLGxlZnQ6bi5sZWZ0K2plKG4scy5ob3Jpem9udGFsKX19KSxbYSxzLmhvcml6b250YWwscy52ZXJ0aWNhbCxjLGZdKSxIPWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe3ZhciB0PTA7aWYodyYmImFuY2hvckVsIj09PWYpe3ZhciBuPXcoZSk7aWYobiYmZS5jb250YWlucyhuKSl7dmFyIHI9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dCxyPTA7biYmbiE9PWU7KXIrPShuPW4ucGFyZW50RWxlbWVudCkuc2Nyb2xsVG9wO3JldHVybiByfShlLG4pO3Q9bi5vZmZzZXRUb3Arbi5jbGllbnRIZWlnaHQvMi1yfHwwfTB9cmV0dXJuIHR9KSxbcy52ZXJ0aWNhbCxmLHddKSxWPWkudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3JldHVybnt2ZXJ0aWNhbDpDZShlLF8udmVydGljYWwpK3QsaG9yaXpvbnRhbDpqZShlLF8uaG9yaXpvbnRhbCl9fSksW18uaG9yaXpvbnRhbCxfLnZlcnRpY2FsXSksVT1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXt2YXIgdD1IKGUpLG49e3dpZHRoOmUub2Zmc2V0",
                    "V2lkdGgsaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0fSxyPVYobix0KTtpZigibm9uZSI9PT1mKXJldHVybnt0b3A6bnVsbCxsZWZ0Om51bGwsdHJhbnNmb3JtT3JpZ2luOlRlKHIpfTt2YXIgbz1CKHQpLGk9by50b3Atci52ZXJ0aWNhbCxsPW8ubGVmdC1yLmhvcml6b250YWwsdT1pK24uaGVpZ2h0LHM9bCtuLndpZHRoLGM9WChQZShhKSksZD1jLmlubmVySGVpZ2h0LUUscD1jLmlubmVyV2lkdGgtRTtpZihpPEUpe3ZhciBoPWktRTtpLT1oLHIudmVydGljYWwrPWh9ZWxzZSBpZih1PmQpe3ZhciBtPXUtZDtpLT1tLHIudmVydGljYWwrPW19aWYobDxFKXt2YXIgdj1sLUU7bC09dixyLmhvcml6b250YWwrPXZ9ZWxzZSBpZihzPnApe3ZhciBiPXMtcDtsLT1iLHIuaG9yaXpvbnRhbCs9Yn1yZXR1cm57dG9wOiIiLmNvbmNhdChNYXRoLnJvdW5kKGkpLCJweCIpLGxlZnQ6IiIuY29uY2F0KE1hdGgucm91bmQobCksInB4IiksdHJhbnNmb3JtT3JpZ2luOlRlKHIpfX0pLFthLGYsQixILFYsRV0pLHE9aS51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXt2YXIgZT1XLmN1cnJlbnQ7aWYoZSl7dmFyIHQ9VShlKTtudWxsIT09dC50b3AmJihlLnN0eWxlLnRvcD10LnRvcCksbnVsbCE9PXQubGVmdCYmKGUuc3R5bGUubGVmdD10LmxlZnQpLGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luPXQudHJhbnNmb3JtT3JpZ2lufX0pLFtVXSksSz1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtXLmN1cnJlbnQ9US5maW5kRE9NTm9kZShlKX0pLFtdKTtpLnVz",
                    "ZUVmZmVjdCgoZnVuY3Rpb24oKXtQJiZxKCl9KSksaS51c2VJbXBlcmF0aXZlSGFuZGxlKG4sKGZ1bmN0aW9uKCl7cmV0dXJuIFA/e3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7cSgpfX06bnVsbH0pLFtQLHFdKSxpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtpZihQKXt2YXIgZT1tKChmdW5jdGlvbigpe3EoKX0pKTtyZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsZSksZnVuY3Rpb24oKXtlLmNsZWFyKCksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsZSl9fX0pLFtQLHFdKTt2YXIgSj16OyJhdXRvIiE9PXp8fEkubXVpU3VwcG9ydEF1dG98fChKPXZvaWQgMCk7dmFyIFo9Ynx8KGE/WShQZShhKSkuYm9keTp2b2lkIDApO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoeWUsT2JqZWN0KHIuYSkoe2NvbnRhaW5lcjpaLG9wZW46UCxyZWY6dCxCYWNrZHJvcFByb3BzOntpbnZpc2libGU6ITB9LGNsYXNzTmFtZTpPYmplY3QobC5hKShoLnJvb3Qsdil9LCQpLGkuY3JlYXRlRWxlbWVudChJLE9iamVjdChyLmEpKHthcHBlYXI6ITAsaW46UCxvbkVudGVyOk8sb25FbnRlcmVkOmssb25FeGl0OkMsb25FeGl0ZWQ6aixvbkV4aXRpbmc6VCx0aW1lb3V0Okp9LEYse29uRW50ZXJpbmc6RygoZnVuY3Rpb24oZSx0KXtTJiZTKGUsdCkscSgpfSksRi5vbkVudGVyaW5nKX0pLGkuY3JlYXRlRWxlbWVudChTZS5hLE9iamVjdChyLmEpKHtlbGV2YXRpb246ZyxyZWY6S30sTix7Y2xhc3NOYW1lOk9iamVj",
                    "dChsLmEpKGgucGFwZXIsTi5jbGFzc05hbWUpfSkscCkpKX0pKSxOZT1PYmplY3QoZi5hKSh7cm9vdDp7fSxwYXBlcjp7cG9zaXRpb246ImFic29sdXRlIixvdmVyZmxvd1k6ImF1dG8iLG92ZXJmbG93WDoiaGlkZGVuIixtaW5XaWR0aDoxNixtaW5IZWlnaHQ6MTYsbWF4V2lkdGg6ImNhbGMoMTAwJSAtIDMycHgpIixtYXhIZWlnaHQ6ImNhbGMoMTAwJSAtIDMycHgpIixvdXRsaW5lOjB9fSx7bmFtZToiTXVpUG9wb3ZlciJ9KShSZSk7dmFyIE1lPWkuY3JlYXRlQ29udGV4dCh7fSksX2U9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2hpbGRyZW4sYT1lLmNsYXNzZXMsdT1lLmNsYXNzTmFtZSxzPWUuY29tcG9uZW50LGM9dm9pZCAwPT09cz8idWwiOnMsZD1lLmRlbnNlLGY9dm9pZCAwIT09ZCYmZCxwPWUuZGlzYWJsZVBhZGRpbmcsaD12b2lkIDAhPT1wJiZwLG09ZS5zdWJoZWFkZXIsdj1PYmplY3Qoby5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiY29tcG9uZW50IiwiZGVuc2UiLCJkaXNhYmxlUGFkZGluZyIsInN1YmhlYWRlciJdKSxiPWkudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm57ZGVuc2U6Zn19KSxbZl0pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoTWUuUHJvdmlkZXIse3ZhbHVlOmJ9LGkuY3JlYXRlRWxlbWVudChjLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGwuYSkoYS5yb290LHUsZiYmYS5kZW5zZSwhaCYmYS5wYWRkaW5nLG0mJmEuc3ViaGVhZGVy",
                    "KSxyZWY6dH0sdiksbSxuKSl9KSksQWU9T2JqZWN0KGYuYSkoe3Jvb3Q6e2xpc3RTdHlsZToibm9uZSIsbWFyZ2luOjAscGFkZGluZzowLHBvc2l0aW9uOiJyZWxhdGl2ZSJ9LHBhZGRpbmc6e3BhZGRpbmdUb3A6OCxwYWRkaW5nQm90dG9tOjh9LGRlbnNlOnt9LHN1YmhlYWRlcjp7cGFkZGluZ1RvcDowfX0se25hbWU6Ik11aUxpc3QifSkoX2UpO2Z1bmN0aW9uIEllKGUsdCxuKXtyZXR1cm4gZT09PXQ/ZS5maXJzdENoaWxkOnQmJnQubmV4dEVsZW1lbnRTaWJsaW5nP3QubmV4dEVsZW1lbnRTaWJsaW5nOm4/bnVsbDplLmZpcnN0Q2hpbGR9ZnVuY3Rpb24gRGUoZSx0LG4pe3JldHVybiBlPT09dD9uP2UuZmlyc3RDaGlsZDplLmxhc3RDaGlsZDp0JiZ0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc/dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOm4/bnVsbDplLmxhc3RDaGlsZH1mdW5jdGlvbiB6ZShlLHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuITA7dmFyIG49ZS5pbm5lclRleHQ7cmV0dXJuIHZvaWQgMD09PW4mJihuPWUudGV4dENvbnRlbnQpLDAhPT0obj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpKS5sZW5ndGgmJih0LnJlcGVhdGluZz9uWzBdPT09dC5rZXlzWzBdOjA9PT1uLmluZGV4T2YodC5rZXlzLmpvaW4oIiIpKSl9ZnVuY3Rpb24gTGUoZSx0LG4scixvLGkpe2Zvcih2YXIgYT0hMSxsPW8oZSx0LCEhdCYmbik7bDspe2lmKGw9PT1lLmZpcnN0Q2hpbGQpe2lmKGEpcmV0dXJuO2E9ITB9dmFyIHU9IXImJihsLmRpc2FibGVk",
                    "fHwidHJ1ZSI9PT1sLmdldEF0dHJpYnV0ZSgiYXJpYS1kaXNhYmxlZCIpKTtpZihsLmhhc0F0dHJpYnV0ZSgidGFiaW5kZXgiKSYmemUobCxpKSYmIXUpcmV0dXJuIHZvaWQgbC5mb2N1cygpO2w9byhlLGwsbil9fXZhciBGZT0idW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3c/aS51c2VFZmZlY3Q6aS51c2VMYXlvdXRFZmZlY3QsJGU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuYWN0aW9ucyxhPWUuYXV0b0ZvY3VzLGw9dm9pZCAwIT09YSYmYSx1PWUuYXV0b0ZvY3VzSXRlbSxzPXZvaWQgMCE9PXUmJnUsYz1lLmNoaWxkcmVuLGQ9ZS5jbGFzc05hbWUsZj1lLmRpc2FibGVkSXRlbXNGb2N1c2FibGUscD12b2lkIDAhPT1mJiZmLG09ZS5kaXNhYmxlTGlzdFdyYXAsdj12b2lkIDAhPT1tJiZtLGI9ZS5vbktleURvd24seT1lLnZhcmlhbnQsZz12b2lkIDA9PT15PyJzZWxlY3RlZE1lbnUiOnksdz1PYmplY3Qoby5hKShlLFsiYWN0aW9ucyIsImF1dG9Gb2N1cyIsImF1dG9Gb2N1c0l0ZW0iLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImRpc2FibGVkSXRlbXNGb2N1c2FibGUiLCJkaXNhYmxlTGlzdFdyYXAiLCJvbktleURvd24iLCJ2YXJpYW50Il0pLHg9aS51c2VSZWYobnVsbCksRT1pLnVzZVJlZih7a2V5czpbXSxyZXBlYXRpbmc6ITAscHJldmlvdXNLZXlNYXRjaGVkOiEwLGxhc3RUaW1lOm51bGx9KTtGZSgoZnVuY3Rpb24oKXtsJiZ4LmN1cnJlbnQuZm9jdXMoKX0pLFtsXSksaS51c2VJbXBlcmF0aXZl",
                    "SGFuZGxlKG4sKGZ1bmN0aW9uKCl7cmV0dXJue2FkanVzdFN0eWxlRm9yU2Nyb2xsYmFyOmZ1bmN0aW9uKGUsdCl7dmFyIG49IXguY3VycmVudC5zdHlsZS53aWR0aDtpZihlLmNsaWVudEhlaWdodDx4LmN1cnJlbnQuY2xpZW50SGVpZ2h0JiZuKXt2YXIgcj0iIi5jb25jYXQobGUoKSwicHgiKTt4LmN1cnJlbnQuc3R5bGVbInJ0bCI9PT10LmRpcmVjdGlvbj8icGFkZGluZ0xlZnQiOiJwYWRkaW5nUmlnaHQiXT1yLHguY3VycmVudC5zdHlsZS53aWR0aD0iY2FsYygxMDAlICsgIi5jb25jYXQociwiKSIpfXJldHVybiB4LmN1cnJlbnR9fX0pLFtdKTt2YXIgTz1pLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXt4LmN1cnJlbnQ9US5maW5kRE9NTm9kZShlKX0pLFtdKSxrPU9iamVjdChoLmEpKE8sdCksUz0tMTtpLkNoaWxkcmVuLmZvckVhY2goYywoZnVuY3Rpb24oZSx0KXtpLmlzVmFsaWRFbGVtZW50KGUpJiYoZS5wcm9wcy5kaXNhYmxlZHx8KCJzZWxlY3RlZE1lbnUiPT09ZyYmZS5wcm9wcy5zZWxlY3RlZHx8LTE9PT1TKSYmKFM9dCkpfSkpO3ZhciBDPWkuQ2hpbGRyZW4ubWFwKGMsKGZ1bmN0aW9uKGUsdCl7aWYodD09PVMpe3ZhciBuPXt9O3JldHVybiBzJiYobi5hdXRvRm9jdXM9ITApLHZvaWQgMD09PWUucHJvcHMudGFiSW5kZXgmJiJzZWxlY3RlZE1lbnUiPT09ZyYmKG4udGFiSW5kZXg9MCksaS5jbG9uZUVsZW1lbnQoZSxuKX1yZXR1cm4gZX0pKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KEFlLE9iamVjdChyLmEp",
                    "KHtyb2xlOiJtZW51IixyZWY6ayxjbGFzc05hbWU6ZCxvbktleURvd246ZnVuY3Rpb24oZSl7dmFyIHQ9eC5jdXJyZW50LG49ZS5rZXkscj1ZKHQpLmFjdGl2ZUVsZW1lbnQ7aWYoIkFycm93RG93biI9PT1uKWUucHJldmVudERlZmF1bHQoKSxMZSh0LHIsdixwLEllKTtlbHNlIGlmKCJBcnJvd1VwIj09PW4pZS5wcmV2ZW50RGVmYXVsdCgpLExlKHQscix2LHAsRGUpO2Vsc2UgaWYoIkhvbWUiPT09billLnByZXZlbnREZWZhdWx0KCksTGUodCxudWxsLHYscCxJZSk7ZWxzZSBpZigiRW5kIj09PW4pZS5wcmV2ZW50RGVmYXVsdCgpLExlKHQsbnVsbCx2LHAsRGUpO2Vsc2UgaWYoMT09PW4ubGVuZ3RoKXt2YXIgbz1FLmN1cnJlbnQsaT1uLnRvTG93ZXJDYXNlKCksYT1wZXJmb3JtYW5jZS5ub3coKTtvLmtleXMubGVuZ3RoPjAmJihhLW8ubGFzdFRpbWU+NTAwPyhvLmtleXM9W10sby5yZXBlYXRpbmc9ITAsby5wcmV2aW91c0tleU1hdGNoZWQ9ITApOm8ucmVwZWF0aW5nJiZpIT09by5rZXlzWzBdJiYoby5yZXBlYXRpbmc9ITEpKSxvLmxhc3RUaW1lPWEsby5rZXlzLnB1c2goaSk7dmFyIGw9ciYmIW8ucmVwZWF0aW5nJiZ6ZShyLG8pO28ucHJldmlvdXNLZXlNYXRjaGVkJiYobHx8TGUodCxyLCExLHAsSWUsbykpP2UucHJldmVudERlZmF1bHQoKTpvLnByZXZpb3VzS2V5TWF0Y2hlZD0hMX1iJiZiKGUpfSx0YWJJbmRleDpsPzA6LTF9LHcpLEMpfSkpLFdlPXt2ZXJ0aWNhbDoidG9wIixob3Jpem9udGFsOiJyaWdodCJ9LEJl",
                    "PXt2ZXJ0aWNhbDoidG9wIixob3Jpem9udGFsOiJsZWZ0In0sSGU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuYXV0b0ZvY3VzLGE9dm9pZCAwPT09bnx8bix1PWUuY2hpbGRyZW4scz1lLmNsYXNzZXMsYz1lLmRpc2FibGVBdXRvRm9jdXNJdGVtLGQ9dm9pZCAwIT09YyYmYyxmPWUuTWVudUxpc3RQcm9wcyxwPXZvaWQgMD09PWY/e306ZixoPWUub25DbG9zZSxtPWUub25FbnRlcmluZyx2PWUub3BlbixiPWUuUGFwZXJQcm9wcyx5PXZvaWQgMD09PWI/e306YixnPWUuUG9wb3ZlckNsYXNzZXMsdz1lLnRyYW5zaXRpb25EdXJhdGlvbix4PXZvaWQgMD09PXc/ImF1dG8iOncsRT1lLnZhcmlhbnQsTz12b2lkIDA9PT1FPyJzZWxlY3RlZE1lbnUiOkUsaz1PYmplY3Qoby5hKShlLFsiYXV0b0ZvY3VzIiwiY2hpbGRyZW4iLCJjbGFzc2VzIiwiZGlzYWJsZUF1dG9Gb2N1c0l0ZW0iLCJNZW51TGlzdFByb3BzIiwib25DbG9zZSIsIm9uRW50ZXJpbmciLCJvcGVuIiwiUGFwZXJQcm9wcyIsIlBvcG92ZXJDbGFzc2VzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidmFyaWFudCJdKSxTPU9iamVjdChSLmEpKCksQz1hJiYhZCYmdixqPWkudXNlUmVmKG51bGwpLFQ9aS51c2VSZWYobnVsbCksUD0tMTtpLkNoaWxkcmVuLm1hcCh1LChmdW5jdGlvbihlLHQpe2kuaXNWYWxpZEVsZW1lbnQoZSkmJihlLnByb3BzLmRpc2FibGVkfHwoIm1lbnUiIT09TyYmZS5wcm9wcy5zZWxlY3RlZHx8LTE9PT1QKSYmKFA9dCkpfSkpO3Zh",
                    "ciBOPWkuQ2hpbGRyZW4ubWFwKHUsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9PT1QP2kuY2xvbmVFbGVtZW50KGUse3JlZjpmdW5jdGlvbih0KXtULmN1cnJlbnQ9US5maW5kRE9NTm9kZSh0KSxPYmplY3QoZWUuYSkoZS5yZWYsdCl9fSk6ZX0pKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KE5lLE9iamVjdChyLmEpKHtnZXRDb250ZW50QW5jaG9yRWw6ZnVuY3Rpb24oKXtyZXR1cm4gVC5jdXJyZW50fSxjbGFzc2VzOmcsb25DbG9zZTpoLG9uRW50ZXJpbmc6ZnVuY3Rpb24oZSx0KXtqLmN1cnJlbnQmJmouY3VycmVudC5hZGp1c3RTdHlsZUZvclNjcm9sbGJhcihlLFMpLG0mJm0oZSx0KX0sYW5jaG9yT3JpZ2luOiJydGwiPT09Uy5kaXJlY3Rpb24/V2U6QmUsdHJhbnNmb3JtT3JpZ2luOiJydGwiPT09Uy5kaXJlY3Rpb24/V2U6QmUsUGFwZXJQcm9wczpPYmplY3Qoci5hKSh7fSx5LHtjbGFzc2VzOk9iamVjdChyLmEpKHt9LHkuY2xhc3Nlcyx7cm9vdDpzLnBhcGVyfSl9KSxvcGVuOnYscmVmOnQsdHJhbnNpdGlvbkR1cmF0aW9uOnh9LGspLGkuY3JlYXRlRWxlbWVudCgkZSxPYmplY3Qoci5hKSh7b25LZXlEb3duOmZ1bmN0aW9uKGUpeyJUYWIiPT09ZS5rZXkmJihlLnByZXZlbnREZWZhdWx0KCksaCYmaChlLCJ0YWJLZXlEb3duIikpfSxhY3Rpb25zOmosYXV0b0ZvY3VzOmEmJigtMT09PVB8fGQpLGF1dG9Gb2N1c0l0ZW06Qyx2YXJpYW50Ok99LHAse2NsYXNzTmFtZTpPYmplY3QobC5hKShzLmxpc3QscC5jbGFzc05hbWUp",
                    "fSksTikpfSkpLFZlPU9iamVjdChmLmEpKHtwYXBlcjp7bWF4SGVpZ2h0OiJjYWxjKDEwMCUgLSA5NnB4KSIsV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6InRvdWNoIn0sbGlzdDp7b3V0bGluZTowfX0se25hbWU6Ik11aU1lbnUifSkoSGUpLFVlPW4oNDUpO2Z1bmN0aW9uIHFlKGUsdCl7cmV0dXJuIm9iamVjdCI9PT1PYmplY3QoSy5hKSh0KSYmbnVsbCE9PXQ/ZT09PXQ6U3RyaW5nKGUpPT09U3RyaW5nKHQpfXZhciBLZT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZVsiYXJpYS1sYWJlbCJdLGE9ZS5hdXRvRm9jdXMscz1lLmF1dG9XaWR0aCxjPWUuY2hpbGRyZW4sZD1lLmNsYXNzZXMsZj1lLmNsYXNzTmFtZSxtPWUuZGVmYXVsdFZhbHVlLHY9ZS5kaXNhYmxlZCxiPWUuZGlzcGxheUVtcHR5LHk9ZS5JY29uQ29tcG9uZW50LGc9ZS5pbnB1dFJlZix3PWUubGFiZWxJZCxFPWUuTWVudVByb3BzLE89dm9pZCAwPT09RT97fTpFLGs9ZS5tdWx0aXBsZSxTPWUubmFtZSxDPWUub25CbHVyLGo9ZS5vbkNoYW5nZSxUPWUub25DbG9zZSxQPWUub25Gb2N1cyxSPWUub25PcGVuLE49ZS5vcGVuLE09ZS5yZWFkT25seSxfPWUucmVuZGVyVmFsdWUsQT1lLlNlbGVjdERpc3BsYXlQcm9wcyxJPXZvaWQgMD09PUE/e306QSxEPWUudGFiSW5kZXgsej0oZS50eXBlLGUudmFsdWUpLEw9ZS52YXJpYW50LEY9dm9pZCAwPT09TD8ic3RhbmRhcmQiOkwsJD1PYmplY3Qoby5hKShlLFsiYXJpYS1sYWJlbCIsImF1dG9Gb2N1cyIs",
                    "ImF1dG9XaWR0aCIsImNoaWxkcmVuIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImRlZmF1bHRWYWx1ZSIsImRpc2FibGVkIiwiZGlzcGxheUVtcHR5IiwiSWNvbkNvbXBvbmVudCIsImlucHV0UmVmIiwibGFiZWxJZCIsIk1lbnVQcm9wcyIsIm11bHRpcGxlIiwibmFtZSIsIm9uQmx1ciIsIm9uQ2hhbmdlIiwib25DbG9zZSIsIm9uRm9jdXMiLCJvbk9wZW4iLCJvcGVuIiwicmVhZE9ubHkiLCJyZW5kZXJWYWx1ZSIsIlNlbGVjdERpc3BsYXlQcm9wcyIsInRhYkluZGV4IiwidHlwZSIsInZhbHVlIiwidmFyaWFudCJdKSxXPU9iamVjdChVZS5hKSh7Y29udHJvbGxlZDp6LGRlZmF1bHQ6bSxuYW1lOiJTZWxlY3QifSksQj1PYmplY3QocS5hKShXLDIpLEg9QlswXSxWPUJbMV0sVT1pLnVzZVJlZihudWxsKSxLPWkudXNlU3RhdGUobnVsbCksUT1LWzBdLFg9S1sxXSxHPWkudXNlUmVmKG51bGwhPU4pLmN1cnJlbnQsSj1pLnVzZVN0YXRlKCksWj1KWzBdLGVlPUpbMV0sdGU9aS51c2VTdGF0ZSghMSksbmU9dGVbMF0scmU9dGVbMV0sb2U9T2JqZWN0KGguYSkodCxnKTtpLnVzZUltcGVyYXRpdmVIYW5kbGUob2UsKGZ1bmN0aW9uKCl7cmV0dXJue2ZvY3VzOmZ1bmN0aW9uKCl7US5mb2N1cygpfSxub2RlOlUuY3VycmVudCx2YWx1ZTpIfX0pLFtRLEhdKSxpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXthJiZRJiZRLmZvY3VzKCl9KSxbYSxRXSksaS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYoUSl7dmFyIGU9WShRKS5nZXRFbGVtZW50",
                    "QnlJZCh3KTtpZihlKXt2YXIgdD1mdW5jdGlvbigpe2dldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkJiZRLmZvY3VzKCl9O3JldHVybiBlLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIix0KSxmdW5jdGlvbigpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigiY2xpY2siLHQpfX19fSksW3csUV0pO3ZhciBpZSxhZSxsZT1mdW5jdGlvbihlLHQpe2U/UiYmUih0KTpUJiZUKHQpLEd8fChlZShzP251bGw6US5jbGllbnRXaWR0aCkscmUoZSkpfSx1ZT1pLkNoaWxkcmVuLnRvQXJyYXkoYyksc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuO2lmKGt8fGxlKCExLHQpLGspe249QXJyYXkuaXNBcnJheShIKT9ILnNsaWNlKCk6W107dmFyIHI9SC5pbmRleE9mKGUucHJvcHMudmFsdWUpOy0xPT09cj9uLnB1c2goZS5wcm9wcy52YWx1ZSk6bi5zcGxpY2UociwxKX1lbHNlIG49ZS5wcm9wcy52YWx1ZTtlLnByb3BzLm9uQ2xpY2smJmUucHJvcHMub25DbGljayh0KSxIIT09biYmKFYobiksaiYmKHQucGVyc2lzdCgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJ0YXJnZXQiLHt3cml0YWJsZTohMCx2YWx1ZTp7dmFsdWU6bixuYW1lOlN9fSksaih0LGUpKSl9fSxjZT1udWxsIT09USYmKEc/TjpuZSk7ZGVsZXRlICRbImFyaWEtaW52YWxpZCJdO3ZhciBkZT1bXSxmZT0hMTsoeCh7dmFsdWU6SH0pfHxiKSYmKF8/aWU9XyhIKTpmZT0hMCk7dmFyIHBlPXVlLm1hcCgoZnVuY3Rpb24oZSl7aWYoIWkuaXNWYWxpZEVsZW1lbnQo",
                    "ZSkpcmV0dXJuIG51bGw7dmFyIHQ7aWYoayl7aWYoIUFycmF5LmlzQXJyYXkoSCkpdGhyb3cgbmV3IEVycm9yKE9iamVjdCh1LmEpKDIpKTsodD1ILnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBxZSh0LGUucHJvcHMudmFsdWUpfSkpKSYmZmUmJmRlLnB1c2goZS5wcm9wcy5jaGlsZHJlbil9ZWxzZSh0PXFlKEgsZS5wcm9wcy52YWx1ZSkpJiZmZSYmKGFlPWUucHJvcHMuY2hpbGRyZW4pO3JldHVybiB0JiYhMCxpLmNsb25lRWxlbWVudChlLHsiYXJpYS1zZWxlY3RlZCI6dD8idHJ1ZSI6dm9pZCAwLG9uQ2xpY2s6c2UoZSksb25LZXlVcDpmdW5jdGlvbih0KXsiICI9PT10LmtleSYmdC5wcmV2ZW50RGVmYXVsdCgpLGUucHJvcHMub25LZXlVcCYmZS5wcm9wcy5vbktleVVwKHQpfSxyb2xlOiJvcHRpb24iLHNlbGVjdGVkOnQsdmFsdWU6dm9pZCAwLCJkYXRhLXZhbHVlIjplLnByb3BzLnZhbHVlfSl9KSk7ZmUmJihpZT1rP2RlLmpvaW4oIiwgIik6YWUpO3ZhciBoZSxtZT1aOyFzJiZHJiZRJiYobWU9US5jbGllbnRXaWR0aCksaGU9InVuZGVmaW5lZCIhPT10eXBlb2YgRD9EOnY/bnVsbDowO3ZhciB2ZT1JLmlkfHwoUz8ibXVpLWNvbXBvbmVudC1zZWxlY3QtIi5jb25jYXQoUyk6dm9pZCAwKTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KGkuRnJhZ21lbnQsbnVsbCxpLmNyZWF0ZUVsZW1lbnQoImRpdiIsT2JqZWN0KHIuYSkoe2NsYXNzTmFtZTpPYmplY3QobC5hKShkLnJvb3QsZC5zZWxlY3QsZC5zZWxlY3RNZW51LGRbRl0s",
                    "Zix2JiZkLmRpc2FibGVkKSxyZWY6WCx0YWJJbmRleDpoZSxyb2xlOiJidXR0b24iLCJhcmlhLWRpc2FibGVkIjp2PyJ0cnVlIjp2b2lkIDAsImFyaWEtZXhwYW5kZWQiOmNlPyJ0cnVlIjp2b2lkIDAsImFyaWEtaGFzcG9wdXAiOiJsaXN0Ym94IiwiYXJpYS1sYWJlbCI6biwiYXJpYS1sYWJlbGxlZGJ5Ijpbdyx2ZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oIiAiKXx8dm9pZCAwLG9uS2V5RG93bjpmdW5jdGlvbihlKXtpZighTSl7LTEhPT1bIiAiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiRW50ZXIiXS5pbmRleE9mKGUua2V5KSYmKGUucHJldmVudERlZmF1bHQoKSxsZSghMCxlKSl9fSxvbk1vdXNlRG93bjp2fHxNP251bGw6ZnVuY3Rpb24oZSl7MD09PWUuYnV0dG9uJiYoZS5wcmV2ZW50RGVmYXVsdCgpLFEuZm9jdXMoKSxsZSghMCxlKSl9LG9uQmx1cjpmdW5jdGlvbihlKXshY2UmJkMmJihlLnBlcnNpc3QoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwidGFyZ2V0Iix7d3JpdGFibGU6ITAsdmFsdWU6e3ZhbHVlOkgsbmFtZTpTfX0pLEMoZSkpfSxvbkZvY3VzOlB9LEkse2lkOnZlfSksZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWV8fCJzdHJpbmciPT09dHlwZW9mIGUmJiFlLnRyaW0oKX0oaWUpP2kuY3JlYXRlRWxlbWVudCgic3BhbiIse2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MOntfX2h0bWw6IiYjODIwMzsifX0pOmllKSxpLmNyZWF0ZUVsZW1lbnQoImlucHV0IixPYmplY3Qoci5hKSh7dmFsdWU6QXJyYXkuaXNB",
                    "cnJheShIKT9ILmpvaW4oIiwiKTpILG5hbWU6UyxyZWY6VSwiYXJpYS1oaWRkZW4iOiEwLG9uQ2hhbmdlOmZ1bmN0aW9uKGUpe3ZhciB0PXVlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJvcHMudmFsdWV9KSkuaW5kZXhPZihlLnRhcmdldC52YWx1ZSk7aWYoLTEhPT10KXt2YXIgbj11ZVt0XTtWKG4ucHJvcHMudmFsdWUpLGomJmooZSxuKX19LHRhYkluZGV4Oi0xLGNsYXNzTmFtZTpkLm5hdGl2ZUlucHV0LGF1dG9Gb2N1czphfSwkKSksaS5jcmVhdGVFbGVtZW50KHkse2NsYXNzTmFtZTpPYmplY3QobC5hKShkLmljb24sZFsiaWNvbiIuY29uY2F0KE9iamVjdChwLmEpKEYpKV0sY2UmJmQuaWNvbk9wZW4sdiYmZC5kaXNhYmxlZCl9KSxpLmNyZWF0ZUVsZW1lbnQoVmUsT2JqZWN0KHIuYSkoe2lkOiJtZW51LSIuY29uY2F0KFN8fCIiKSxhbmNob3JFbDpRLG9wZW46Y2Usb25DbG9zZTpmdW5jdGlvbihlKXtsZSghMSxlKX19LE8se01lbnVMaXN0UHJvcHM6T2JqZWN0KHIuYSkoeyJhcmlhLWxhYmVsbGVkYnkiOncscm9sZToibGlzdGJveCIsZGlzYWJsZUxpc3RXcmFwOiEwfSxPLk1lbnVMaXN0UHJvcHMpLFBhcGVyUHJvcHM6T2JqZWN0KHIuYSkoe30sTy5QYXBlclByb3BzLHtzdHlsZTpPYmplY3Qoci5hKSh7bWluV2lkdGg6bWV9LG51bGwhPU8uUGFwZXJQcm9wcz9PLlBhcGVyUHJvcHMuc3R5bGU6bnVsbCl9KX0pLHBlKSl9KSksWWU9big2Nyk7dmFyIFFlPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZnVuY3Rpb24odCxu",
                    "KXtyZXR1cm4gYS5hLmNyZWF0ZUVsZW1lbnQoWWUuYSxPYmplY3Qoci5hKSh7cmVmOm59LHQpLGUpfTtyZXR1cm4gbi5tdWlOYW1lPVllLmEubXVpTmFtZSxhLmEubWVtbyhhLmEuZm9yd2FyZFJlZihuKSl9KGkuY3JlYXRlRWxlbWVudCgicGF0aCIse2Q6Ik03IDEwbDUgNSA1LTV6In0pKSxYZT1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jbGFzc2VzLGE9ZS5jbGFzc05hbWUsdT1lLmRpc2FibGVkLHM9ZS5JY29uQ29tcG9uZW50LGM9ZS5pbnB1dFJlZixkPWUudmFyaWFudCxmPXZvaWQgMD09PWQ/InN0YW5kYXJkIjpkLGg9T2JqZWN0KG8uYSkoZSxbImNsYXNzZXMiLCJjbGFzc05hbWUiLCJkaXNhYmxlZCIsIkljb25Db21wb25lbnQiLCJpbnB1dFJlZiIsInZhcmlhbnQiXSk7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChpLkZyYWdtZW50LG51bGwsaS5jcmVhdGVFbGVtZW50KCJzZWxlY3QiLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGwuYSkobi5yb290LG4uc2VsZWN0LG5bZl0sYSx1JiZuLmRpc2FibGVkKSxkaXNhYmxlZDp1LHJlZjpjfHx0fSxoKSksZS5tdWx0aXBsZT9udWxsOmkuY3JlYXRlRWxlbWVudChzLHtjbGFzc05hbWU6T2JqZWN0KGwuYSkobi5pY29uLG5bImljb24iLmNvbmNhdChPYmplY3QocC5hKShmKSldLHUmJm4uZGlzYWJsZWQpfSkpfSkpLEdlPWZ1bmN0aW9uKGUpe3JldHVybntyb290Ont9LHNlbGVjdDp7Ii1tb3otYXBwZWFyYW5jZSI6Im5vbmUiLCItd2Via2l0LWFw",
                    "cGVhcmFuY2UiOiJub25lIix1c2VyU2VsZWN0OiJub25lIixib3JkZXJSYWRpdXM6MCxtaW5XaWR0aDoxNixjdXJzb3I6InBvaW50ZXIiLCImOmZvY3VzIjp7YmFja2dyb3VuZENvbG9yOiJsaWdodCI9PT1lLnBhbGV0dGUudHlwZT8icmdiYSgwLCAwLCAwLCAwLjA1KSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSkiLGJvcmRlclJhZGl1czowfSwiJjo6LW1zLWV4cGFuZCI6e2Rpc3BsYXk6Im5vbmUifSwiJiRkaXNhYmxlZCI6e2N1cnNvcjoiZGVmYXVsdCJ9LCImW211bHRpcGxlXSI6e2hlaWdodDoiYXV0byJ9LCImOm5vdChbbXVsdGlwbGVdKSBvcHRpb24sICY6bm90KFttdWx0aXBsZV0pIG9wdGdyb3VwIjp7YmFja2dyb3VuZENvbG9yOmUucGFsZXR0ZS5iYWNrZ3JvdW5kLnBhcGVyfSwiJiYiOntwYWRkaW5nUmlnaHQ6MjR9fSxmaWxsZWQ6eyImJiI6e3BhZGRpbmdSaWdodDozMn19LG91dGxpbmVkOntib3JkZXJSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXMsIiYmIjp7cGFkZGluZ1JpZ2h0OjMyfX0sc2VsZWN0TWVudTp7aGVpZ2h0OiJhdXRvIixtaW5IZWlnaHQ6IjEuMTg3NmVtIix0ZXh0T3ZlcmZsb3c6ImVsbGlwc2lzIix3aGl0ZVNwYWNlOiJub3dyYXAiLG92ZXJmbG93OiJoaWRkZW4ifSxkaXNhYmxlZDp7fSxpY29uOntwb3NpdGlvbjoiYWJzb2x1dGUiLHJpZ2h0OjAsdG9wOiJjYWxjKDUwJSAtIDEycHgpIixwb2ludGVyRXZlbnRzOiJub25lIixjb2xvcjplLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZSwiJiRk",
                    "aXNhYmxlZCI6e2NvbG9yOmUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWR9fSxpY29uT3Blbjp7dHJhbnNmb3JtOiJyb3RhdGUoMTgwZGVnKSJ9LGljb25GaWxsZWQ6e3JpZ2h0Ojd9LGljb25PdXRsaW5lZDp7cmlnaHQ6N30sbmF0aXZlSW5wdXQ6e2JvdHRvbTowLGxlZnQ6MCxwb3NpdGlvbjoiYWJzb2x1dGUiLG9wYWNpdHk6MCxwb2ludGVyRXZlbnRzOiJub25lIix3aWR0aDoiMTAwJSJ9fX0sSmU9aS5jcmVhdGVFbGVtZW50KEMsbnVsbCksWmU9aS5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2hpbGRyZW4sYT1lLmNsYXNzZXMsbD1lLkljb25Db21wb25lbnQsdT12b2lkIDA9PT1sP1FlOmwsYz1lLmlucHV0LGQ9dm9pZCAwPT09Yz9KZTpjLGY9ZS5pbnB1dFByb3BzLHA9KGUudmFyaWFudCxPYmplY3Qoby5hKShlLFsiY2hpbGRyZW4iLCJjbGFzc2VzIiwiSWNvbkNvbXBvbmVudCIsImlucHV0IiwiaW5wdXRQcm9wcyIsInZhcmlhbnQiXSkpLGg9cyh7cHJvcHM6ZSxtdWlGb3JtQ29udHJvbDpJKCksc3RhdGVzOlsidmFyaWFudCJdfSk7cmV0dXJuIGkuY2xvbmVFbGVtZW50KGQsT2JqZWN0KHIuYSkoe2lucHV0Q29tcG9uZW50OlhlLGlucHV0UHJvcHM6T2JqZWN0KHIuYSkoe2NoaWxkcmVuOm4sY2xhc3NlczphLEljb25Db21wb25lbnQ6dSx2YXJpYW50OmgudmFyaWFudCx0eXBlOnZvaWQgMH0sZixkP2QucHJvcHMuaW5wdXRQcm9wczp7fSkscmVmOnR9LHApKX0pKTtaZS5tdWlOYW1lPSJTZWxlY3QiO09i",
                    "amVjdChmLmEpKEdlLHtuYW1lOiJNdWlOYXRpdmVTZWxlY3QifSkoWmUpO3ZhciBldD1HZSx0dD1pLmNyZWF0ZUVsZW1lbnQoQyxudWxsKSxudD1pLmNyZWF0ZUVsZW1lbnQoVCxudWxsKSxydD1pLmZvcndhcmRSZWYoKGZ1bmN0aW9uIGUodCxuKXt2YXIgYT10LmF1dG9XaWR0aCxsPXZvaWQgMCE9PWEmJmEsdT10LmNoaWxkcmVuLGM9dC5jbGFzc2VzLGQ9dC5kaXNwbGF5RW1wdHksZj12b2lkIDAhPT1kJiZkLHA9dC5JY29uQ29tcG9uZW50LGg9dm9pZCAwPT09cD9RZTpwLG09dC5pZCx2PXQuaW5wdXQsYj10LmlucHV0UHJvcHMseT10LmxhYmVsLGc9dC5sYWJlbElkLHc9dC5sYWJlbFdpZHRoLHg9dm9pZCAwPT09dz8wOncsRT10Lk1lbnVQcm9wcyxPPXQubXVsdGlwbGUsaz12b2lkIDAhPT1PJiZPLFM9dC5uYXRpdmUsQz12b2lkIDAhPT1TJiZTLGo9dC5vbkNsb3NlLFQ9dC5vbk9wZW4sUD10Lm9wZW4sUj10LnJlbmRlclZhbHVlLE49dC5TZWxlY3REaXNwbGF5UHJvcHMsTT10LnZhcmlhbnQsXz12b2lkIDA9PT1NPyJzdGFuZGFyZCI6TSxEPU9iamVjdChvLmEpKHQsWyJhdXRvV2lkdGgiLCJjaGlsZHJlbiIsImNsYXNzZXMiLCJkaXNwbGF5RW1wdHkiLCJJY29uQ29tcG9uZW50IiwiaWQiLCJpbnB1dCIsImlucHV0UHJvcHMiLCJsYWJlbCIsImxhYmVsSWQiLCJsYWJlbFdpZHRoIiwiTWVudVByb3BzIiwibXVsdGlwbGUiLCJuYXRpdmUiLCJvbkNsb3NlIiwib25PcGVuIiwib3BlbiIsInJlbmRlclZhbHVlIiwiU2VsZWN0",
                    "RGlzcGxheVByb3BzIiwidmFyaWFudCJdKSx6PUM/WGU6S2UsTD1zKHtwcm9wczp0LG11aUZvcm1Db250cm9sOkkoKSxzdGF0ZXM6WyJ2YXJpYW50Il19KS52YXJpYW50fHxfLEY9dnx8e3N0YW5kYXJkOnR0LG91dGxpbmVkOmkuY3JlYXRlRWxlbWVudChBLHtsYWJlbDp5LGxhYmVsV2lkdGg6eH0pLGZpbGxlZDpudH1bTF07cmV0dXJuIGkuY2xvbmVFbGVtZW50KEYsT2JqZWN0KHIuYSkoe2lucHV0Q29tcG9uZW50OnosaW5wdXRQcm9wczpPYmplY3Qoci5hKSh7Y2hpbGRyZW46dSxJY29uQ29tcG9uZW50OmgsdmFyaWFudDpMLHR5cGU6dm9pZCAwLG11bHRpcGxlOmt9LEM/e2lkOm19OnthdXRvV2lkdGg6bCxkaXNwbGF5RW1wdHk6ZixsYWJlbElkOmcsTWVudVByb3BzOkUsb25DbG9zZTpqLG9uT3BlbjpULG9wZW46UCxyZW5kZXJWYWx1ZTpSLFNlbGVjdERpc3BsYXlQcm9wczpPYmplY3Qoci5hKSh7aWQ6bX0sTil9LGIse2NsYXNzZXM6Yj9PYmplY3QoVS5hKSh7YmFzZUNsYXNzZXM6YyxuZXdDbGFzc2VzOmIuY2xhc3NlcyxDb21wb25lbnQ6ZX0pOmN9LHY/di5wcm9wcy5pbnB1dFByb3BzOnt9KSxyZWY6bn0sRCkpfSkpO3J0Lm11aU5hbWU9IlNlbGVjdCI7dmFyIG90PU9iamVjdChmLmEpKGV0LHtuYW1lOiJNdWlTZWxlY3QifSkocnQpLGl0PXtzdGFuZGFyZDpDLGZpbGxlZDpULG91dGxpbmVkOkF9LGF0PWkuZm9yd2FyZFJlZigoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmF1dG9Db21wbGV0ZSxhPWUuYXV0b0ZvY3VzLHU9",
                    "dm9pZCAwIT09YSYmYSxzPWUuY2hpbGRyZW4sYz1lLmNsYXNzZXMsZD1lLmNsYXNzTmFtZSxmPWUuY29sb3IscD12b2lkIDA9PT1mPyJwcmltYXJ5IjpmLGg9ZS5kZWZhdWx0VmFsdWUsbT1lLmRpc2FibGVkLHY9dm9pZCAwIT09bSYmbSxiPWUuZXJyb3IseT12b2lkIDAhPT1iJiZiLGc9ZS5Gb3JtSGVscGVyVGV4dFByb3BzLHc9ZS5mdWxsV2lkdGgseD12b2lkIDAhPT13JiZ3LEU9ZS5oZWxwZXJUZXh0LE89ZS5oaWRkZW5MYWJlbCxrPWUuaWQsUz1lLklucHV0TGFiZWxQcm9wcyxDPWUuaW5wdXRQcm9wcyxqPWUuSW5wdXRQcm9wcyxUPWUuaW5wdXRSZWYsUD1lLmxhYmVsLFI9ZS5tdWx0aWxpbmUsTj12b2lkIDAhPT1SJiZSLE09ZS5uYW1lLF89ZS5vbkJsdXIsQT1lLm9uQ2hhbmdlLEk9ZS5vbkZvY3VzLEQ9ZS5wbGFjZWhvbGRlcix6PWUucmVxdWlyZWQsTD12b2lkIDAhPT16JiZ6LCQ9ZS5yb3dzLFc9ZS5yb3dzTWF4LEg9ZS5zZWxlY3QsVT12b2lkIDAhPT1IJiZILHE9ZS5TZWxlY3RQcm9wcyxLPWUudHlwZSxZPWUudmFsdWUsUT1lLnZhcmlhbnQsWD12b2lkIDA9PT1RPyJzdGFuZGFyZCI6USxHPU9iamVjdChvLmEpKGUsWyJhdXRvQ29tcGxldGUiLCJhdXRvRm9jdXMiLCJjaGlsZHJlbiIsImNsYXNzZXMiLCJjbGFzc05hbWUiLCJjb2xvciIsImRlZmF1bHRWYWx1ZSIsImRpc2FibGVkIiwiZXJyb3IiLCJGb3JtSGVscGVyVGV4dFByb3BzIiwiZnVsbFdpZHRoIiwiaGVscGVyVGV4dCIsImhpZGRlbkxhYmVsIiwiaWQi",
                    "LCJJbnB1dExhYmVsUHJvcHMiLCJpbnB1dFByb3BzIiwiSW5wdXRQcm9wcyIsImlucHV0UmVmIiwibGFiZWwiLCJtdWx0aWxpbmUiLCJuYW1lIiwib25CbHVyIiwib25DaGFuZ2UiLCJvbkZvY3VzIiwicGxhY2Vob2xkZXIiLCJyZXF1aXJlZCIsInJvd3MiLCJyb3dzTWF4Iiwic2VsZWN0IiwiU2VsZWN0UHJvcHMiLCJ0eXBlIiwidmFsdWUiLCJ2YXJpYW50Il0pO3ZhciBKPXt9O2lmKCJvdXRsaW5lZCI9PT1YJiYoUyYmInVuZGVmaW5lZCIhPT10eXBlb2YgUy5zaHJpbmsmJihKLm5vdGNoZWQ9Uy5zaHJpbmspLFApKXt2YXIgWixlZT1udWxsIT09KFo9bnVsbD09PVN8fHZvaWQgMD09PVM/dm9pZCAwOlMucmVxdWlyZWQpJiZ2b2lkIDAhPT1aP1o6TDtKLmxhYmVsPWkuY3JlYXRlRWxlbWVudChpLkZyYWdtZW50LG51bGwsUCxlZSYmIlx4YTAqIil9VSYmKHEmJnEubmF0aXZlfHwoSi5pZD12b2lkIDApLEpbImFyaWEtZGVzY3JpYmVkYnkiXT12b2lkIDApO3ZhciB0ZT1FJiZrPyIiLmNvbmNhdChrLCItaGVscGVyLXRleHQiKTp2b2lkIDAsbmU9UCYmaz8iIi5jb25jYXQoaywiLWxhYmVsIik6dm9pZCAwLHJlPWl0W1hdLG9lPWkuY3JlYXRlRWxlbWVudChyZSxPYmplY3Qoci5hKSh7ImFyaWEtZGVzY3JpYmVkYnkiOnRlLGF1dG9Db21wbGV0ZTpuLGF1dG9Gb2N1czp1LGRlZmF1bHRWYWx1ZTpoLGZ1bGxXaWR0aDp4LG11bHRpbGluZTpOLG5hbWU6TSxyb3dzOiQscm93c01heDpXLHR5cGU6Syx2YWx1ZTpZLGlkOmssaW5wdXRS",
                    "ZWY6VCxvbkJsdXI6XyxvbkNoYW5nZTpBLG9uRm9jdXM6SSxwbGFjZWhvbGRlcjpELGlucHV0UHJvcHM6Q30sSixqKSk7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChCLE9iamVjdChyLmEpKHtjbGFzc05hbWU6T2JqZWN0KGwuYSkoYy5yb290LGQpLGRpc2FibGVkOnYsZXJyb3I6eSxmdWxsV2lkdGg6eCxoaWRkZW5MYWJlbDpPLHJlZjp0LHJlcXVpcmVkOkwsY29sb3I6cCx2YXJpYW50Olh9LEcpLFAmJmkuY3JlYXRlRWxlbWVudChGLE9iamVjdChyLmEpKHtodG1sRm9yOmssaWQ6bmV9LFMpLFApLFU/aS5jcmVhdGVFbGVtZW50KG90LE9iamVjdChyLmEpKHsiYXJpYS1kZXNjcmliZWRieSI6dGUsaWQ6ayxsYWJlbElkOm5lLHZhbHVlOlksaW5wdXQ6b2V9LHEpLHMpOm9lLEUmJmkuY3JlYXRlRWxlbWVudChWLE9iamVjdChyLmEpKHtpZDp0ZX0sZyksRSkpfSkpO3QuYT1PYmplY3QoZi5hKSh7cm9vdDp7fX0se25hbWU6Ik11aVRleHRGaWVsZCJ9KShhdCl9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oMTMpLGk9bigyMSk7big1KTtmdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUucmVwbGFjZShuZXcgUmVnRXhwKCIoXnxcXHMpIit0KyIoPzpcXHN8JCkiLCJnIiksIiQxIikucmVwbGFjZSgvXHMrL2csIiAiKS5yZXBsYWNlKC9eXHMqfFxzKiQvZywiIil9dmFyIGw9bigwKSx1PW4ubihsKSxzPW4oNjUpLGM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSYmdCYmdC5zcGxpdCgiICIpLmZvckVhY2goKGZ1",
                    "bmN0aW9uKHQpe3JldHVybiByPXQsdm9pZCgobj1lKS5jbGFzc0xpc3Q/bi5jbGFzc0xpc3QucmVtb3ZlKHIpOiJzdHJpbmciPT09dHlwZW9mIG4uY2xhc3NOYW1lP24uY2xhc3NOYW1lPWEobi5jbGFzc05hbWUscik6bi5zZXRBdHRyaWJ1dGUoImNsYXNzIixhKG4uY2xhc3NOYW1lJiZuLmNsYXNzTmFtZS5iYXNlVmFsfHwiIixyKSkpO3ZhciBuLHJ9KSl9LGQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe2Zvcih2YXIgdCxuPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkobiksbz0wO288bjtvKyspcltvXT1hcmd1bWVudHNbb107cmV0dXJuKHQ9ZS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChyKSl8fHRoaXMpLmFwcGxpZWRDbGFzc2VzPXthcHBlYXI6e30sZW50ZXI6e30sZXhpdDp7fX0sdC5vbkVudGVyPWZ1bmN0aW9uKGUsbil7dmFyIHI9dC5yZXNvbHZlQXJndW1lbnRzKGUsbiksbz1yWzBdLGk9clsxXTt0LnJlbW92ZUNsYXNzZXMobywiZXhpdCIpLHQuYWRkQ2xhc3MobyxpPyJhcHBlYXIiOiJlbnRlciIsImJhc2UiKSx0LnByb3BzLm9uRW50ZXImJnQucHJvcHMub25FbnRlcihlLG4pfSx0Lm9uRW50ZXJpbmc9ZnVuY3Rpb24oZSxuKXt2YXIgcj10LnJlc29sdmVBcmd1bWVudHMoZSxuKSxvPXJbMF0saT1yWzFdPyJhcHBlYXIiOiJlbnRlciI7dC5hZGRDbGFzcyhvLGksImFjdGl2ZSIpLHQucHJvcHMub25FbnRlcmluZyYmdC5wcm9wcy5vbkVudGVyaW5nKGUsbil9LHQub25FbnRlcmVkPWZ1bmN0aW9uKGUs",
                    "bil7dmFyIHI9dC5yZXNvbHZlQXJndW1lbnRzKGUsbiksbz1yWzBdLGk9clsxXT8iYXBwZWFyIjoiZW50ZXIiO3QucmVtb3ZlQ2xhc3NlcyhvLGkpLHQuYWRkQ2xhc3MobyxpLCJkb25lIiksdC5wcm9wcy5vbkVudGVyZWQmJnQucHJvcHMub25FbnRlcmVkKGUsbil9LHQub25FeGl0PWZ1bmN0aW9uKGUpe3ZhciBuPXQucmVzb2x2ZUFyZ3VtZW50cyhlKVswXTt0LnJlbW92ZUNsYXNzZXMobiwiYXBwZWFyIiksdC5yZW1vdmVDbGFzc2VzKG4sImVudGVyIiksdC5hZGRDbGFzcyhuLCJleGl0IiwiYmFzZSIpLHQucHJvcHMub25FeGl0JiZ0LnByb3BzLm9uRXhpdChlKX0sdC5vbkV4aXRpbmc9ZnVuY3Rpb24oZSl7dmFyIG49dC5yZXNvbHZlQXJndW1lbnRzKGUpWzBdO3QuYWRkQ2xhc3MobiwiZXhpdCIsImFjdGl2ZSIpLHQucHJvcHMub25FeGl0aW5nJiZ0LnByb3BzLm9uRXhpdGluZyhlKX0sdC5vbkV4aXRlZD1mdW5jdGlvbihlKXt2YXIgbj10LnJlc29sdmVBcmd1bWVudHMoZSlbMF07dC5yZW1vdmVDbGFzc2VzKG4sImV4aXQiKSx0LmFkZENsYXNzKG4sImV4aXQiLCJkb25lIiksdC5wcm9wcy5vbkV4aXRlZCYmdC5wcm9wcy5vbkV4aXRlZChlKX0sdC5yZXNvbHZlQXJndW1lbnRzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHQucHJvcHMubm9kZVJlZj9bdC5wcm9wcy5ub2RlUmVmLmN1cnJlbnQsZV06W2Usbl19LHQuZ2V0Q2xhc3NOYW1lcz1mdW5jdGlvbihlKXt2YXIgbj10LnByb3BzLmNsYXNzTmFtZXMscj0ic3RyaW5nIj09",
                    "PXR5cGVvZiBuLG89cj8iIisociYmbj9uKyItIjoiIikrZTpuW2VdO3JldHVybntiYXNlQ2xhc3NOYW1lOm8sYWN0aXZlQ2xhc3NOYW1lOnI/bysiLWFjdGl2ZSI6bltlKyJBY3RpdmUiXSxkb25lQ2xhc3NOYW1lOnI/bysiLWRvbmUiOm5bZSsiRG9uZSJdfX0sdH1PYmplY3QoaS5hKSh0LGUpO3ZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmFkZENsYXNzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLmdldENsYXNzTmFtZXModClbbisiQ2xhc3NOYW1lIl0sbz10aGlzLmdldENsYXNzTmFtZXMoImVudGVyIikuZG9uZUNsYXNzTmFtZTsiYXBwZWFyIj09PXQmJiJkb25lIj09PW4mJm8mJihyKz0iICIrbyksImFjdGl2ZSI9PT1uJiZlJiZlLnNjcm9sbFRvcCxyJiYodGhpcy5hcHBsaWVkQ2xhc3Nlc1t0XVtuXT1yLGZ1bmN0aW9uKGUsdCl7ZSYmdCYmdC5zcGxpdCgiICIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiByPXQsdm9pZCgobj1lKS5jbGFzc0xpc3Q/bi5jbGFzc0xpc3QuYWRkKHIpOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY2xhc3NMaXN0PyEhdCYmZS5jbGFzc0xpc3QuY29udGFpbnModCk6LTEhPT0oIiAiKyhlLmNsYXNzTmFtZS5iYXNlVmFsfHxlLmNsYXNzTmFtZSkrIiAiKS5pbmRleE9mKCIgIit0KyIgIil9KG4scil8fCgic3RyaW5nIj09PXR5cGVvZiBuLmNsYXNzTmFtZT9uLmNsYXNzTmFtZT1uLmNsYXNzTmFtZSsiICIrcjpuLnNldEF0dHJpYnV0ZSgiY2xhc3MiLChuLmNsYXNzTmFtZSYmbi5j",
                    "bGFzc05hbWUuYmFzZVZhbHx8IiIpKyIgIityKSkpO3ZhciBuLHJ9KSl9KGUscikpfSxuLnJlbW92ZUNsYXNzZXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmFwcGxpZWRDbGFzc2VzW3RdLHI9bi5iYXNlLG89bi5hY3RpdmUsaT1uLmRvbmU7dGhpcy5hcHBsaWVkQ2xhc3Nlc1t0XT17fSxyJiZjKGUsciksbyYmYyhlLG8pLGkmJmMoZSxpKX0sbi5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9KGUuY2xhc3NOYW1lcyxPYmplY3Qoby5hKShlLFsiY2xhc3NOYW1lcyJdKSk7cmV0dXJuIHUuYS5jcmVhdGVFbGVtZW50KHMuYSxPYmplY3Qoci5hKSh7fSx0LHtvbkVudGVyOnRoaXMub25FbnRlcixvbkVudGVyZWQ6dGhpcy5vbkVudGVyZWQsb25FbnRlcmluZzp0aGlzLm9uRW50ZXJpbmcsb25FeGl0OnRoaXMub25FeGl0LG9uRXhpdGluZzp0aGlzLm9uRXhpdGluZyxvbkV4aXRlZDp0aGlzLm9uRXhpdGVkfSkpfSx0fSh1LmEuQ29tcG9uZW50KTtkLmRlZmF1bHRQcm9wcz17Y2xhc3NOYW1lczoiIn0sZC5wcm9wVHlwZXM9e307dC5hPWR9LGZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7dmFyIHI9bigxKSxvPW4oNDApLGk9big0MSksYT1uKDMzKSxsPW4oNDIpO3ZhciB1PW4oMTkpLHM9bigyKSxjPW4oMCksZD0obigyOCksbig1KSxuKDMpKSxmPW4oNjUpLHA9big0KSxoPW4oNDMpLG09bigzMiksdj1uKDIyKSxiPW4oMTApLHk9Yy5mb3J3YXJkUmVmKChmdW5jdGlvbihlLHQpe3ZhciBuPWUuY2hpbGRy",
                    "ZW4sbz1lLmNsYXNzZXMsaT1lLmNsYXNzTmFtZSxhPWUuY29sbGFwc2VkSGVpZ2h0LGw9dm9pZCAwPT09YT8iMHB4IjphLHA9ZS5jb21wb25lbnQseT12b2lkIDA9PT1wPyJkaXYiOnAsZz1lLmRpc2FibGVTdHJpY3RNb2RlQ29tcGF0LHc9dm9pZCAwIT09ZyYmZyx4PWUuaW4sRT1lLm9uRW50ZXIsTz1lLm9uRW50ZXJlZCxrPWUub25FbnRlcmluZyxTPWUub25FeGl0LEM9ZS5vbkV4aXRlZCxqPWUub25FeGl0aW5nLFQ9ZS5zdHlsZSxQPWUudGltZW91dCxSPXZvaWQgMD09PVA/aC5iLnN0YW5kYXJkOlAsTj1lLlRyYW5zaXRpb25Db21wb25lbnQsTT12b2lkIDA9PT1OP2YuYTpOLF89T2JqZWN0KHMuYSkoZSxbImNoaWxkcmVuIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImNvbGxhcHNlZEhlaWdodCIsImNvbXBvbmVudCIsImRpc2FibGVTdHJpY3RNb2RlQ29tcGF0IiwiaW4iLCJvbkVudGVyIiwib25FbnRlcmVkIiwib25FbnRlcmluZyIsIm9uRXhpdCIsIm9uRXhpdGVkIiwib25FeGl0aW5nIiwic3R5bGUiLCJ0aW1lb3V0IiwiVHJhbnNpdGlvbkNvbXBvbmVudCJdKSxBPU9iamVjdCh2LmEpKCksST1jLnVzZVJlZigpLEQ9Yy51c2VSZWYobnVsbCksej1jLnVzZVJlZigpLEw9Im51bWJlciI9PT10eXBlb2YgbD8iIi5jb25jYXQobCwicHgiKTpsO2MudXNlRWZmZWN0KChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe2NsZWFyVGltZW91dChJLmN1cnJlbnQpfX0pLFtdKTt2YXIgRj1BLnVuc3RhYmxlX3N0cmljdE1vZGUm",
                    "JiF3LCQ9Yy51c2VSZWYobnVsbCksVz1PYmplY3QoYi5hKSh0LEY/JDp2b2lkIDApLEI9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYoZSl7dmFyIHI9Rj9bJC5jdXJyZW50LHRdOlt0LG5dLG89T2JqZWN0KHUuYSkociwyKSxpPW9bMF0sYT1vWzFdO3ZvaWQgMD09PWE/ZShpKTplKGksYSl9fX0sSD1CKChmdW5jdGlvbihlLHQpe2Uuc3R5bGUuaGVpZ2h0PUwsRSYmRShlLHQpfSkpLFY9QigoZnVuY3Rpb24oZSx0KXt2YXIgbj1ELmN1cnJlbnQ/RC5jdXJyZW50LmNsaWVudEhlaWdodDowLHI9T2JqZWN0KG0uYSkoe3N0eWxlOlQsdGltZW91dDpSfSx7bW9kZToiZW50ZXIifSkuZHVyYXRpb247aWYoImF1dG8iPT09Uil7dmFyIG89QS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24obik7ZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb249IiIuY29uY2F0KG8sIm1zIiksei5jdXJyZW50PW99ZWxzZSBlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj0ic3RyaW5nIj09PXR5cGVvZiByP3I6IiIuY29uY2F0KHIsIm1zIik7ZS5zdHlsZS5oZWlnaHQ9IiIuY29uY2F0KG4sInB4IiksayYmayhlLHQpfSkpLFU9QigoZnVuY3Rpb24oZSx0KXtlLnN0eWxlLmhlaWdodD0iYXV0byIsTyYmTyhlLHQpfSkpLHE9QigoZnVuY3Rpb24oZSl7dmFyIHQ9RC5jdXJyZW50P0QuY3VycmVudC5jbGllbnRIZWlnaHQ6MDtlLnN0eWxlLmhlaWdodD0iIi5jb25jYXQodCwicHgiKSxTJiZTKGUpfSkpLEs9QihDKSxZPUIoKGZ1",
                    "bmN0aW9uKGUpe3ZhciB0PUQuY3VycmVudD9ELmN1cnJlbnQuY2xpZW50SGVpZ2h0OjAsbj1PYmplY3QobS5hKSh7c3R5bGU6VCx0aW1lb3V0OlJ9LHttb2RlOiJleGl0In0pLmR1cmF0aW9uO2lmKCJhdXRvIj09PVIpe3ZhciByPUEudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKHQpO2Uuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPSIiLmNvbmNhdChyLCJtcyIpLHouY3VycmVudD1yfWVsc2UgZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb249InN0cmluZyI9PT10eXBlb2Ygbj9uOiIiLmNvbmNhdChuLCJtcyIpO2Uuc3R5bGUuaGVpZ2h0PUwsaiYmaihlKX0pKTtyZXR1cm4gYy5jcmVhdGVFbGVtZW50KE0sT2JqZWN0KHIuYSkoe2luOngsb25FbnRlcjpILG9uRW50ZXJlZDpVLG9uRW50ZXJpbmc6VixvbkV4aXQ6cSxvbkV4aXRlZDpLLG9uRXhpdGluZzpZLGFkZEVuZExpc3RlbmVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49Rj9lOnQ7ImF1dG8iPT09UiYmKEkuY3VycmVudD1zZXRUaW1lb3V0KG4sei5jdXJyZW50fHwwKSl9LG5vZGVSZWY6Rj8kOnZvaWQgMCx0aW1lb3V0OiJhdXRvIj09PVI/bnVsbDpSfSxfKSwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gYy5jcmVhdGVFbGVtZW50KHksT2JqZWN0KHIuYSkoe2NsYXNzTmFtZTpPYmplY3QoZC5hKShvLmNvbnRhaW5lcixpLHtlbnRlcmVkOm8uZW50ZXJlZCxleGl0ZWQ6IXgmJiIwcHgiPT09TCYmby5oaWRkZW59W2VdKSxzdHlsZTpPYmplY3Qoci5hKSh7bWluSGVpZ2h0",
                    "Okx9LFQpLHJlZjpXfSx0KSxjLmNyZWF0ZUVsZW1lbnQoImRpdiIse2NsYXNzTmFtZTpvLndyYXBwZXIscmVmOkR9LGMuY3JlYXRlRWxlbWVudCgiZGl2Iix7Y2xhc3NOYW1lOm8ud3JhcHBlcklubmVyfSxuKSkpfSkpfSkpO3kubXVpU3VwcG9ydEF1dG89ITA7dmFyIGc9T2JqZWN0KHAuYSkoKGZ1bmN0aW9uKGUpe3JldHVybntjb250YWluZXI6e2hlaWdodDowLG92ZXJmbG93OiJoaWRkZW4iLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoImhlaWdodCIpfSxlbnRlcmVkOntoZWlnaHQ6ImF1dG8iLG92ZXJmbG93OiJ2aXNpYmxlIn0saGlkZGVuOnt2aXNpYmlsaXR5OiJoaWRkZW4ifSx3cmFwcGVyOntkaXNwbGF5OiJmbGV4In0sd3JhcHBlcklubmVyOnt3aWR0aDoiMTAwJSJ9fX0pLHtuYW1lOiJNdWlDb2xsYXBzZSJ9KSh5KSx3PW4oMTI4KSx4PW4oNDYpLEU9big0NSksTz1jLmZvcndhcmRSZWYoKGZ1bmN0aW9uKGUsdCl7dmFyIG4sZj1lLmNoaWxkcmVuLHA9ZS5jbGFzc2VzLGg9ZS5jbGFzc05hbWUsbT1lLmRlZmF1bHRFeHBhbmRlZCx2PXZvaWQgMCE9PW0mJm0sYj1lLmRpc2FibGVkLHk9dm9pZCAwIT09YiYmYixPPWUuZXhwYW5kZWQsaz1lLm9uQ2hhbmdlLFM9ZS5zcXVhcmUsQz12b2lkIDAhPT1TJiZTLGo9ZS5UcmFuc2l0aW9uQ29tcG9uZW50LFQ9dm9pZCAwPT09aj9nOmosUD1lLlRyYW5zaXRpb25Qcm9wcyxSPU9iamVjdChzLmEpKGUsWyJjaGlsZHJlbiIsImNsYXNzZXMiLCJjbGFzc05hbWUiLCJk",
                    "ZWZhdWx0RXhwYW5kZWQiLCJkaXNhYmxlZCIsImV4cGFuZGVkIiwib25DaGFuZ2UiLCJzcXVhcmUiLCJUcmFuc2l0aW9uQ29tcG9uZW50IiwiVHJhbnNpdGlvblByb3BzIl0pLE49T2JqZWN0KEUuYSkoe2NvbnRyb2xsZWQ6TyxkZWZhdWx0OnYsbmFtZToiQWNjb3JkaW9uIixzdGF0ZToiZXhwYW5kZWQifSksTT1PYmplY3QodS5hKShOLDIpLF89TVswXSxBPU1bMV0sST1jLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtBKCFfKSxrJiZrKGUsIV8pfSksW18sayxBXSksRD1jLkNoaWxkcmVuLnRvQXJyYXkoZiksej0obj1ELE9iamVjdChvLmEpKG4pfHxPYmplY3QoaS5hKShuKXx8T2JqZWN0KGEuYSkobil8fE9iamVjdChsLmEpKCkpLEw9elswXSxGPXouc2xpY2UoMSksJD1jLnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJue2V4cGFuZGVkOl8sZGlzYWJsZWQ6eSx0b2dnbGU6SX19KSxbXyx5LEldKTtyZXR1cm4gYy5jcmVhdGVFbGVtZW50KHcuYSxPYmplY3Qoci5hKSh7Y2xhc3NOYW1lOk9iamVjdChkLmEpKHAucm9vdCxoLF8mJnAuZXhwYW5kZWQseSYmcC5kaXNhYmxlZCwhQyYmcC5yb3VuZGVkKSxyZWY6dCxzcXVhcmU6Q30sUiksYy5jcmVhdGVFbGVtZW50KHguYS5Qcm92aWRlcix7dmFsdWU6JH0sTCksYy5jcmVhdGVFbGVtZW50KFQsT2JqZWN0KHIuYSkoe2luOl8sdGltZW91dDoiYXV0byJ9LFApLGMuY3JlYXRlRWxlbWVudCgiZGl2Iix7ImFyaWEtbGFiZWxsZWRieSI6TC5wcm9wcy5pZCxpZDpMLnByb3BzWyJhcmlh",
                    "LWNvbnRyb2xzIl0scm9sZToicmVnaW9uIn0sRikpKX0pKTt0LmE9T2JqZWN0KHAuYSkoKGZ1bmN0aW9uKGUpe3ZhciB0PXtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXN0fTtyZXR1cm57cm9vdDp7cG9zaXRpb246InJlbGF0aXZlIix0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsibWFyZ2luIl0sdCksIiY6YmVmb3JlIjp7cG9zaXRpb246ImFic29sdXRlIixsZWZ0OjAsdG9wOi0xLHJpZ2h0OjAsaGVpZ2h0OjEsY29udGVudDonIiInLG9wYWNpdHk6MSxiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLmRpdmlkZXIsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZShbIm9wYWNpdHkiLCJiYWNrZ3JvdW5kLWNvbG9yIl0sdCl9LCImOmZpcnN0LWNoaWxkIjp7IiY6YmVmb3JlIjp7ZGlzcGxheToibm9uZSJ9fSwiJiRleHBhbmRlZCI6e21hcmdpbjoiMTZweCAwIiwiJjpmaXJzdC1jaGlsZCI6e21hcmdpblRvcDowfSwiJjpsYXN0LWNoaWxkIjp7bWFyZ2luQm90dG9tOjB9LCImOmJlZm9yZSI6e29wYWNpdHk6MH19LCImJGV4cGFuZGVkICsgJiI6eyImOmJlZm9yZSI6e2Rpc3BsYXk6Im5vbmUifX0sIiYkZGlzYWJsZWQiOntiYWNrZ3JvdW5kQ29sb3I6ZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZEJhY2tncm91bmR9fSxyb3VuZGVkOntib3JkZXJSYWRpdXM6MCwiJjpmaXJzdC1jaGlsZCI6e2JvcmRlclRvcExlZnRSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXMsYm9yZGVyVG9wUmln",
                    "aHRSYWRpdXM6ZS5zaGFwZS5ib3JkZXJSYWRpdXN9LCImOmxhc3QtY2hpbGQiOntib3JkZXJCb3R0b21MZWZ0UmFkaXVzOmUuc2hhcGUuYm9yZGVyUmFkaXVzLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOmUuc2hhcGUuYm9yZGVyUmFkaXVzLCJAc3VwcG9ydHMgKC1tcy1pbWUtYWxpZ246IGF1dG8pIjp7Ym9yZGVyQm90dG9tTGVmdFJhZGl1czowLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOjB9fX0sZXhwYW5kZWQ6e30sZGlzYWJsZWQ6e319fSkse25hbWU6Ik11aUFjY29yZGlvbiJ9KShPKX0sZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj1uKDEzKSxvPW4oMSksaT1uKDM4KSxhPW4oMjEpLGw9KG4oNSksbigwKSksdT1uLm4obCkscz1uKDM0KTtmdW5jdGlvbiBjKGUsdCl7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtyZXR1cm4gZSYmbC5DaGlsZHJlbi5tYXAoZSwoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlLmtleV09ZnVuY3Rpb24oZSl7cmV0dXJuIHQmJk9iamVjdChsLmlzVmFsaWRFbGVtZW50KShlKT90KGUpOmV9KGUpfSkpLG59ZnVuY3Rpb24gZChlLHQsbil7cmV0dXJuIG51bGwhPW5bdF0/blt0XTplLnByb3BzW3RdfWZ1bmN0aW9uIGYoZSx0LG4pe3ZhciByPWMoZS5jaGlsZHJlbiksbz1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4obil7cmV0dXJuIG4gaW4gdD90W25dOmVbbl19ZT1lfHx7fSx0PXR8fHt9O3ZhciByLG89T2JqZWN0LmNyZWF0ZShudWxs",
                    "KSxpPVtdO2Zvcih2YXIgYSBpbiBlKWEgaW4gdD9pLmxlbmd0aCYmKG9bYV09aSxpPVtdKTppLnB1c2goYSk7dmFyIGw9e307Zm9yKHZhciB1IGluIHQpe2lmKG9bdV0pZm9yKHI9MDtyPG9bdV0ubGVuZ3RoO3IrKyl7dmFyIHM9b1t1XVtyXTtsW29bdV1bcl1dPW4ocyl9bFt1XT1uKHUpfWZvcihyPTA7cjxpLmxlbmd0aDtyKyspbFtpW3JdXT1uKGlbcl0pO3JldHVybiBsfSh0LHIpO3JldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChmdW5jdGlvbihpKXt2YXIgYT1vW2ldO2lmKE9iamVjdChsLmlzVmFsaWRFbGVtZW50KShhKSl7dmFyIHU9aSBpbiB0LHM9aSBpbiByLGM9dFtpXSxmPU9iamVjdChsLmlzVmFsaWRFbGVtZW50KShjKSYmIWMucHJvcHMuaW47IXN8fHUmJiFmP3N8fCF1fHxmP3MmJnUmJk9iamVjdChsLmlzVmFsaWRFbGVtZW50KShjKSYmKG9baV09T2JqZWN0KGwuY2xvbmVFbGVtZW50KShhLHtvbkV4aXRlZDpuLmJpbmQobnVsbCxhKSxpbjpjLnByb3BzLmluLGV4aXQ6ZChhLCJleGl0IixlKSxlbnRlcjpkKGEsImVudGVyIixlKX0pKTpvW2ldPU9iamVjdChsLmNsb25lRWxlbWVudCkoYSx7aW46ITF9KTpvW2ldPU9iamVjdChsLmNsb25lRWxlbWVudCkoYSx7b25FeGl0ZWQ6bi5iaW5kKG51bGwsYSksaW46ITAsZXhpdDpkKGEsImV4aXQiLGUpLGVudGVyOmQoYSwiZW50ZXIiLGUpfSl9fSkpLG99dmFyIHA9T2JqZWN0LnZhbHVlc3x8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLm1hcCgo",
                    "ZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19KSl9LGg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4pe3ZhciByLG89KHI9ZS5jYWxsKHRoaXMsdCxuKXx8dGhpcykuaGFuZGxlRXhpdGVkLmJpbmQoT2JqZWN0KGkuYSkocikpO3JldHVybiByLnN0YXRlPXtjb250ZXh0VmFsdWU6e2lzTW91bnRpbmc6ITB9LGhhbmRsZUV4aXRlZDpvLGZpcnN0UmVuZGVyOiEwfSxyfU9iamVjdChhLmEpKHQsZSk7dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4uY29tcG9uZW50RGlkTW91bnQ9ZnVuY3Rpb24oKXt0aGlzLm1vdW50ZWQ9ITAsdGhpcy5zZXRTdGF0ZSh7Y29udGV4dFZhbHVlOntpc01vdW50aW5nOiExfX0pfSxuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy5tb3VudGVkPSExfSx0LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz1mdW5jdGlvbihlLHQpe3ZhciBuLHIsbz10LmNoaWxkcmVuLGk9dC5oYW5kbGVFeGl0ZWQ7cmV0dXJue2NoaWxkcmVuOnQuZmlyc3RSZW5kZXI/KG49ZSxyPWksYyhuLmNoaWxkcmVuLChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0KGwuY2xvbmVFbGVtZW50KShlLHtvbkV4aXRlZDpyLmJpbmQobnVsbCxlKSxpbjohMCxhcHBlYXI6ZChlLCJhcHBlYXIiLG4pLGVudGVyOmQoZSwiZW50ZXIiLG4pLGV4aXQ6ZChlLCJleGl0IixuKX0pfSkpKTpmKGUsbyxpKSxmaXJzdFJlbmRlcjohMX19LG4uaGFuZGxlRXhpdGVkPWZ1bmN0aW9uKGUsdCl7dmFyIG49Yyh0aGlzLnByb3BzLmNoaWxkcmVu",
                    "KTtlLmtleSBpbiBufHwoZS5wcm9wcy5vbkV4aXRlZCYmZS5wcm9wcy5vbkV4aXRlZCh0KSx0aGlzLm1vdW50ZWQmJnRoaXMuc2V0U3RhdGUoKGZ1bmN0aW9uKHQpe3ZhciBuPU9iamVjdChvLmEpKHt9LHQuY2hpbGRyZW4pO3JldHVybiBkZWxldGUgbltlLmtleV0se2NoaWxkcmVuOm59fSkpKX0sbi5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb21wb25lbnQsbj1lLmNoaWxkRmFjdG9yeSxvPU9iamVjdChyLmEpKGUsWyJjb21wb25lbnQiLCJjaGlsZEZhY3RvcnkiXSksaT10aGlzLnN0YXRlLmNvbnRleHRWYWx1ZSxhPXAodGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKG4pO3JldHVybiBkZWxldGUgby5hcHBlYXIsZGVsZXRlIG8uZW50ZXIsZGVsZXRlIG8uZXhpdCxudWxsPT09dD91LmEuY3JlYXRlRWxlbWVudChzLmEuUHJvdmlkZXIse3ZhbHVlOml9LGEpOnUuYS5jcmVhdGVFbGVtZW50KHMuYS5Qcm92aWRlcix7dmFsdWU6aX0sdS5hLmNyZWF0ZUVsZW1lbnQodCxvLGEpKX0sdH0odS5hLkNvbXBvbmVudCk7aC5wcm9wVHlwZXM9e30saC5kZWZhdWx0UHJvcHM9e2NvbXBvbmVudDoiZGl2IixjaGlsZEZhY3Rvcnk6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9fTt0LmE9aH1dXSk7"
                ],
                "static/js/runtime-main.ae5a3129.js": [
                    "IWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7Zm9yKHZhciBuLGwsaT1yWzBdLGE9clsxXSxmPXJbMl0sYz0wLHM9W107YzxpLmxlbmd0aDtjKyspbD1pW2NdLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLGwpJiZvW2xdJiZzLnB1c2gob1tsXVswXSksb1tsXT0wO2ZvcihuIGluIGEpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsbikmJihlW25dPWFbbl0pO2ZvcihwJiZwKHIpO3MubGVuZ3RoOylzLnNoaWZ0KCkoKTtyZXR1cm4gdS5wdXNoLmFwcGx5KHUsZnx8W10pLHQoKX1mdW5jdGlvbiB0KCl7Zm9yKHZhciBlLHI9MDtyPHUubGVuZ3RoO3IrKyl7Zm9yKHZhciB0PXVbcl0sbj0hMCxpPTE7aTx0Lmxlbmd0aDtpKyspe3ZhciBhPXRbaV07MCE9PW9bYV0mJihuPSExKX1uJiYodS5zcGxpY2Uoci0tLDEpLGU9bChsLnM9dFswXSkpfXJldHVybiBlfXZhciBuPXt9LG89ezE6MH0sdT1bXTtmdW5jdGlvbiBsKHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgdD1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKHQuZXhwb3J0cyx0LHQuZXhwb3J0cyxsKSx0Lmw9ITAsdC5leHBvcnRzfWwubT1lLGwuYz1uLGwuZD1mdW5jdGlvbihlLHIsdCl7bC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnR9KX0sbC5yPWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT09dHlwZW9mIFN5bWJvbCYmU3ltYm9s",
                    "LnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSxsLnQ9ZnVuY3Rpb24oZSxyKXtpZigxJnImJihlPWwoZSkpLDgmcilyZXR1cm4gZTtpZig0JnImJiJvYmplY3QiPT09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGwucih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImciYmInN0cmluZyIhPXR5cGVvZiBlKWZvcih2YXIgbiBpbiBlKWwuZCh0LG4sZnVuY3Rpb24ocil7cmV0dXJuIGVbcl19LmJpbmQobnVsbCxuKSk7cmV0dXJuIHR9LGwubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbC5kKHIsImEiLHIpLHJ9LGwubz1mdW5jdGlvbihlLHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKX0sbC5wPSIvIjt2YXIgaT10aGlzWyJ3ZWJwYWNrSnNvbnBqaXJhLXdvcmstbG9nZ2VyIl09dGhpc1sid2VicGFja0pzb25wamlyYS13b3JrLWxvZ2dlciJdfHxbXSxhPWkucHVzaC5iaW5kKGkpO2kucHVzaD1yLGk9aS5zbGljZSgpO2Zvcih2YXIgZj0wO2Y8aS5sZW5ndGg7",
                    "ZisrKXIoaVtmXSk7dmFyIHA9YTt0KCl9KFtdKTs="
                ]
            });
        }
    };
});
System.register("file:///Jira-Work-Logger/hamster", [], function (exports_65, context_65) {
    "use strict";
    var __moduleName = context_65 && context_65.id;
    async function getHamsterReport(begin, end, ignoreCateg) {
        if ((await Deno.permissions.query({ name: "run" })).state !== "granted") {
            throw new Error(`Missing Deno run permission"`);
        }
        const hamsterReport = await Deno.run({
            cmd: ["hamster", "export", "tsv", begin, end],
            stdout: "piped",
        }).output();
        const lines = new TextDecoder().decode(hamsterReport).split("\n").slice(1);
        return lines
            .filter((line) => line)
            .map((line) => {
            const [comment, date, , minutes, category] = line.split("\t");
            return { comment, date, minutes, category };
        })
            .filter(({ comment, date, minutes, category }) => !ignoreCateg || !category || !category.match(ignoreCateg))
            .map(({ comment, date, minutes, category }) => {
            return {
                comment,
                date: date?.substr(0, 10),
                hours: Math.round((100 * parseFloat(minutes)) / 60) / 100,
            };
        });
    }
    exports_65("getHamsterReport", getHamsterReport);
    return {
        setters: [],
        execute: async function () {
            if (context_65.meta.main) {
                console.log(await getHamsterReport("2020-01-01", "2020-12-31"));
            }
        }
    };
});
System.register("file:///Jira-Work-Logger/frontend/src/types", [], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.74.0/_util/assert", [], function (exports_67, context_67) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_67 && context_67.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_67("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_67("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/_constants", [], function (exports_68, context_68) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, NATIVE_OS, navigator, isWindows;
    var __moduleName = context_68 && context_68.id;
    return {
        setters: [],
        execute: function () {
            exports_68("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65);
            exports_68("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97);
            exports_68("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90);
            exports_68("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122);
            exports_68("CHAR_DOT", CHAR_DOT = 46);
            exports_68("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47);
            exports_68("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92);
            exports_68("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124);
            exports_68("CHAR_COLON", CHAR_COLON = 58);
            exports_68("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63);
            exports_68("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95);
            exports_68("CHAR_LINE_FEED", CHAR_LINE_FEED = 10);
            exports_68("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13);
            exports_68("CHAR_TAB", CHAR_TAB = 9);
            exports_68("CHAR_FORM_FEED", CHAR_FORM_FEED = 12);
            exports_68("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33);
            exports_68("CHAR_HASH", CHAR_HASH = 35);
            exports_68("CHAR_SPACE", CHAR_SPACE = 32);
            exports_68("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160);
            exports_68("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279);
            exports_68("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91);
            exports_68("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93);
            exports_68("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60);
            exports_68("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62);
            exports_68("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123);
            exports_68("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125);
            exports_68("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45);
            exports_68("CHAR_PLUS", CHAR_PLUS = 43);
            exports_68("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34);
            exports_68("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39);
            exports_68("CHAR_PERCENT", CHAR_PERCENT = 37);
            exports_68("CHAR_SEMICOLON", CHAR_SEMICOLON = 59);
            exports_68("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94);
            exports_68("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96);
            exports_68("CHAR_AT", CHAR_AT = 64);
            exports_68("CHAR_AMPERSAND", CHAR_AMPERSAND = 38);
            exports_68("CHAR_EQUAL", CHAR_EQUAL = 61);
            exports_68("CHAR_0", CHAR_0 = 48);
            exports_68("CHAR_9", CHAR_9 = 57);
            NATIVE_OS = "linux";
            exports_68("NATIVE_OS", NATIVE_OS);
            navigator = globalThis.navigator;
            if (globalThis.Deno != null) {
                exports_68("NATIVE_OS", NATIVE_OS = Deno.build.os);
            }
            else if (navigator?.appVersion?.includes?.("Win") ?? false) {
                exports_68("NATIVE_OS", NATIVE_OS = "windows");
            }
            exports_68("isWindows", isWindows = NATIVE_OS == "windows");
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/_interface", [], function (exports_69, context_69) {
    "use strict";
    var __moduleName = context_69 && context_69.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/_util", ["https://deno.land/std@0.74.0/path/_constants"], function (exports_70, context_70) {
    "use strict";
    var _constants_ts_7;
    var __moduleName = context_70 && context_70.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_70("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_7.CHAR_FORWARD_SLASH;
    }
    exports_70("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_7.CHAR_BACKWARD_SLASH;
    }
    exports_70("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_7.CHAR_LOWERCASE_A && code <= _constants_ts_7.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_7.CHAR_UPPERCASE_A && code <= _constants_ts_7.CHAR_UPPERCASE_Z));
    }
    exports_70("isWindowsDeviceRoot", isWindowsDeviceRoot);
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_7.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_7.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_7.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_7.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_70("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base ||
            (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_70("_format", _format);
    return {
        setters: [
            function (_constants_ts_7_1) {
                _constants_ts_7 = _constants_ts_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/win32", ["https://deno.land/std@0.74.0/path/_constants", "https://deno.land/std@0.74.0/path/_util", "https://deno.land/std@0.74.0/_util/assert"], function (exports_71, context_71) {
    "use strict";
    var _constants_ts_8, _util_ts_3, assert_ts_7, sep, delimiter;
    var __moduleName = context_71 && context_71.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_3.assertPath(path);
            const len = path.length;
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len > 1) {
                if (_util_ts_3.isPathSeparator(code)) {
                    isAbsolute = true;
                    if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                        let j = 2;
                        let last = j;
                        for (; j < len; ++j) {
                            if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            last = j;
                            for (; j < len; ++j) {
                                if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                last = j;
                                for (; j < len; ++j) {
                                    if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                    if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        resolvedTail = _util_ts_3.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_3.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_71("resolve", resolve);
    function normalize(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                isAbsolute = true;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_3.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_3.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_3.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_71("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_3.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_3.isWindowsDeviceRoot(code)) {
            if (len > 2 && path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                if (_util_ts_3.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_71("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_3.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_7.assert(firstPart != null);
        if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_3.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_71("join", join);
    function relative(from, to) {
        _util_ts_3.assertPath(from);
        _util_ts_3.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_8.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_8.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_71("relative", relative);
    function toNamespacedPath(path) {
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_8.CHAR_QUESTION_MARK && code !== _constants_ts_8.CHAR_DOT) {
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_71("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = offset = 1;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return path;
                            }
                            if (j !== last) {
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_3.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_71("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_3.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_3.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_3.isPathSeparator(code)) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_3.isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_71("basename", basename);
    function extname(path) {
        _util_ts_3.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
            _util_ts_3.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_3.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_71("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_3._format("\\", pathObject);
    }
    exports_71("format", format);
    function parse(path) {
        _util_ts_3.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = 1;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_3.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_71("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        let path = decodeURIComponent(url.pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\")
            .replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
        if (url.hostname != "") {
            path = `\\\\${url.hostname}${path}`;
        }
        return path;
    }
    exports_71("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_8_1) {
                _constants_ts_8 = _constants_ts_8_1;
            },
            function (_util_ts_3_1) {
                _util_ts_3 = _util_ts_3_1;
            },
            function (assert_ts_7_1) {
                assert_ts_7 = assert_ts_7_1;
            }
        ],
        execute: function () {
            exports_71("sep", sep = "\\");
            exports_71("delimiter", delimiter = ";");
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/posix", ["https://deno.land/std@0.74.0/path/_constants", "https://deno.land/std@0.74.0/path/_util"], function (exports_72, context_72) {
    "use strict";
    var _constants_ts_9, _util_ts_4, sep, delimiter;
    var __moduleName = context_72 && context_72.id;
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_4.assertPath(path);
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        }
        resolvedPath = _util_ts_4.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_4.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_72("resolve", resolve);
    function normalize(path) {
        _util_ts_4.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_9.CHAR_FORWARD_SLASH;
        path = _util_ts_4.normalizeString(path, !isAbsolute, "/", _util_ts_4.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_72("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_4.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
    }
    exports_72("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_4.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_72("join", join);
    function relative(from, to) {
        _util_ts_4.assertPath(from);
        _util_ts_4.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_9.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_9.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_72("relative", relative);
    function toNamespacedPath(path) {
        return path;
    }
    exports_72("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_4.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_72("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_4.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_72("basename", basename);
    function extname(path) {
        _util_ts_4.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_72("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_4._format("/", pathObject);
    }
    exports_72("format", format);
    function parse(path) {
        _util_ts_4.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_72("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    }
    exports_72("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_9_1) {
                _constants_ts_9 = _constants_ts_9_1;
            },
            function (_util_ts_4_1) {
                _util_ts_4 = _util_ts_4_1;
            }
        ],
        execute: function () {
            exports_72("sep", sep = "/");
            exports_72("delimiter", delimiter = ":");
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/separator", ["https://deno.land/std@0.74.0/path/_constants"], function (exports_73, context_73) {
    "use strict";
    var _constants_ts_10, SEP, SEP_PATTERN;
    var __moduleName = context_73 && context_73.id;
    return {
        setters: [
            function (_constants_ts_10_1) {
                _constants_ts_10 = _constants_ts_10_1;
            }
        ],
        execute: function () {
            exports_73("SEP", SEP = _constants_ts_10.isWindows ? "\\" : "/");
            exports_73("SEP_PATTERN", SEP_PATTERN = _constants_ts_10.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/common", ["https://deno.land/std@0.74.0/path/separator"], function (exports_74, context_74) {
    "use strict";
    var separator_ts_4;
    var __moduleName = context_74 && context_74.id;
    function common(paths, sep = separator_ts_4.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_74("common", common);
    return {
        setters: [
            function (separator_ts_4_1) {
                separator_ts_4 = separator_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/glob", ["https://deno.land/std@0.74.0/path/_constants", "https://deno.land/std@0.74.0/path/mod", "https://deno.land/std@0.74.0/path/separator"], function (exports_75, context_75) {
    "use strict";
    var _constants_ts_11, mod_ts_13, separator_ts_5, regExpEscapeChars, rangeEscapeChars;
    var __moduleName = context_75 && context_75.id;
    function globToRegExp(glob, { extended = true, globstar: globstarOption = true, os = _constants_ts_11.NATIVE_OS } = {}) {
        if (glob == "") {
            return /(?!)/;
        }
        const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
        const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
        const seps = os == "windows" ? ["\\", "/"] : ["/"];
        const globstar = os == "windows"
            ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*"
            : "(?:[^/]*(?:/|$)+)*";
        const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
        const escapePrefix = os == "windows" ? "`" : "\\";
        let newLength = glob.length;
        for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--)
            ;
        glob = glob.slice(0, newLength);
        let regExpString = "";
        for (let j = 0; j < glob.length;) {
            let segment = "";
            const groupStack = [];
            let inRange = false;
            let inEscape = false;
            let endsWithSep = false;
            let i = j;
            for (; i < glob.length && !seps.includes(glob[i]); i++) {
                if (inEscape) {
                    inEscape = false;
                    const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                    segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                    continue;
                }
                if (glob[i] == escapePrefix) {
                    inEscape = true;
                    continue;
                }
                if (glob[i] == "[") {
                    if (!inRange) {
                        inRange = true;
                        segment += "[";
                        if (glob[i + 1] == "!") {
                            i++;
                            segment += "^";
                        }
                        else if (glob[i + 1] == "^") {
                            i++;
                            segment += "\\^";
                        }
                        continue;
                    }
                    else if (glob[i + 1] == ":") {
                        let k = i + 1;
                        let value = "";
                        while (glob[k + 1] != null && glob[k + 1] != ":") {
                            value += glob[k + 1];
                            k++;
                        }
                        if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                            i = k + 2;
                            if (value == "alnum")
                                segment += "\\dA-Za-z";
                            else if (value == "alpha")
                                segment += "A-Za-z";
                            else if (value == "ascii")
                                segment += "\x00-\x7F";
                            else if (value == "blank")
                                segment += "\t ";
                            else if (value == "cntrl")
                                segment += "\x00-\x1F\x7F";
                            else if (value == "digit")
                                segment += "\\d";
                            else if (value == "graph")
                                segment += "\x21-\x7E";
                            else if (value == "lower")
                                segment += "a-z";
                            else if (value == "print")
                                segment += "\x20-\x7E";
                            else if (value == "punct") {
                                segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~";
                            }
                            else if (value == "space")
                                segment += "\\s\v";
                            else if (value == "upper")
                                segment += "A-Z";
                            else if (value == "word")
                                segment += "\\w";
                            else if (value == "xdigit")
                                segment += "\\dA-Fa-f";
                            continue;
                        }
                    }
                }
                if (glob[i] == "]" && inRange) {
                    inRange = false;
                    segment += "]";
                    continue;
                }
                if (inRange) {
                    if (glob[i] == "\\") {
                        segment += `\\\\`;
                    }
                    else {
                        segment += glob[i];
                    }
                    continue;
                }
                if (glob[i] == ")" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += ")";
                    const type = groupStack.pop();
                    if (type == "!") {
                        segment += wildcard;
                    }
                    else if (type != "@") {
                        segment += type;
                    }
                    continue;
                }
                if (glob[i] == "|" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("+");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("@");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "?") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("?");
                        segment += "(?:";
                    }
                    else {
                        segment += ".";
                    }
                    continue;
                }
                if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("!");
                    segment += "(?!";
                    continue;
                }
                if (glob[i] == "{") {
                    groupStack.push("BRACE");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                    groupStack.pop();
                    segment += ")";
                    continue;
                }
                if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "*") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("*");
                        segment += "(?:";
                    }
                    else {
                        const prevChar = glob[i - 1];
                        let numStars = 1;
                        while (glob[i + 1] == "*") {
                            i++;
                            numStars++;
                        }
                        const nextChar = glob[i + 1];
                        if (globstarOption && numStars == 2 &&
                            [...seps, undefined].includes(prevChar) &&
                            [...seps, undefined].includes(nextChar)) {
                            segment += globstar;
                            endsWithSep = true;
                        }
                        else {
                            segment += wildcard;
                        }
                    }
                    continue;
                }
                segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
            }
            if (groupStack.length > 0 || inRange || inEscape) {
                segment = "";
                for (const c of glob.slice(j, i)) {
                    segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                    endsWithSep = false;
                }
            }
            regExpString += segment;
            if (!endsWithSep) {
                regExpString += i < glob.length ? sep : sepMaybe;
                endsWithSep = true;
            }
            while (seps.includes(glob[i]))
                i++;
            if (!(i > j)) {
                throw new Error("Assertion failure: i > j (potential infinite loop)");
            }
            j = i;
        }
        regExpString = `^${regExpString}$`;
        return new RegExp(regExpString);
    }
    exports_75("globToRegExp", globToRegExp);
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_75("isGlob", isGlob);
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_13.normalize(glob);
        }
        const s = separator_ts_5.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_13.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_75("normalizeGlob", normalizeGlob);
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_13.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_5.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_75("joinGlobs", joinGlobs);
    return {
        setters: [
            function (_constants_ts_11_1) {
                _constants_ts_11 = _constants_ts_11_1;
            },
            function (mod_ts_13_1) {
                mod_ts_13 = mod_ts_13_1;
            },
            function (separator_ts_5_1) {
                separator_ts_5 = separator_ts_5_1;
            }
        ],
        execute: function () {
            regExpEscapeChars = ["!", "$", "(", ")", "*", "+", ".", "=", "?", "[", "\\", "^", "{", "|"];
            rangeEscapeChars = ["-", "\\", "]"];
        }
    };
});
System.register("https://deno.land/std@0.74.0/path/mod", ["https://deno.land/std@0.74.0/path/_constants", "https://deno.land/std@0.74.0/path/win32", "https://deno.land/std@0.74.0/path/posix", "https://deno.land/std@0.74.0/path/common", "https://deno.land/std@0.74.0/path/separator", "https://deno.land/std@0.74.0/path/_interface", "https://deno.land/std@0.74.0/path/glob"], function (exports_76, context_76) {
    "use strict";
    var _constants_ts_12, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_76 && context_76.id;
    var exportedNames_2 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_2.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_76(exports);
    }
    return {
        setters: [
            function (_constants_ts_12_1) {
                _constants_ts_12 = _constants_ts_12_1;
            },
            function (_win32_2) {
                _win32 = _win32_2;
            },
            function (_posix_2) {
                _posix = _posix_2;
            },
            function (common_ts_6_1) {
                exportStar_3(common_ts_6_1);
            },
            function (separator_ts_6_1) {
                exports_76({
                    "SEP": separator_ts_6_1["SEP"],
                    "SEP_PATTERN": separator_ts_6_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_2_1) {
                exportStar_3(_interface_ts_2_1);
            },
            function (glob_ts_2_1) {
                exportStar_3(glob_ts_2_1);
            }
        ],
        execute: function () {
            path = _constants_ts_12.isWindows ? _win32 : _posix;
            exports_76("win32", win32 = _win32);
            exports_76("posix", posix = _posix);
            exports_76("basename", basename = path.basename), exports_76("delimiter", delimiter = path.delimiter), exports_76("dirname", dirname = path.dirname), exports_76("extname", extname = path.extname), exports_76("format", format = path.format), exports_76("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_76("isAbsolute", isAbsolute = path.isAbsolute), exports_76("join", join = path.join), exports_76("normalize", normalize = path.normalize), exports_76("parse", parse = path.parse), exports_76("relative", relative = path.relative), exports_76("resolve", resolve = path.resolve), exports_76("sep", sep = path.sep), exports_76("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.74.0/fs/walk", ["https://deno.land/std@0.74.0/_util/assert", "https://deno.land/std@0.74.0/path/mod"], function (exports_77, context_77) {
    "use strict";
    var assert_ts_8, mod_ts_14;
    var __moduleName = context_77 && context_77.id;
    function _createWalkEntrySync(path) {
        path = mod_ts_14.normalize(path);
        const name = mod_ts_14.basename(path);
        const info = Deno.statSync(path);
        return {
            path,
            name,
            isFile: info.isFile,
            isDirectory: info.isDirectory,
            isSymlink: info.isSymlink,
        };
    }
    exports_77("_createWalkEntrySync", _createWalkEntrySync);
    async function _createWalkEntry(path) {
        path = mod_ts_14.normalize(path);
        const name = mod_ts_14.basename(path);
        const info = await Deno.stat(path);
        return {
            path,
            name,
            isFile: info.isFile,
            isDirectory: info.isDirectory,
            isSymlink: info.isSymlink,
        };
    }
    exports_77("_createWalkEntry", _createWalkEntry);
    function include(path, exts, match, skip) {
        if (exts && !exts.some((ext) => path.endsWith(ext))) {
            return false;
        }
        if (match && !match.some((pattern) => !!path.match(pattern))) {
            return false;
        }
        if (skip && skip.some((pattern) => !!path.match(pattern))) {
            return false;
        }
        return true;
    }
    async function* walk(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined, } = {}) {
        if (maxDepth < 0) {
            return;
        }
        if (includeDirs && include(root, exts, match, skip)) {
            yield await _createWalkEntry(root);
        }
        if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
            return;
        }
        for await (const entry of Deno.readDir(root)) {
            if (entry.isSymlink) {
                if (followSymlinks) {
                    throw new Error("unimplemented");
                }
                else {
                    continue;
                }
            }
            assert_ts_8.assert(entry.name != null);
            const path = mod_ts_14.join(root, entry.name);
            if (entry.isFile) {
                if (includeFiles && include(path, exts, match, skip)) {
                    yield { path, ...entry };
                }
            }
            else {
                yield* walk(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip,
                });
            }
        }
    }
    exports_77("walk", walk);
    function* walkSync(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined, } = {}) {
        if (maxDepth < 0) {
            return;
        }
        if (includeDirs && include(root, exts, match, skip)) {
            yield _createWalkEntrySync(root);
        }
        if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
            return;
        }
        for (const entry of Deno.readDirSync(root)) {
            if (entry.isSymlink) {
                if (followSymlinks) {
                    throw new Error("unimplemented");
                }
                else {
                    continue;
                }
            }
            assert_ts_8.assert(entry.name != null);
            const path = mod_ts_14.join(root, entry.name);
            if (entry.isFile) {
                if (includeFiles && include(path, exts, match, skip)) {
                    yield { path, ...entry };
                }
            }
            else {
                yield* walkSync(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip,
                });
            }
        }
    }
    exports_77("walkSync", walkSync);
    return {
        setters: [
            function (assert_ts_8_1) {
                assert_ts_8 = assert_ts_8_1;
            },
            function (mod_ts_14_1) {
                mod_ts_14 = mod_ts_14_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Jira-Work-Logger/base64", [], function (exports_78, context_78) {
    "use strict";
    var __moduleName = context_78 && context_78.id;
    function utf8_to_b64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }
    exports_78("utf8_to_b64", utf8_to_b64);
    function b64_to_utf8(str) {
        return decodeURIComponent(escape(window.atob(str)));
    }
    exports_78("b64_to_utf8", b64_to_utf8);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("file:///Jira-Work-Logger/filesContentGenerator", ["https://deno.land/std@0.74.0/fs/walk", "file:///Jira-Work-Logger/base64"], function (exports_79, context_79) {
    "use strict";
    var walk_ts_1, base64_ts_1;
    var __moduleName = context_79 && context_79.id;
    function encodeFileContent(content) {
        return base64_ts_1.utf8_to_b64(new TextDecoder().decode(content)).match(/.{1,1000}/g) || [];
    }
    exports_79("encodeFileContent", encodeFileContent);
    function decodeFileContent(encodedContent) {
        return base64_ts_1.b64_to_utf8(encodedContent.join(""));
    }
    exports_79("decodeFileContent", decodeFileContent);
    async function encodeFolder(path) {
        const files = {};
        for await (const entry of walk_ts_1.walk(path)) {
            if (entry.isFile) {
                const file = await Deno.open(entry.path, { read: true });
                const content = await Deno.readAll(file);
                Deno.close(file.rid);
                files[entry.path.replace(/^frontend\/build\//, "")] = encodeFileContent(content);
            }
        }
        return files;
    }
    return {
        setters: [
            function (walk_ts_1_1) {
                walk_ts_1 = walk_ts_1_1;
            },
            function (base64_ts_1_1) {
                base64_ts_1 = base64_ts_1_1;
            }
        ],
        execute: async function () {
            if (context_79.meta.main) {
                const files = await encodeFolder("./frontend/build");
                await Deno.writeTextFile("filesContent.ts", "export const files = " + JSON.stringify(files, null, " ") + "\n");
            }
        }
    };
});
System.register("file:///Jira-Work-Logger/router", ["https://deno.land/x/media_types@v2.5.1/mod", "file:///Jira-Work-Logger/filesContent", "file:///Jira-Work-Logger/hamster", "file:///Jira-Work-Logger/filesContentGenerator"], function (exports_80, context_80) {
    "use strict";
    var mod_ts_15, filesContent_ts_1, hamster_ts_1, filesContentGenerator_ts_1;
    var __moduleName = context_80 && context_80.id;
    async function jiraApi(config, query, options) {
        if (!config.jiraUrl.match(/^http/)) {
            throw new Error("bad jira url configuration");
        }
        const headers = new Headers();
        headers.append("Authorization", "Basic " + btoa(`${config.username}:${config.password}`));
        if (options?.body) {
            headers.append("Content-Type", "application/json");
        }
        const url = `${config.jiraUrl}/rest/api/2/${query}`;
        const response = await fetch(url, { ...options, headers });
        console.log(`%c[jiraApi] ${response.status} ${options?.method || "GET"} ${url}`, "color:green");
        return await response.json();
    }
    exports_80("jiraApi", jiraApi);
    async function jiraJql(config, jql) {
        return await jiraApi(config, `search?fields=summary,worklog&maxResults=20&jql=${jql.replaceAll(/\s+/g, " ")}`);
    }
    exports_80("jiraJql", jiraJql);
    function allowLocalhost(ctx) {
        const origin = ctx.request.headers.get("Origin");
        if (origin?.match(/http:\/\/localhost:.*/)) {
            ctx.response.headers.set("Access-Control-Allow-Origin", origin);
        }
    }
    function addStopRoute(router, controller) {
        router.post("/stop", (ctx) => {
            ctx.response.body = "stop ok";
            console.log("Stop");
            controller.abort();
        });
    }
    exports_80("addStopRoute", addStopRoute);
    function addStaticFilesRoutes(router) {
        if (filesContent_ts_1.files["index.html"]) {
            router.get("/", (ctx) => {
                ctx.response.body = filesContentGenerator_ts_1.decodeFileContent(filesContent_ts_1.files["index.html"]);
                ctx.response.type = mod_ts_15.lookup("index.html");
            });
        }
        Object.entries(filesContent_ts_1.files).map(([path, content]) => router.get(`/${path}`, (ctx) => {
            ctx.response.body = filesContentGenerator_ts_1.decodeFileContent(content);
            ctx.response.type = mod_ts_15.lookup(path);
        }));
    }
    exports_80("addStaticFilesRoutes", addStaticFilesRoutes);
    function addJiraRoutes(router) {
        router.post("/myLastIssues", async (ctx) => {
            const config = JSON.parse(await ctx.request.body().value);
            const jql = `
      (
        assignee = currentUser()
        AND ( resolution = Unresolved OR updatedDate >= startOfWeek() )
        AND updatedDate >= startOfYear()
      ) OR (
        worklogAuthor = currentUser() AND worklogDate > startOfWeek()
      )
      order by updatedDate DESC`;
            ctx.response.body = await jiraJql(config, jql);
            ctx.response.type = "application/json";
            allowLocalhost(ctx);
        });
        router.post("/issue/:issueKey", async (ctx) => {
            const config = JSON.parse(await ctx.request.body().value);
            ctx.response.body = await jiraApi(config, `issue/${ctx.params.issueKey}?fields=summary`);
            ctx.response.type = "application/json";
            allowLocalhost(ctx);
        });
        router.post("/createWorkLogs", async (ctx) => {
            const { config, toLog } = JSON.parse(await ctx.request.body().value);
            await Promise.all(toLog.map((log) => jiraApi(config, `issue/${log.key}/worklog`, {
                method: "POST",
                body: JSON.stringify({
                    comment: log.comment,
                    started: `${log.date}T20:00:00.000+0000`,
                    timeSpent: `${log.hours}h`,
                }),
            })));
            ctx.response.body = '{"status":"OK"}';
            ctx.response.type = "application/json";
            allowLocalhost(ctx);
        });
    }
    exports_80("addJiraRoutes", addJiraRoutes);
    function addHamsterRoute(router) {
        router.get("/hamsterExport", async (ctx) => {
            const ignoreCategories = ctx.request.url.searchParams.get("ignore");
            const hamsterDaysToImport = Number(ctx.request.url.searchParams.get("hamsterDaysToImport") || 5);
            const begin = new Date(Date.now() - 1000 * 60 * 60 * 24 * hamsterDaysToImport).toISOString().substr(0, 10);
            const end = new Date().toISOString().substr(0, 10);
            console.log(`%c[hamsterExport] hamsterDaysToImport=${hamsterDaysToImport} begin=${begin} end=${end}`, "color:indigo");
            ctx.response.body = await hamster_ts_1.getHamsterReport(begin, end, ignoreCategories);
            ctx.response.type = "application/json";
            allowLocalhost(ctx);
        });
    }
    exports_80("addHamsterRoute", addHamsterRoute);
    return {
        setters: [
            function (mod_ts_15_1) {
                mod_ts_15 = mod_ts_15_1;
            },
            function (filesContent_ts_1_1) {
                filesContent_ts_1 = filesContent_ts_1_1;
            },
            function (hamster_ts_1_1) {
                hamster_ts_1 = hamster_ts_1_1;
            },
            function (filesContentGenerator_ts_1_1) {
                filesContentGenerator_ts_1 = filesContentGenerator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Jira-Work-Logger/server", ["https://deno.land/x/oak@v6.3.1/mod", "file:///Jira-Work-Logger/opn", "file:///Jira-Work-Logger/router"], function (exports_81, context_81) {
    "use strict";
    var mod_ts_16, mod_ts_17, opn_ts_1, router_ts_2, port, controller, oakApp, router;
    var __moduleName = context_81 && context_81.id;
    return {
        setters: [
            function (mod_ts_16_1) {
                mod_ts_16 = mod_ts_16_1;
                mod_ts_17 = mod_ts_16_1;
            },
            function (opn_ts_1_1) {
                opn_ts_1 = opn_ts_1_1;
            },
            function (router_ts_2_1) {
                router_ts_2 = router_ts_2_1;
            }
        ],
        execute: function () {
            port = 8000;
            controller = new AbortController();
            oakApp = new mod_ts_17.Application();
            oakApp.addEventListener("error", (evt) => console.log(evt.error));
            oakApp.addEventListener("listen", async () => {
                console.log(`Listening on: http://localhost:${port}`);
                opn_ts_1.opn(`http://localhost:${port}`, { checkDenoPermission: true }).catch(() => console.log("Run permission is missing, the hamster import will not work, and the localhost url was not opened in the default web browser at launch"));
            });
            router = new mod_ts_16.Router();
            router_ts_2.addStopRoute(router, controller);
            router_ts_2.addStaticFilesRoutes(router);
            router_ts_2.addJiraRoutes(router);
            router_ts_2.addHamsterRoute(router);
            oakApp.use(router.routes());
            oakApp.listen({ hostname: "127.0.0.1", port, signal: controller.signal });
        }
    };
});

await __instantiate("file:///Jira-Work-Logger/server", true);
